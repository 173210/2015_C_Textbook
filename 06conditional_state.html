<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>第6章 ～条件文～</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/sanitize.css/2.0.0/sanitize.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <script src="./syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushPlain.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushCpp_kai.js" type="text/javascript"></script>
    <link href="./syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css">
    <link href="./syntaxhighlighter/styles/shThemeMidnight_likeVS.css" rel="stylesheet" type="text/css">
    <script src="./scripts/common.js" type="text/javascript"></script>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <h1>第6章 ～条件文～</h1>
    <nav class="top">
        <ul>
            <li><a href="./05function.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./07roop_and_split_Sourcecode.html" title="次頁">next</a></li>
        </ul>
    </nav>
    <section>
        <h2>bool型と_BOOL型とBOOL型と</h2>
        <p>
            C++では当初から真と偽を表すbool型が導入され、C言語でもC99で<code>stdbool.h</code>をincldueすることによりbool型が使えるようになりました。
        </p>
        <pre class="brush: cpp; first-line: 24;" title="stdbol.h (mingw32)">/*
 * ISO C Standard:  7.16  Boolean type and values  &lt;stdbool.h&gt;
 */

#ifndef _STDBOOL_H
#define _STDBOOL_H

#ifndef __cplusplus

#define bool    _Bool
#define true    1
#define false   0

#else /* __cplusplus */

/* Supporting &lt;stdbool.h&gt; in C++ is a GCC extension.  */
#define _Bool   bool
#define bool    bool
#define false   false
#define true    true

#endif /* __cplusplus */

/* Signal that all the definitions are present.  */
#define __bool_true_false_are_defined   1

#endif  /* stdbool.h */</pre>
        <p>
            C99のbool型は_BOOL型をマクロを使って実装しています（マクロが何かは後ほど）。<br>
            実際に使い方を見ましょう。C++ではstdbool.hのincludeは不要です(無理にincludeしても勝手にincldueを外されます)。だってC++の基本型だし。
        </p>
        <pre class="brush: cpp;">#include &lt;stdbool.h&gt;
int main(void){
    //前略
    bool no_first_skip = true;
    bool no_dct_decimate = false;
    //後略
    return 0;
}</pre>
        <p>C99/C++のbool型は、真と偽はtrueとfalseに対応し、int型に変換すると1と0になります。それ以外の値を入れられることは保証されていません。</p>
        <p>
            さて、ここまでならなんら問題はなかったのですが、問題はBOOL型です。ここでいうBOOL型はWin32APIのBOOL型です。<br>
            Win32APIのBOOL型は何をキチがえたのか、平気で負の値とかが入っていたりします。それもそのはず、ただ単にint型をtypedefしてBOOL型を作っているからです。<br>
            これにはC言語が真と偽を非0と0に対応づけてきた歴史も関わってきます。<br>
            なにが言いたいかというと、false(FALSE)が0であることは保証されているが、true(TRUE)が1であることは保証されない、ということです。<br>
            うっかりすると足を救われるので注意です。
        </p>
    </section>
    <section>
        <h2>条件文</h2>
        <p>
            前にbit演算のところでAND演算とかOR演算とかやったと思いますが、それをbit単位でなく、変数単位でやるのが条件文です。<br>
            条件文の演算結果は事実上bool型になります。つまり、真と偽は、1と0に対応します。例を見てみましょう。
        </p>
        <pre class="brush: cpp;">int a = 10;
int tmp = (5 == a);//0になる</pre>
        <p>条件文は多くの場合大小比較や同値比較と同時に用いられるので、その演算子をまとめておきましょう。</p>
        <table>
            <tr>
                <th>演算子</th>
                <th>意味</th>
            </tr>

            <tr>
                <td>==</td>
                <td>等しい</td>
            </tr>
            <tr>
                <td>!=</td>
                <td>等しくない</td>
            </tr>
            <tr>
                <td>&lt;=</td>
                <td>(左は)(右)以下である</td>
            </tr>
            <tr>
                <td>&gt;=</td>
                <td>(右は)(左)以下である</td>
            </tr>
            <tr>
                <td>&lt;</td>
                <td>(左は)(右)より小さい</td>
            </tr>
            <tr>
                <td>&gt;</td>
                <td>(左は)(右)より大きい</td>
            </tr>
        </table>
        <p>これに加えてAND,OR,NOT演算子があります</p>
        <table>
            <tr>
                <th>演算子</th>
                <th>意味</th>
            </tr>
            <tr>
                <td>&amp;&amp;</td>
                <td>かつ(AND)</td>
            </tr>
            <tr>
                <td>||</td>
                <td>または(OR)</td>
            </tr>
            <tr>
                <td>!</td>
                <td>否定(NOT)</td>
            </tr>
        </table>
    </section>
    <section>
        <h2>if文</h2>
        <p>条件式をそれ単体で使うことは、そこまで多くなく、if文やこの後紹介するwhile,for,do-while文と共に用いられます。</p>
        <p>if文はプログラムを組む上で無くてはならないものです。例を見てみましょう。</p>
        <pre class="brush: cpp;">if(条件式)
    //条件式が真の時
else
    //条件式が偽の時</pre>
        <p>
            この書き方だと処理が一行しか書けません。複数行書くときは{}を使います。<br>
            気をつけて欲しいのですが、{}がなくともスコープがあります。ところで言うまでもないですが、else節はなくても構いません。
        </p>
        <pre class="brush: cpp;">int first_number, second_number, third_number, max_number, center_number, min_number;
//3つの変数になにか値を代入
if (first_number > second_number){//１番目の数と２番めの数を比較
	max_number = first_number;
	center_number = second_number;
}
else{
	max_number = second_number;
	center_number = first_number;
}
if (third_number > max_number){//３番めの数と上で出した「１番目の数と２番めの数」の大きい方と比較
	min_number = center_number;
	center_number = max_number;
	max_number = third_number;
}
else if(third_number > center_number){//３番めの数と上で出した「１番目の数と２番めの数」の小さい方と比較
	min_number = center_number;
	center_number = third_number;
}
else{//3番目の数が最小の時
	min_number = third_number;
}</pre>
        <p>このようにif文 else if のように連ねて書くことも可能です。</p>
        <pre class="brush: cpp;">if(5 == a)
    int x = 7;
else
    x = 6;//これはだめ
</pre>
        <p>そもそもif文の中で変数を宣言しないようにしましょう。<b>変数を宣言したい、そう思ったら、直ちにその部分を関数化</b>しましょう。</p>
        <section class="technique">
            <h4>コーディングの作法</h4>
            <p>if文では、else節に正常な動作を書くと、多くの場合ですっきり書けます。</p>
            <pre class="brush: cpp;">if(条件文){
    //エラー処理
}
else{
    //正常動作
}</pre>
            <p>大切なのが、正常な動作の時の流れがもっとも簡潔であるように書くことです。</p>
            <p>また、条件式を書く上での注意ですが、同値比較(==)は「=」が2つですが、ついうっかり1つにしてしまいがちです。そこで、このように書くようにしましょう</p>
            <pre class="brush: cpp;">if(5 == a)//正しい書き方
if(a == 5)//これも正しい書き方だが、推奨しない、ミスの元
if(5 = a)//これはコンパイルエラー
if(a = 5)//これはコンパイルエラーにならない、aに代入した後のaが0か否かが判別される</pre>
            <p>
                constがついた変数や、数値、マクロで定義された値を左側、変数を右側に持っていくようにします。<br>
                こうすることで、書き間違えた時にコンパイルエラーになります。(変更不可能なものに代入しようとしています、など)
            </p>
            <p>エラー処理等、明確に実行文が1行しかない、と言える時を除き、原則{}はつけましょう。あとで文が増えた時に付け忘れるのを防ぐことができます。</p>
        </section>
        <section>
            <h2>練習問題１</h2>
            <p>
                if文を使い、入力された点数が<br>
                ９０点以上：Ｓ<br>
                ８０～８９点：Ａ<br>
                ７０～７９点：Ｂ<br>
                ６０～６９点：Ｃ<br>
                ５９点以下：Ｄ<br>
                と表示するプログラムを作れ。<br>
                ただし、メイン関数は６行以内に留めること。<br>
                専用解答用紙ならぬ専用解答用プロジェクトは<a href="./file/Unit6_Question1AnswerSheet.zip">こちら</a>からダウンロードできます。Macの方は<a href="./file/Mac_AnswerSheet.zip">こちら</a>をダウンロードし、中身をコピペして使ってください。<br>
                値の取得にscanf_sを使われるのが嫌なので作りました。専用解答用プロジェクトとかなってますが、練習問題２でも使えます。<br>
                でもコピるのめんｄいだろうから練習問題２にも専用解答用プロジェクトつけてあるのでコピらなくてもおｋです。<br>
            </p>
        </section>
    </section>

    <section>
        <h2>3項演算子</h2>
        <p>if文とは一味ちがう書き方です。見てみましょう。</p>
        <pre class="brush: cpp" title="3項演算子を使って書く">const int hoge = 17;
const int isEven = (hoge % 2)? 1324 : 2432;</pre>
        <pre class="brush: cpp;" title="if文で書く">const int hoge = 17;
int isEven;
if(hoge % 2){
    isEven = 1324;
}
else{
    isEven = 2432;
}</pre>
        <p>if文を使って書くより簡単ですし(スコープの問題がない)、代入する変数にconstが付けられます(ワタシ的にはここが美味しい)</p>
        <p>
            この書きかたですが、「一行で」かけるので、後に説明するプリプロセッサマクロでしばしば用いられます。<br>
            ・・・って私は教わったんだけど、マクロにして使ったことってないなぁ。それくらいならinline関数(C++の機能)にしちゃうし。
        </p>
    </section>
    <section>
        <h2>switch文</h2>
        <p>if文が高級な条件分岐文とするならば、switch文は低級な条件分岐文といえますが、最大のメリットは、一度の条件式で複数の分岐が作れることです。</p>
        <pre class="brush: cpp;">char time_when;
//do something
switch (time_when)
{
case 'a':
	puts("朝");
	break;
case 'b':
	puts("昼");
	break;
case 'c':
	puts("夜");
    break;
default:
	break;
}</pre>
        <p>
            switch文には必ず「default:」を書きましょう。<br>
            「case 'c':」とかは「ラベル」といいます。後述するgoto文にも登場するので頭の片隅においておいてください。<br>
            「break;」はswitch文を抜け出すために用います。もし、6行目の「break;」がなかった場合、5行目を実行した後8行目を実行します。つまり必ずしもbreakは必須ではありません。<br>
            switch文を「低級な条件分岐文」と表現したのは、アセンブリコードのjmp命令にそっくりの構文だからです。
        </p>
        <p>このjmp命令にそっくりという性質を活かして</p>
        <pre class="brush: cpp;">send(register short *to, register short *from, register count)
{
	register n = (count + 7) / 8;
	switch(count % 8) {
	case 0:	do {	*to = *from++;
	case 7:		*to = *from++;
	case 6:		*to = *from++;
	case 5:		*to = *from++;
	case 4:		*to = *from++;
	case 3:		*to = *from++;
	case 2:		*to = *from++;
	case 1:		*to = *from++;
		} while(--n > 0);
	}
}</pre>
        <p>なんていう、わけわかめなプログラム(<a href="http://ja.wikipedia.org/wiki/Duff%27s_device">Duff's device</a>というプログラム高速化のための最適化技法)を書いた人が居ますが、やめましょう。</p>
        <p>このswitch文、あとで出てくる列挙型(enum)とものすごく相性がいいです。#defineをわんさか書こうとしているそこのアナタ、enumを使いましょう。</p>
        <section>
            <h2>練習問題２</h2>
            <p>
                switch文を使い、ダウンロードファイル内にあるアプリケーションのプログラムを再現せよ。<br>
                ただし、メイン関数は１０行以内に収めること。<br>
                この問題で使うファイルのダウンロードは<a href="./file/Unit6_Question2Pack.zip">こちら</a><br>
                Macの方は<a href="./file/Mac_Unit6_Question2Pack.zip">こちら</a>をダウンロードしてください。
            </p>
        </section>
    </section>
    <section>
        <h3>enum型(列挙型)</h3>
        <p>enum型とは列挙型と呼ばれており、switch文と相性がいいんです（気づくまでに時間がかかった人）。</p>
        <pre class="brush: cpp;">enum status{
    STATE_TITLE,//タイトル
    STATE_MAIN,//メイン
    STATE_END,//リザルト
};</pre>
        <p>ここでstatusはタグ名と言います。タグ名を除いた";"の前まで全体が型となります。enumはtypedefして初めて真価を発揮します。</p>
        <pre class="brush: cpp;">typedef enum{
    STATE_TITLE,//タイトル
    STATE_MAIN,//メイン
    STATE_END,//リザルト
}status_t;</pre>
        <p>typedefするときはタグ名は省略してもいいです。なお、「STATE_ENDのあとになんで","が置けるんだ？」と思ったあなた、よく勉強しています。enumに関しては書けるんです(C89からだっけ・・・？)</p>
        <p>実際に例を見ていきましょう</p>
        <pre class="brush: cpp;">#include&lt;stdio.h&gt;
#include&lt;dxlib.h&gt;
//  ゲーム状態
typedef enum{
    STATE_TITLE,//タイトル
    STATE_MAIN,//メイン
    STATE_END,//リザルト
}status_t;
//タイトル処理
status_t title(){
    //タイトルを描画
    //クリック押されたら
    return STATE_END;
}
//ゲームのメイン処理
status_t gameMain(){
    //ゲーム処理
    //ゲーム終了したら
    return STATE_END;
}
//リザルト画面など
status_t ending(){
    //リザルト画面描画
    //クリック押されたら
    return STATE_MAIN;
}
int main(){
    status_t function_status = STATE_TITLE;
    while(1){
        switch (function_status){
            case STATE_TITLE:
                function_status = title();
                break;
            case STATE_MAIN:
                function_status = gameMain();
                break;
            case STATE_END:
                function_status = ending();
                break;
            default:
                return -1;//エラー
        }
    }
   return 0;
}
</pre>
        <p>
            このようにゲームなど状態を管理するときに非常に便利です。<br>
            まあ、戻り値にするよりポインターか参照(いずれも後述)を使って引数経由でやったほうがいい気もするけど、ケース・バイ・ケースなので。<br>
            ていうか教えてないし。
        </p>
    </section>
    <section>
        <h2>enum class</h2>
        <p>
            C言語のenumはグローバル空間で宣言されるため、名前衝突の危険が有りました。
            enum classはscoped enumerationとかStrongly Typed Enumsとも呼ばれ、その名の通りスコープの概念があるenumとなっています。<br>
            N2347 | Strongly Typed Enums (revision 3)<br>
            <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf</a><br>
            規格準拠の遅いVisual Studioでもかなり昔から使えたC++11の機能です。
        </p>
        <pre class="brush: cpp;">enum class PrimitiveType: std::size_t
{
    TriangleList = 0,
    TriangleStrip,
    LineList,
    LineStrip,
};
//中略
PrimitiveType primitiveType = PrimitiveType::TriangleStrip;</pre>
        <p>
            Cのenumと違い、いちいちtypedefする必要はありません。<br>
            「PrimitiveType」はidentifierと呼ばれ、この列挙型の型名となります。<br>
            「TriangleList」とか「TriangleStrip」とかは列挙子と呼ばれます。<br>
            identifierの後に「: [型名]」のように続いていますが、これらは列挙子の内部的な型を指定します。省略するとint型になります。
        </p>
        <p>enum classでは厳密に型が判定されるので以下の例はすべてダメです。</p>
        <pre class="brush: cpp;" title="ダメな例">int           primitiveType1 = PrimitiveType::TriangleList; // error
unsigned char primitiveType2 = PrimitiveType::TriangleList; // error
std::size_t   primitiveType3 = PrimitiveType::TriangleList; // error</pre>
        <p>このように書き換える必要があります。</p>
        <pre class="brush: cpp;" title="正しい例">PrimitiveType primitiveType4 = PrimitiveType::TriangleList;
std::size_t primitiveType5 = static_cast&lt;std::size_t&gt;(PrimitiveType::TriangleList);</pre>
        <p>もちろんこれもダメです。どうやって<code>size_t</code>型で負の値を表すのさ、unsignedなのに。</p>
        <pre class="brush: cpp;" title="enum classの中だって型がチェックされる">enum class PrimitiveType: std::size_t
{
    TriangleList = -1, // error, Enumerator value evaluates to -1, which cannot be narrowed to type 'std::size_t'
};</pre>
        <p>早速例を見ましょう。</p>
        <pre class="brush: cpp;">#include&lt;stdio.h&gt;
//#include&lt;dxlib.h&gt;
//  ゲーム状態
enum class status_t{
	STATE_TITLE,//タイトル
	STATE_MAIN,//メイン
	STATE_END,//リザルト
};
//タイトル処理
status_t title(){
	//タイトルを描画
	//クリック押されたら
	return status_t::STATE_END;
}
//ゲームのメイン処理
status_t gameMain(){
	//ゲーム処理
	//ゲーム終了したら
	return status_t::STATE_END;
}
//リザルト画面など
status_t ending(){
	//リザルト画面描画
	//クリック押されたら
	return status_t::STATE_MAIN;
}
int main(){
	status_t function_status = status_t::STATE_TITLE;
    while(1){
    	switch (function_status){
    	case status_t::STATE_TITLE:
    		function_status = title();
    		break;
    	case status_t::STATE_MAIN:
    		function_status = gameMain();
    		break;
    	case status_t::STATE_END:
    		function_status = ending();
    		break;
    	default:
    		return -1;//エラー
    	}
    }
	return 0;
}</pre>
        <p>
            参考サイト<br>
            C3(Composite Computer Club)  »  5月22日は enum class の話。（1日目 #毎日3分 C++11。）<br>
            <a href="http://www.c3.club.kyutech.ac.jp/archives/1614">http://www.c3.club.kyutech.ac.jp/archives/1614</a><br>
            C++11 における enum のまとめ - spinorの日記<br>
            <a href="http://d.hatena.ne.jp/spinor/20110918/1316321563">http://d.hatena.ne.jp/spinor/20110918/1316321563</a><br>
            enumのスコープを指定する方法 - CREST’S WEBLOG <br>
            <a href="http://d.hatena.ne.jp/Crest/20111020/1319113048">http://d.hatena.ne.jp/Crest/20111020/1319113048</a><br>
            C++ 列挙体の宣言 | MSDN<br>
            <a href="https://msdn.microsoft.com/ja-jp/library/2dzy4k6e.aspx">https://msdn.microsoft.com/ja-jp/library/2dzy4k6e.aspx</a>
        </p>
    </section>
    <nav class="bottom">
        <ul>
            <li><a href="./05function.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./07roop_and_split_Sourcecode.html" title="次頁">next</a></li>
        </ul>
    </nav>
</body>
</html>