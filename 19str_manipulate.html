<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>第19章 ～文字列操作～</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/sanitize.css/2.0.0/sanitize.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <script src="./syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushPlain.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushCpp_kai.js" type="text/javascript"></script>
    <link href="./syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css">
    <link href="./syntaxhighlighter/styles/shThemeMidnight_likeVS.css" rel="stylesheet" type="text/css">
    <script src="./scripts/common.js" type="text/javascript"></script>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
    <style type="text/css">
        .scroll_box{
            height: 200px;
            overflow-y: scroll;
        }
    </style>
</head>
<body>
    <h1>第19章 ～文字列操作～</h1>
    <nav class="top">
        <ul>
            <li><a href="./18c_char_str_base.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./" title="次頁">next</a></li>
        </ul>
    </nav>
    <section>
        <h2>初めに</h2>
        <p>
            C言語最難関の文字列操作です。ひたすら気を使わないといけないことが多い、<b>心折設計</b>となっております。<br>
            ここでは、Cでの文字列操作の難しさを苦しみつつ体感していただきつつ、C++のSTL、std::stringの便利さを痛感していただければ、と思います。<br>
            その前に一言。Cで文字列操作するならとりあえずsprintf使え。
        </p>
    </section>
    <section>
        <h2>strlen</h2>
        <p>文字列の長さを求める関数です。といってもマルチバイト文字は考慮しないのでNULL文字を除くbyte数を求めることになります。プロトタイプ宣言を見てみましょう。</p>
        <pre class="brush: cpp;" title="プロトタイプ宣言">size_t strlen(const char *str);</pre>
        <p>使用例を見ましょう。</p>
        <pre class="brush: cpp;" title="使用例">#include &lt;stdio.h>
#include &lt;string.h>
int main(){
    const char* str = "arikitari_na_world!";
    printf("文字列%sの長さは\n%zu\n", str, strlen(str));
    return 0;
}</pre>
        <p>
            使い方もわかりやすいのでいいですね。・・・と言いたいのですが、使用には実は細心の注意が必要です。<br>
            <a href="http://mavericktse.mooo.com/wordpress/archives/1982">Do not use strlen() family to determine size of dynamic array! | 舶来ゴミ置き場</a><br>
            Cで文字列操作といえばほぼ例外なくsprintf系関数を使うのですが、その書き込み先のサイズ指定にstrlenを用いてはいけません。<br>
            なぜならば、strlenで取得できるのはあくまで文字列の長さであって、確保しているメモリサイズではないからです。<br>
            strlen関数は便利でいいのですが、過去の私みたいに落とし穴にハマることの無いよう、お気をつけ下さい。
        </p>
        <p>では、このstrlen関数を自作してみましょう。まあnull文字が出るまでfor回すだけだから楽勝だよね？</p>
        <section>
            <h3>ヘッダー</h3>
            <pre class="brush: cpp;" title="strlen.h">#if (defined(_MSC_VER) &amp;&amp; _MSC_VER > 1000) || (defined(__clang__) &amp;&amp; (__clang_major__ > 3 || (__clang_major__ == 3 &amp;&amp; __clang_minor__ > 2))) ||(defined(__ICC) &amp;&amp; __ICC > 1000) ||defined (__GNUC__) &amp;&amp; !defined(__ICC) &amp;&amp; !defined(__clang__) &amp;&amp; (__GNUC__ >= 4 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ >= 4))
#pragma once
#endif
#ifndef _INC_MY_STRLEN_H
#define _INC_MY_STRLEN_H
#include &lt;cstddef>
size_t my_strlen(const char *str);
#endif</pre>
        </section>
        <section class="scroll_box">
            <h3>使用例</h3>
            <pre class="brush: cpp;" title="main.cpp">#include &lt;iostream>
#include &lt;cstring>
#include "strlen.h"
void strlen_and_do(const char* str, auto (*getstrlen)(const char*) -> size_t, const char* message){
    std::cout &lt;&lt; message &lt;&lt; "を呼び出します" &lt;&lt; std::endl;
    const auto re = getstrlen(str);
    if (0 == re){
        std::cout &lt;&lt; "エラーなんだぜ" &lt;&lt; std::endl;
    }
    else{
        std::cout &lt;&lt; re &lt;&lt; "文字だよ" &lt;&lt; std::endl;
    }
}
int main(void){
    auto str = "arikitari_na_world!";

    std::cout &lt;&lt; "base_str : " &lt;&lt; str &lt;&lt; std::endl;

    strlen_and_do(str, strlen, "string.hのstrlen関数");
    strlen_and_do(str, my_strlen, "strlen.hのmy_strlen関数");
    return 0;
}
</pre>
        </section>
        <pre class="brush: plain" title="望ましい実行例1">$ ./strlen.exe
base_str : arikitari_na_world!
string.hのstrlen関数を呼び出します
19文字だよ
strlen.hのmy_strlen関数を呼び出します
19文字だよ</pre>
        <form><input type="button" value="答えを 表示/非表示" onclick="change_answer_state('my_strlen')"></form>
        <section id="my_strlen" style="display: none;">
            <h4>回答</h4>
            <pre class="brush: cpp;" title="strlen.cpp">#include "strlen.h"
#include &lt;limits>
size_t my_strlen(const char *str){
    if (nullptr == str) return 0;
    const auto search_limits = std::numeric_limits&lt;size_t>::max();//無限ループ防止
    size_t len;
    for (len = 0; search_limits > len &amp;&amp; '\0' != str[len]; len++);
    return (search_limits == len) ? 0 : len;
}
</pre>
        </section>
    </section>
    <section>
        <h2>strchr</h2>
        <p>
            指定した文字を文字列中から検索し、最初に見つかった場所へのポインタを返します。<br>
            見つからない場合はnullptrを返します。
        </p>
        <pre class="brush: cpp;" title="使用例">#Include &lt;stdio.h>
int main(){
    char buf[1024];
    fgets(buf, 1024, stdin);
    strchr(buf, '\n')[0] = '\0';

    puts(buf);

    return 0;
}</pre>
        <p>というわけで作りましょう、これまたfor書くだけの簡単なお仕事。</p>
        <section>
            <h3>ヘッダー</h3>
            <pre class="brush: cpp; highlight: [14, 16];" title="strlen.h">#if (defined(_MSC_VER) &amp;&amp; _MSC_VER > 1000) || (defined(__clang__) &amp;&amp; (__clang_major__ > 3 || (__clang_major__ == 3 &amp;&amp; __clang_minor__ > 2))) ||(defined(__ICC) &amp;&amp; __ICC > 1000) ||defined (__GNUC__) &amp;&amp; !defined(__ICC) &amp;&amp; !defined(__clang__) &amp;&amp; (__GNUC__ >= 4 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ >= 4))
#pragma once
#endif
#include &lt;stddef.h>
#ifndef _CONST_RETURN//for msys2 mingw64 clang 3.5.1.
#ifdef __cplusplus
#define _CONST_RETURN  const
#define _CRT_CONST_CORRECT_OVERLOADS
#else  /* __cplusplus */
#define _CONST_RETURN
#endif  /* __cplusplus */
#endif  /* _CONST_RETURN */
#ifdef __cplusplus
char * mystrchr(char * str, int character);
#endif
_CONST_RETURN char * mystrchr(const char * str, int character);
</pre>
        </section>
        <section class="scroll_box">
            <h3>使用例</h3>
            <pre class="brush: cpp;" title="main.cpp">#include "strchr.h"
#include &lt;cstdio>
#include &lt;cstring>
using strchr_t = char* (*)(char*, int);
template&lt;size_t SIZE>void replace_newline_char(char (&amp;str)[SIZE], const char* func_name, strchr_t func) {
    printf("関数名: %s\n", func_name);
    printf("Before: %s\n", str);
    func(str, '\n')[0] = '\0';
    printf("After: %s\n", str);
}
int main() {
    constexpr size_t arr_size = 1024;
    char str1[arr_size], str2[arr_size];
    puts("文字列を入力してください");
    fgets(str1, arr_size, stdin);
    memcpy(str2, str1, strlen(str1) + 1);

    replace_newline_char(str1, "strchr", strchr);
    replace_newline_char(str2, "mystrchr", mystrchr);

    return 0;
}</pre>
        </section>
        <pre class="brush: plain" title="望ましい実行例1">$ ./strchr.exe
文字列を入力してください
arikitari_na_world!
関数名: strchr
Before: arikitari_na_world!

After: arikitari_na_world!
関数名: mystrchr
Before: arikitari_na_world!

After: arikitari_na_world!
</pre>
        <form><input type="button" value="答えを 表示/非表示" onclick="change_answer_state('my_strchr')"></form>
        <section id="my_strchr" style="display: none;">
            <h4>回答</h4>
            <pre class="brush: cpp;" title="strlen.cpp">#include "strchr.h"
#ifdef __cplusplus
char * mystrchr(char * str, int character) {
    size_t i;
    for (i = 0; '\0' != str[i] &amp;&amp; character != str[i]; ++i);
    return (character != str[i]) ? nullptr : &amp;str[i];
}
#endif
_CONST_RETURN char * mystrchr(const char * str, int character) {
    return mystrchr(const_cast&lt;char*>(str), character);
}</pre>
        </section>
    </section>
    <section>
        <h2>strcmp</h2>
        <p>
            文字列を比較する関数です。第1引数の文字列のと第2引数の文字列を1文字づつ比較していきます。<br>
            文字が一致しなくなるかnull文字に遭遇するとループを終了し値をかえします。<br>
            そのときその文字コードが第一引数のほうが大きかったら正の値を、小さかったら負の値を、両方同じなら0を返します。<br>
            正の値とは具体的に何かというと実装依存ですが、MSVCもgccもclangも1を返すようです。負の値は同様に-1のようです。
        </p>
        <pre class="brush: cpp;" title="プロトタイプ宣言">int strcmp ( const char * str1, const char * str2 );</pre>
        <pre class="brush: cpp;" title="実行例">#include &lt;stdio.h>
#include &lt;string.h>
int main(){
    char buf[1024];
    fgets(buf, 1024, stdin);
    strchr(buf, '\n')[0] = '\0';
    if(0 == strcmp("add", buf)){
        puts("足し算");
    }
    else if(0 == strcmp("sub", buf)){
        puts("引き算");
    }
    else if(0 == strcmp("mul", buf)){
        puts("掛け算");
    }
    else if(0 == strcmp("div", buf)){
        puts("割り算");
    }
    else{
        puts("unknown command");
    }
    return 0;
}</pre>
        <section>
            <h3>ヘッダー</h3>
            <pre class="brush: cpp;" title="strcmp.h">#if (defined(_MSC_VER) &amp;&amp; _MSC_VER > 1000) || (defined(__clang__) &amp;&amp; (__clang_major__ > 3 || (__clang_major__ == 3 &amp;&amp; __clang_minor__ > 2))) ||(defined(__ICC) &amp;&amp; __ICC > 1000) ||defined (__GNUC__) &amp;&amp; !defined(__ICC) &amp;&amp; !defined(__clang__) &amp;&amp; (__GNUC__ >= 4 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ >= 4))
#pragma once
#endif
#ifndef _INC_MY_STRLEN_H
#define _INC_MY_STRLEN_H
int my_strcmp(const char *string1, const char *string2);
#endif</pre>
        </section>
        <section class="scroll_box">
            <h3>使用例</h3>
            <pre class="brush: cpp;" title="main.cpp">#include &lt;iostream>
#include &lt;cstdio>
#include &lt;cstring>
#include "strcmp.h"
using strcmp_t = int (*)(const char*, const char*);
void strstr_and_do(const char* str1, const char* str2, strcmp_t strcomare, const char* message){
    std::cout &lt;&lt; message &lt;&lt; "を呼び出します" &lt;&lt; std::endl;
    const auto re = strcomare(str1, str2);
    if (0 == re){
        std::cout &lt;&lt; "\"" &lt;&lt; str1 &lt;&lt; "\", \"" &lt;&lt; str2 &lt;&lt; "\" は一致しました" &lt;&lt; std::endl;
    }
    else{
        std::cout &lt;&lt; re &lt;&lt; " = strcmp(\"" &lt;&lt; str1 &lt;&lt; "\", \"" &lt;&lt; str2 &lt;&lt; "\")  戻り値 :" &lt;&lt; ((re > 0) ? '>' : '&lt;') &lt;&lt; "0" &lt;&lt; std::endl;
    }
}
int main(void){
    auto str1 = "arikitari_na_world!";
    const char* str2[] = { "akrikitariahanai", "arikitari_na_world", "arikitari_na_world!", "arikitari_na_world!!", "arikitari_na_world_" };

    for (auto i : str2){
        strstr_and_do(str1, i, strcmp, "string.hのstrcmp関数");
        strstr_and_do(str1, i, my_strcmp, "strcmp.hのmy_strcmp関数");
        std::cout &lt;&lt; std::endl;
    }
    return 0;
}
</pre>
        </section>
        <form><input type="button" value="答えを 表示/非表示" onclick="change_answer_state('my_strcmp')"></form>
        <section id="my_strcmp" style="display: none;">
            <h4>回答</h4>
            <pre class="brush: cpp;" title="strcmp.cpp">#include "strcmp.h"
#include &lt;limits>
#include &lt;cstddef>
#include &lt;cerrno>
int my_strcmp(const char *string1, const char *string2){
    if (nullptr == string1 || nullptr == string2){
        errno = EINVAL;
        return -2;
    }
    const auto search_limits = std::numeric_limits&lt;size_t>::max();//無限ループ防止
    size_t i;
    for (i = 0; i &lt; search_limits &amp;&amp; '\0' != string1[i] &amp;&amp; '\0' != string2[i] &amp;&amp; string1[i] == string2[i]; i++);
    if (search_limits == i){
        errno = EINVAL;
        return -2;
    }
    //MSVC, gcc, clangの実装では1,0,-1のいずれかを返す
    return (string1[i] == string2[i]) ? 0 : (string1[i] > string2[i]) ? 1 : -1;//引き算にするとアンダーフローの危険がある
}
</pre>
        </section>
    </section>
    <section>
        <h2>strstr</h2>
        <p>文字列を検索する関数です。見つかるとその先頭のポインターを返し、見つからない場合はNULLポインターを返します。</p>
        <pre class="brush: cpp;" title="使用例">#include &lt;stdio.h>
#include &lt;string.h>
int main(void){
    char str[] = "arikitari_na_world!";
    printf("Before: %s\n", str);
    memcpy(strstr(str, "arikitari"), "arifureta___", 12);
    printf("After : %s\n", str);
    return 0;
}</pre>
        <section>
            <h3>ヘッダー</h3>
            <pre class="brush: cpp;" title="strcmp.h">#if (defined(_MSC_VER) &amp;&amp; _MSC_VER > 1000) || (defined(__clang__) &amp;&amp; (__clang_major__ > 3 || (__clang_major__ == 3 &amp;&amp; __clang_minor__ > 2))) ||(defined(__ICC) &amp;&amp; __ICC > 1000) ||defined (__GNUC__) &amp;&amp; !defined(__ICC) &amp;&amp; !defined(__clang__) &amp;&amp; (__GNUC__ >= 4 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ >= 4))
#pragma once
#endif
#ifndef _INC_MY_STRSTR_H
#define _INC_MY_STRSTR_H
#include &lt;cstddef>//To use _CONST_RETURN
#ifndef _CONST_RETURN//for msys2 mingw64 clang 3.5.1.
#ifdef __cplusplus
#define _CONST_RETURN  const
#define _CRT_CONST_CORRECT_OVERLOADS
#else  /* __cplusplus */
#define _CONST_RETURN
#endif  /* __cplusplus */
#endif  /* _CONST_RETURN */
#ifdef __cplusplus
char *my_strstr(char *str, const char *strSearch);
#endif
_CONST_RETURN char *my_strstr(const char *str, const char *strSearch);
#endif</pre>
        </section>
        <section class="scroll_box">
            <h3>使用例</h3>
            <pre class="brush: cpp;" title="main.cpp">#include &lt;iostream>
#include &lt;cstring>
#include "strstr.h"
using strstr_t = _CONST_RETURN char*(*)(const char*, const char*);
void strstr_and_do(const char* str, const char* search_key, strstr_t strsearch, const char* message){
    std::cout &lt;&lt; message &lt;&lt; "を呼び出します" &lt;&lt; std::endl;
    auto re = strsearch(str, search_key);
    if (nullptr == re){
        std::cout &lt;&lt; "見つからなかったんだぜ" &lt;&lt; std::endl;
    }
    else{
        std::cout &lt;&lt; (re - str) + 1 &lt;&lt; "番目で見つかったよ (" &lt;&lt; re[0] &lt;&lt; ")" &lt;&lt; std::endl;
    }
}
int main(void){
    auto str = "arikitari_na_world";
    auto search_key = "world";

    std::cout &lt;&lt; "base_str : " &lt;&lt; str &lt;&lt; std::endl;
    std::cout &lt;&lt; "search_key : " &lt;&lt; search_key &lt;&lt; std::endl;

    strstr_and_do(str, search_key, strstr, "string.hのstrstr関数");
    strstr_and_do(str, search_key, my_strstr, "strstr.hのmy_strstr関数");
    return 0;
}</pre>
        </section>
        <p>さて、この関数を作ってみましょう。forの2重ループを組むのが一番早いと思います。</p>
        <blockquote cite="http://www.cplusplus.com/reference/cstring/strstr/">
            <a href="http://www.cplusplus.com/reference/cstring/strstr/">strstr - C++ Reference</a><br>
            A pointer to the first occurrence in str1 of the entire sequence of characters specified in str2, or a null pointer if the sequence is not present in str1.
        </blockquote>
        <blockquote cite="https://msdn.microsoft.com/ja-jp/library/z9da80kz.aspx">
            <a href="https://msdn.microsoft.com/ja-jp/library/z9da80kz.aspx">strstr、wcsstr、_mbsstr、_mbsstr_l | MSDN</a><br>
             Returns a pointer to the first occurrence of strSearch in str, or NULL if strSearch does not appear in str. If strSearch points to a string of zero length, the function returns str.
        </blockquote>
        <p>第2引数が空の文字列(=0番目の要素が'\0')のときは第1引数をそのまま帰す必要がある点に注意してください。また使用例の4-11行目、_CONST_RETURNについての部分も書かないとダメです。</p>
        <pre class="brush: plain" title="望ましい実行例1">$ ./strstr.exe
base_str : arikitari_na_world
search_key : world
string.hのstrstr関数を呼び出します
14番目で見つかったよ (w)
strstr.hのmy_strstr関数を呼び出します
14番目で見つかったよ (w)</pre>
        <form><input type="button" value="答えを 表示/非表示" onclick="change_answer_state('my_strstr')"></form>
        <section id="my_strstr" style="display: none;">
            <h4>回答</h4>
            <pre class="brush: cpp; highlight:[18, 23, 27];" title="strstr.cpp">#include "strstr.h"
#include &lt;limits>
#ifndef _CONST_RETURN//for msys2 mingw64 clang 3.5.1.
#ifdef __cplusplus
#define _CONST_RETURN  const
#define _CRT_CONST_CORRECT_OVERLOADS
#else  /* __cplusplus */
#define _CONST_RETURN
#endif  /* __cplusplus */
#endif  /* _CONST_RETURN */
_CONST_RETURN char *my_strstr(const char *str, const char *strSearch){
    if (nullptr == str || nullptr == strSearch) return nullptr;
    if ('\0' == strSearch[0]) return str;
    size_t i, j, k;
    const auto search_lim = std::numeric_limits&lt;size_t>::max();//無限ループ防止
    for (
        str_is_not_terminate = true, i = 0, j= 0, k = 0;
        search_lim != i &amp;&amp; '\0' != str[k] &amp;&amp; '\0' != str[i] &amp;&amp; '\0' != strSearch[j];//正規のbreak条件は'\0' == strSearch[j]
        ++i
    ){
        for (
            j = 0, k = i;
            search_lim - 1 != k &amp;&amp; search_lim != j &amp;&amp; '\0' != str[k] &amp;&amp; '\0' != strSearch[j] &amp;&amp; str[k] == strSearch[j];
            ++j, ++k
        );
    }
    return ('\0' != strSearch[j]) ? nullptr : &amp;str[i - j - 1];//この時必ずi > jとなる。さもなくばreturnはnullptr
}</pre>
            <p>
                18, 23, 27行目に注目しながら読んでください。strの1文字目とstrSearchの1文字目が一致するかを調べ、しなければstrの2文字目とstrSearchの1文字目と言った具合に線形探索していきます。<br>
                見つかるより先にstrが'\0'と24行目で判定されたら、18行目のループも抜けることになります。<br>
                見つかった場合23行目の段階で条件式「'\0' != strSearch[j]」はfalseになるので「&amp;str[i - j - 1]」を返します。-1はさっき言ったようにi++されるからです。
            </p>
            <p>12, 13行目についてですが、これを逆にしてはいけません。nullポインターの実体って、あなた、それどこですか？</p>
            <p>俗に力任せ法とか言われる方法ですが、別途配列を持たなければならないBM法やKMP法よりはL1キャッシュを活用しやすいはずなので、ポインタ減算が発生することを差し引いてもstrSearchが十分に短い文字列の場合、十分な早さで検索できます。BM法はひたすらポインタ減算するので論外ですし、KMP法はstrSearch内が同じ文字列の繰り返しのような特殊な場合以外では先にindexを構築する分速度面で不利になります。</p>
        </section>
    </section>
    <section>
        <h2>sprintf</h2>
        <p>
            Cで文字列操作するならとりあえずsprintf使え、と最初に言いましたがその通りです。<br>
            使い方はいたってシンプル。というかprintfと全く同じです。<br>
            printfでもsprintfでも第一引数に確保されている領域へのポインタ(配列、動的配列)を渡せば結果がそこに書き込まれます。
        </p>
        <section>
            <h3>サンプル: 数字の桁数を求める</h3>
            <script src="http://ideone.com/e.js/idduCj" type="text/javascript" ></script>
        </section>
        <p>
            というわけで、下に掲げる関数を短くしてください。<br>
            元ネタは<br>
            <a href="http://www.pro.or.jp/~fuji/mybooks/cdiag/cdiag.9.3.html">Ｃプログラミング診断室／珠玉の力作／文字列処理</a>です<br>
            短くした後の関数のプロトタイプは
        </p>
        <pre class="brush: cpp;">void SetUp_OutputFileName_fix(char* poutputfile_path_name, const char* pjob_name, PFILE_INFORMATION pfile_information);</pre>
        <p>とします。</p>
        <section class="scroll_box">
            <h3>問題のコード</h3>
            <pre class="brush: plain;">void SetUp_OutputFileName(unsigned char* poutputfile_path_name, unsigned char* pjob_name, PFILE_INFORMATION pfile_information){
/*1991.10.21  変更前開始*/
/*
if (pfile_information->type == FILE_TYPE_BLOCK_COPY)
    {
    strcpy((char *)poutputfile_path_name, PATH_OUTPUT_HOME);
    strcat((char *)poutputfile_path_name, "/");
    strcat((char *)poutputfile_path_name, (char *)pjob_name);
    strcat((char *)poutputfile_path_name, PATH_BLOCK_COPY_FILE);
    sprintf((char *)poutputfile_path_name + strlen(PATH_OUTPUT_HOME) + 1 + strlen((char *)pjob_name) + strlen(PATH_BLOCK_COPY_FILE) + 0,
            "%1X",
            pfile_information->information.block_copy.black_flag);
    sprintf((char *)poutputfile_path_name + strlen(PATH_OUTPUT_HOME) + 1 + strlen((char *)pjob_name) + strlen(PATH_BLOCK_COPY_FILE) + 1,
            "%1X",
            pfile_information->information.block_copy.plane_code);
    sprintf((char *)poutputfile_path_name + strlen(PATH_OUTPUT_HOME) + 1 + strlen((char *)pjob_name) + strlen(PATH_BLOCK_COPY_FILE) + 2,
            "%1X",
            pfile_information->information.block_copy.color_code);
    sprintf((char *)poutputfile_path_name + strlen(PATH_OUTPUT_HOME) + 1 + strlen((char *)pjob_name) + strlen(PATH_BLOCK_COPY_FILE) + 3,
            "%1X",
            pfile_information->information.block_copy.image_flag);
    sprintf((char *)poutputfile_path_name + strlen(PATH_OUTPUT_HOME) + 1 + strlen((char *)pjob_name) + strlen(PATH_BLOCK_COPY_FILE) + 4,
            "%1X",
            pfile_information->information.block_copy.border_flag);
    sprintf((char *)poutputfile_path_name + strlen(PATH_OUTPUT_HOME) + 1 + strlen((char *)pjob_name) + strlen(PATH_BLOCK_COPY_FILE) + 5,
            "%1X",
            pfile_information->information.block_copy.special_flag);
    strcat((char *)poutputfile_path_name, ".");
    strcat((char *)poutputfile_path_name, (char *)pfile_information->information.block_copy.ppage_no);
    }
else if (pfile_information->type == FILE_TYPE_MASK)
    {
    strcpy((char *)poutputfile_path_name, PATH_OUTPUT_HOME);
    strcat((char *)poutputfile_path_name, "/");
    strcat((char *)poutputfile_path_name, (char *)pjob_name);
    strcat((char *)poutputfile_path_name, PATH_MASK_FILE);
    strcat((char *)poutputfile_path_name, ".");
    strcat((char *)poutputfile_path_name, (char *)pfile_information->information.mask.ppage_no);
    }*/
/*1991.10.21  変更前終了*/
/*1991.10.21  変更後開始*/
    if (pfile_information->type == FILE_TYPE_BLOCK_COPY) {
        strcpy((char *)poutputfile_path_name, PATH_OUTPUT_HOME);
        strcat((char *)poutputfile_path_name, "/");
        strcat((char *)poutputfile_path_name, (char *)pjob_name);
        strcat((char *)poutputfile_path_name, "/");
        strcat((char *)poutputfile_path_name, "R");
        strcat((char *)poutputfile_path_name, (char *)pfile_information->information.block_copy.ppage_no);
        strcat((char *)poutputfile_path_name, ".HAN");
    } else if (pfile_information->type == FILE_TYPE_MASK) {
        strcpy((char *)poutputfile_path_name, PATH_OUTPUT_HOME);
        strcat((char *)poutputfile_path_name, "/");
        strcat((char *)poutputfile_path_name, (char *)pjob_name);
        strcat((char *)poutputfile_path_name, "/");
        strcat((char *)poutputfile_path_name, "R");
        strcat((char *)poutputfile_path_name, (char *)pfile_information->information.mask.ppage_no);
        strcat((char *)poutputfile_path_name, ".MAS");
    }
/*1991.10.21  変更後終了*/

return;
}</pre>
        </section>
        <form><input type="button" value="答えを 表示/非表示" onclick="change_answer_state('sprintf')"></form>
        <section id="sprintf" style="display: none;">
            <h4>回答</h4>
            <pre class="brush: cpp;">void SetUp_OutputFileName_fix(const char* poutputfile_path_name, char* pjob_name, PFILE_INFORMATION pfile_information){
    switch(pfile_information->type){
    case FILE_TYPE_BLOCK_COPY:
        sprintf(poutputfile_path_name, "%s/%s/R%s.HAN", PATH_OUTPUT_HOME, pjob_name, pfile_information->information.block_copy.ppage_no);
        break;
    case FILE_TYPE_MASK:
        sprintf(poutputfile_path_name, "%s/%s/R%s.MAS", PATH_OUTPUT_HOME, pjob_name, pfile_information->information.mask.ppage_no);
        break;
    default:
        break;
    }
}</pre>
            <p>
                もうね、圧倒的圧縮率。問題文のsyntaxhighlightを止めていたのはコメントの多さがばれないようにするためでした。<br>
                とりあえず過去のコードをコメントアウトするな、gitで管理しろ、strcat関数は使うなと言いたい。<br>
                ちなみにC++のstd::stringつかうとこんな感じ。
            </p>
            <pre class="brush: cpp;">std::string SetUp_OutputFileName_fix(const char* pjob_name, PFILE_INFORMATION pfile_information) {
    auto&amp; inf = pfile_information->information;
    switch (pfile_information->type) {
    case FILE_TYPE_BLOCK_COPY:
        return std::string(PATH_OUTPUT_HOME) + '/' + pjob_name +"/R" + inf.block_copy.ppage_no + ".HAN";
    case FILE_TYPE_MASK:
        return std::string(PATH_OUTPUT_HOME) + '/' + pjob_name + "/R" + inf.mask.ppage_no + ".MAS";
    default:
        return "";
        break;
    }
}</pre>
        </section>
    </section>
    <section>
        <h2>insert</h2>
        <p>C++のstd::stringにはinsertメンバー関数があります。</p>
        <pre class="brush: cpp;">std::string str = "arikitari_na_world!";
str.insert(10, "dehanai");</pre>
        <p>
            とっても簡単でわかりやすい。<br>
            しかしC言語標準ライブラリにはinseetはないんです。というのも、文字列を編集するには配列か、動的確保された領域に文字列が入っている必要があります。<br>
            しかも配列の場合はinsertしても配列に格納しきれることが必要なので、かなり面倒です。<br>
            まあつくってみましょう。<br>
            しかし場合分けが必要になります。
        </p>
        <dl>
            <dt>文字列リテラルなどconst char*型の場合</dt>
            <dd>
                この場合は新たに動的確保した領域に文字列をコピーして返すしかありません。<br>
                下のc_str_insert_const関数が該当します。
            </dd>
            <dt>配列に入っている場合</dt>
            <dd>
                この場合、挿入しても配列に収まりきる場合のみ挿入できます。そうでない場合はnullptrを返すしか無いです。<br>
                なぜなら、c_str_insert_const関数を内部で呼ぶと呼び出し側でfreeが必要か否か判断が付きませんからね。<br>
                下のc_str_insert_c_array関数が該当します。
            </dd>
            <dt>動的確保された領域に文字列が入っている場合</dt>
            <dd>
                この場合はreallocすればいいですね。<br>
                下のc_str_insert_no_const関数が該当します。
            </dd>
        </dl>
        <section>
            <h3>ヘッダー</h3>
            <pre class="brush: cpp; highlight:[6, 7, 8];" title="c_str_insert.h">#pragma once
#ifndef _INC_C_STR_INSERT_H
#define _INC_C_STR_INSERT_H
#include &lt;stddef.h>

char* c_str_insert_no_const(char* base_str, size_t insert_index, const char* insert_str);//reallocate
char* c_str_insert_const(const char* base_str, size_t insert_index, const char* insert_str);//unchangeable string
char* c_str_insert_c_array(char* base_str, size_t array_num, size_t insert_index, const char* insert_str);//c_array
#ifdef __cplusplus
#ifndef cstr_insert
#define cstr_insert( base_str, insert_index, insert_str) c_str_insert_c&lt;decltype(base_str)>()(base_str, insert_index, insert_str)
#endif //cstr_insert
template&lt;size_t SIZE> char* c_str_insert_c_array(char(&amp;str_arr)[SIZE], size_t insert_index, const char* insert_str) {//c_array
    return c_str_insert_c_array(str_arr, SIZE, insert_index, insert_str);
}
template&lt;typename T_> struct c_str_insert_c{//reallocate
    char* operator()(T_ base_str, size_t insert_index, const char* insert_str) {
        return c_str_insert_no_const(base_str, insert_index, insert_str);
    }
};
template&lt;> struct c_str_insert_c &lt;const char*>{//unchangeable string
    char* operator()(const char* base_str, size_t insert_index, const char* insert_str) {
        return c_str_insert_const(base_str, insert_index, insert_str);
    }
};
template&lt;size_t SIZE> struct c_str_insert_c &lt;char[SIZE]> {//c_array
    char* operator()(char (&amp;base_str)[SIZE], size_t insert_index, const char* insert_str) {
        return c_str_insert_c_array(base_str, SIZE, insert_index, insert_str);
    }
};
#endif //__cplusplus
#endif //_INC_C_STR_INSERT_H </pre>
            <p>
                16～30行目はいわゆる関数オブジェクトとかfunction-like objectというやつです。templateの特殊化によって6～8行目の関数を呼び分けます。<br>
                マクロ関数cstr_insertはなんとかマクロ使わずにできないのかな・・・
            </p>
        </section>
        <section class="scroll_box">
            <h3>使用例</h3>
            <pre class="brush: cpp;" title="main.cpp">#include "c_str_insert.h"
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#if !defined (_countof)
#if !defined (__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else  /* !defined (__cplusplus) */
extern "C++"
{
    template&lt;typename TYPE,  std::size_t SIZE>
    std::size_t array_length(const TYPE(&amp;)[SIZE]){
        return SIZE;
    }
#define _countof(_Array) array_length(_Array)
}
#endif  /* !defined (__cplusplus) */
#endif  /* !defined (_countof) */
#ifndef print_c_str_when_it_is_not_null
#define print_c_str_when_it_is_not_null( str ) print_c_str_when_it_is_not_null_helper(#str, str)
#endif
void print_c_str_when_it_is_not_null_helper(const char* variable_name, const char* str) {
    printf("%s : ", variable_name);
    if (nullptr != str) puts(str); else putchar('\n');
}
char* make_str_heap(const char* str) {
    char* re = static_cast&lt;char*>(calloc(strlen(str) + 1, sizeof(char)));
#ifdef _MSC_VER
    sprintf_s(re, strlen(str) + 1, "%s", str);
#else
    sprintf(re, "%s", str1);
#endif
    return re;
}
int main() {
    const char* str1 = "arikitari_na_world!";
    char str2[] = "arikitari_na_world!";
    char str1_3[28] = "arikitari_na_world!";
    char str2_3[28] = "arikitari_na_world!";
    char str3_3[28] = "arikitari_na_world!";
    char* str1_4 = make_str_heap(str1);
    char* str2_4 = make_str_heap(str1);
    const char* insert_str = "dehanai";

    char* re1 = cstr_insert(str1, 10, insert_str);
    char* re2 = cstr_insert(str2, 10, insert_str);
    char* re3 = cstr_insert(str1_3, 10, insert_str);
    char* re4 = cstr_insert(str1_4, 10, insert_str);
    print_c_str_when_it_is_not_null(re1);
    print_c_str_when_it_is_not_null(re2);
    print_c_str_when_it_is_not_null(re3);
    print_c_str_when_it_is_not_null(re4);
    free(re1);
    free(re4);//nullptrが渡された時は何も起きないと保証されている

    char* re2_1 = c_str_insert_const(str1, 10, insert_str);
    char* re2_2 = c_str_insert_c_array(str2, 10, insert_str);
    char* re2_3 = c_str_insert_c_array(str2_3, 10, insert_str);
    char* re2_4 = c_str_insert_no_const(str2_4, 10, insert_str);
    print_c_str_when_it_is_not_null(re2_1);
    print_c_str_when_it_is_not_null(re2_2);
    print_c_str_when_it_is_not_null(re2_3);
    print_c_str_when_it_is_not_null(re2_4);
    free(re2_1);
    free(re2_4);//nullptrが渡された時は何も起きないと保証されている

    char* re3_2 = c_str_insert_c_array(str2, _countof(str2),10, insert_str);
    char* re3_3 = c_str_insert_c_array(str3_3, _countof(str3_3), 10, insert_str);
    print_c_str_when_it_is_not_null(re3_2);
    print_c_str_when_it_is_not_null(re3_3);

    return 0;
}</pre>
        </section>
        <p>
            まあヘッダーの6-8行目にある関数を作って欲しいわけです。なおstrcpy, strncpy, strcpy_s関数は使用禁止とします。<br>
            また、配列版は要素数チェックを必ずしましょう<br>
            ちゃんとできていれば上の使用例を実行すると以下のようになるはずです。
        </p>
        <pre class="brush: plain;" title="望ましい実行例">re1 : arikitari_dehanaina_world!
re2 :
re3 : arikitari_dehanaina_world!
re4 : arikitari_dehanaina_world!
re2_1 : arikitari_dehanaina_world!
re2_2 :
re2_3 : arikitari_dehanaina_world!
re2_4 : arikitari_dehanaina_world!
re3_2 :
re3_3 : arikitari_dehanaina_world!</pre>
        <form><input type="button" value="答えを 表示/非表示" onclick="change_answer_state('c_str_insert')"></form>
        <section id="c_str_insert" style="display: none;">
            <h4>回答</h4>
            <p>
                文字列編集と言ったら真っ先にsprintf関数を思い出さなければなりません。memcpyとかstrcatとか使う前にまずこれを思い出しましょう。<br>
                ただ、reallocate版と配列版は引数を変更できるので、sprintfよりmemmoveとmemcpyを使うほうが楽です。<br>
                今回reallocate版と配列版は最初の処理以外同じなのでc_str_insert_helper_という関数に処理をまとめています。<br>
                c_str_insert_helper_is_insertable_関数は配列の要素数チェックをします。書き込むだけの領域が確保されているか、必ず確認しましょう。<br>
                なお、Visual Studioではsprintf関数はsprintf_s使えと怒られますが、今回は必要分メモリー確保してあるので要素数チェックをするsprintf_sではなくsprintfを使いたいので、warning (disable: 4996)しています。
            </p>
            <pre class="brush: cpp;">#include "c_str_insert.h"
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#if !defined(__cplusplus) &amp;&amp; !defined(nullptr)
#define nullptr NULL
#endif
char* c_str_insert_helper_(char* str_arr, size_t insert_index, const char* insert_str) {
    memmove(str_arr + insert_index + strlen(insert_str), str_arr + insert_index, strlen(str_arr + insert_index) + 1);
    memcpy(str_arr + insert_index, insert_str, strlen(insert_str));
    return str_arr;
}
bool c_str_insert_helper_is_insertable_(const char* str_arr, const char* insert_str, size_t size) {
    return strlen(str_arr) + strlen(insert_str) + 1 &lt;= size;
}
#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4996) //error C4996: 'sprintf': This function or variable may be unsafe. Consider using sprintf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.
#endif
char* c_str_insert_const(const char* base_str, size_t insert_index, const char* insert_str) {//文字列リテラル
    char* new_str = (char*)(calloc(strlen(base_str) + strlen(insert_str) + 2, sizeof(char)));
    if (nullptr != new_str) sprintf(new_str, "%.*s%s%s", insert_index, base_str, insert_str, &amp;base_str[insert_index]);
    return new_str;
}
#ifdef _MSC_VER
#pragma warning (pop)
#endif
char* c_str_insert_c_array(char* base_str, size_t array_num, size_t insert_index, const char* insert_str) {//配列
    return (nullptr != base_str &amp;&amp; c_str_insert_helper_is_insertable_(base_str, insert_str, array_num)) ? c_str_insert_helper_(base_str, insert_index, insert_str) : nullptr;
}
char* c_str_insert_no_const(char* base_str, size_t insert_index, const char* insert_str) {//realocate
    char* new_str = (char*)(realloc(base_str, (strlen(base_str) + strlen(insert_str) + 2) * sizeof(char)));
    return (nullptr == new_str) ? nullptr : c_str_insert_helper_(new_str, insert_index, insert_str);
}
</pre>
        </section>
    </section>
    <nav class="bottom">
        <ul>
            <li><a href="./18c_char_str_base.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./" title="次頁">next</a></li>
        </ul>
    </nav>
</body>
</html>