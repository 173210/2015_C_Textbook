<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>第17章 ～乱数～</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/sanitize.css/2.0.0/sanitize.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <script src="./syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushPlain.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushCpp_kai.js" type="text/javascript"></script>
    <link href="./syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css">
    <link href="./syntaxhighlighter/styles/shThemeMidnight_likeVS.css" rel="stylesheet" type="text/css">
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <h1>第17章 ～乱数～</h1>
    <nav class="top">
        <ul>
            <li><a href="./16Range-base_for.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./18c_char_str_base.html" title="次頁">next</a></li>
        </ul>
    </nav>
    <section>
        <h2>C言語で乱数生成を頑張る人の奮闘</h2>
        <p>
            プログラミングにおいて、乱数の生成はゲームや暗号化などの場面で非常に多用されます。<br>
            しかし、C言語ではまともな乱数を作り出すのは困難です。素直にSFMTみたいな外部ライブラリや(DxLibraryも内部ではこれを使っています)、C++の乱数生成を使うべきです。<br>
            しかし、SFMTは変数名や型名の競合があり、かと言ってC++の乱数生成はやや煩雑な手順を必要とし、C標準ライブラリ―の乱数生成法のような手軽さはC++17を待つ必要があります。<br>
            というわけで乱数生成をやっていきましょう。
        </p>
</section>
    <section>
        <h3>コンピューター乱数概論</h3>
        <p>一口に「乱数」といっても2種類が有ります。</p>
        <dl>
            <dt>真の乱数</dt>
            <dd>
                予測が困難な乱雑性のある数字。一般に生成には時間がかかったり、別途ハードウェアが必要になったりします。<br>
                ex.)時刻、CPUの温度、GPUの温度、マウスポインタの座標、プロセスID、main関数の引数のアドレス、起動中のプロセス数、環境光の照度、CPU周辺のノイズ量、ユーザーが入力する任意の数、ラジウムの崩壊数
            </dd>
            <dt>擬似乱数</dt>
            <dd>
                ある種のアルゴリズム(計算式)にseed値を与えることにより、高速に数字をつくりだす。<br>
                一般に擬似乱数の評価基準は、生成速度、生成の分布の一様性、周期、全数探索可能性などになります。
            </dd>
        </dl>
        <p>どんな方法を使うにせよ、必ず真の乱数をseed値として擬似乱数生成アルゴリズムを使い擬似乱数を作ることになります。よって以下、seed値を作るということと、擬似乱数を生成することを明確に区別して読み進めてください</p>
    </section>
    <section>
        <h3>ありきたりなC言語的乱数生成</h3>
        <p>まずは大抵の参考書に乗っているごくごくありきたりなソースコードを載せます。さして精度を求めなかったり、同じ数が連続して出ても良い場合はこれで十分だったりします。</p>
        <pre class="brush: cpp;">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
int main(void){
	unsigned int i,j;
	/* 乱数系列の変更 */
	srand(static_cast&lt;unsigned int&gt;(time(nullptr)));
	/* 1～100の擬似乱数を10個ずつ10行発生 */
	for (i = 1; i <= 10; i++) {
		for (j = 0; j < 10; j++) {
			printf("%3d ", rand() % 100 + 1);
		}
		putchar('\n');
	}
	return 0;
}</pre>
        <p>seed値は現在時刻を求めるtime関数を利用し、擬似乱数生成にはC標準ライブラリ―のrand関数を利用しています。rand関数にseedを渡すにはsrand関数を使用します。</p>
        <p>上記の例では、乱数を任意の範囲に加工するのに余りを求める計算を利用していますが、これは余り賢いやり方ではありません。なのでこんな風にすれば使いやすい・・・のかな？</p>
        <pre class="brush: cpp;">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
unsigned int gen_uirand(unsigned int max, unsigned int min){
	return min + (rand() * (max-min+1.0) / (1.0 + RAND_MAX));
}
int main(void){
	unsigned int i,j;
	/* 乱数系列の変更 */
	srand(static_cast&lt;unsigned int&gt;(time(nullptr)));
	/* 1～100の擬似乱数を10個ずつ10行発生 */
	for (i = 1; i <= 10; i++) {
		for (j = 0; j < 10; j++) {
			printf("%3d ", gen_uirand(100, 1));
		}
		putchar('\n');
	}
	return 0;
}</pre>
    </section>
    <section>
        <h3>擬似乱数の生成を改善する</h3>
        <p>
            ところでC標準ライブラリーのrand関数はとても便利なのですが、あまりまともな擬似乱数を作ってくれません。<br>
            擬似乱数はちょうど大きなリング上の数字が順に吐き出されるように周期が有りますが、この周期もあまり良くありません。<br>
            さらにMSVCみたいにいまだにRAND_MAX(生成される乱数の最大値)が15bit変数と同じ、なんていう処理系も有ります。<br>
            そこでもう少し頭のいい方法を使ってみましょう。<br>
            ３月１４日（水）　疑似乱数の話 | Diary 2012-3 | まるも<br>
            <a href="http://www.marumo.ne.jp/db2012_3.htm#14">http://www.marumo.ne.jp/db2012_3.htm#14</a><br>
            よりパク・・・げふんげふん、引用します。
        </p>
        <pre class="brush: cpp;">unsigned int libc_rand_32_normal()
{
	unsigned int r = 0;
	r  = ((rand() >> 3) &amp; 0x0fff)      ; // 12 bit
	r |= ((rand() >> 4) &amp; 0x07ff) &lt;&lt; 12; // 12+11 : 23 bit
	r |= ((rand() >> 6) &amp; 0x01ff) &lt;&lt; 23; // 12+11+9 : 32 bit
	return r;
}</pre>
        <p>参考サイトの記述によれば周期は 0x80000000 (2,147,483,648)なのだそうです(どうやっても参考サイトのコードが動かないorz)。</p>
        <p>まあこれの場合seedを変えても開始点が変わるだけで同じ所をグルグル回るというおまけ付きなんですが。</p>
    </section>
    <section>
        <h3>seed値の生成を改善する(OS非依存)</h3>
        <p>先の関数ではseed値に、time関数の戻り値を利用しましたが、こいつ1秒に1回しか変わりません。また、時刻はある程度予測可能なため真の乱数とは言いがたいです。</p>
        <p>まずはOS非依存な範囲で何とかしてみましょう。こんな感じ・・・？</p>
        <pre class="brush: cpp;">unsigned int create_seed(int argc, char* argv[], uint32_t num){
	char* dst = (char*)malloc(sizeof(char) * 2);
	unsigned int seed = ((uint64_t)argv + (uint64_t)&amp;argc + (uint32_t)time(NULL) + clock() + libc_rand_32_normal() + ((uint32_t)dst * (uint32_t)((rand() &amp; 0xff) &lt;&lt; 16) * (uint32_t)&amp;dst)) % UINT_MAX;
	free(dst);
	return seed;
}</pre>
        <p>
            main関数の引数のアドレスは最近のOSなら大体ランダムになるようなので十分使えます。また、ヒープ領域にメモリーを確保するmalloc関数もそのアドレスはある程度ランダムに選ばれると言っていいでしょう。<br>
            擬似乱数生成器自身もseed値を予測しにくくするのに役立つでしょう。初回呼び出し前になんでもいいのでsrandしないといけなくなりますが。<br>
            PC起動時からの経過tick数を返すclock関数はほぼ必ず呼び出しごとに値が変わると言えるのでseedには持ってこいです。
        </p>
    </section>
    <section>
        <h3>seed値の生成を改善する(WindowsとLinux)</h3>
        <p>
            実行ファイルを実行するとたいていはOSが管理するためにそれぞれにプロセスID(pid)が割り当てられます。こいつもseedに使えそうです。<br>
            Windowsではwin32apiのGetCurrentProcessId関数を使用します。Linuxでは・・・きっとあるでしょう。
        </p>
        <p>
            また、マウスポインタの位置は完全に予測不能ですのでseedにもってこいです。<br>
            WindowsではGetCursorPos関数を使用します。Linuxは、そもそもGUIの作り方がわからん。まあQtとかXWindowとか大抵のGUIフレームワークでそれっぽい関数があるでしょう。<br>
            <a href="http://doc.qt.io/qt-5/qcontextmenuevent.html#globalPos">http://doc.qt.io/qt-5/qcontextmenuevent.html#globalPos</a><br>
            Qtではこれ使うっぽい。さっぱり使い方がわからんけど。
        </p>
        <p>とまぁ、こういう感じになる・・・のかな？</p>
        <pre class="brush: cpp;">unsigned int create_seed(int argc, char* argv[], uint32_t num){
	POINT point;
	GetCursorPos(&amp;point);
	char* dst = (char*)malloc(sizeof(char) * 2);
	unsigned int seed = ((uint64_t)argv + (uint64_t)&amp;argc + (num * (uint64_t)(point.x + point.y)) + (uint64_t)GetCurrentProcessId() 
        + (uint32_t)time(NULL) + clock() + libc_rand_32_normal() + ((uint32_t)dst * (uint32_t)((rand() &amp; 0xff) &lt;&lt; 16) * (uint32_t)&amp;dst) + 3457450835) % UINT_MAX;
	free(dst);
	return seed;
}</pre>
        <p>せっかくなのでこれを利用してなんか動くものを作る。</p>
        <script src="http://ideone.com/e.js/1wxKrF" type="text/javascript"></script>
    </section>
    <section>
        <h3>そもそも乱数のseed作成にはIntelCPUのRDRAND命令やRDSEED命令が使える</h3>
        <p>
            さきほどseedを作る方法を紹介しましたが、Intel Core i シリーズ第3世代からはRDRAND命令、第5世代からはRDSEED命令という乱数生成命令が追加されました。<br>
            こいつはハードウェア乱数生成器で擬似乱数生成程ではないにしろ、比較的高速にほとんど真の乱数と呼べる数値を作ってくれます。<br>
            なのでこいつをseedに使ってやればいいです。またさほど生成が遅くないので(200tick程度？)これ自体を乱数として採用するのもありです。
        </p>
        <p>
            実際にRDRAND命令を乱数として採用したのがこちらのプロジェクトです。DLして試してみてください。<br>
            Using Intel’s Secure Key (RDRAND) in MS Visual C++ 2013 | GiuHub<br>
            <a href="https://github.com/yumetodo/rdrand_msvc_2010">https://github.com/yumetodo/rdrand_msvc_2010</a><br>
        </p>
        <pre class="brush: plain;">git clone https://github.com/yumetodo/rdrand_msvc_2010.git</pre>
        <p><a href="https://github.com/yumetodo/rdrand_msvc_2010/blob/master/README.md">readme</a>に書いているように、わざわざアセンブリを書かなくても</p>
        <pre class="brush: cpp;">static bool RDRAND(void) { return CPU_Rep.f_1_ECX_[30]; }
extern int __cdecl _rdrand16_step(unsigned short *);
extern int __cdecl _rdrand32_step(unsigned int *);
#if defined (_M_X64)
extern int __cdecl _rdrand64_step(unsigned __int64 *);
#endif  /* defined (_M_X64) */</pre>
        <p>これらの関数群が使えるんですけどね。</p>
    </section>
    <section>
        <h3>そもそもwin32apiに乱数生成関数がある</h3>
        <p>
            MSVCにはrand_sという関数が有り、勝手に適当なseedを与えて擬似乱数を作ってくれる関数があります。<br>
            こいつは内部で「RtlGenRandom API」というWindowsXP以降に対応しているAPIを叩いています。
        </p>
        <pre class="brush: cpp;">errno_t rand_s(unsigned int* randomValue);</pre>
        <p><a href="https://msdn.microsoft.com/ja-jp/library/sxtz2fa8.aspx">rand_s | MSDN</a></p>
        <p>乱数の精度にさほどこだわらない時はこれを使うといいです。少なくともrand関数よりはずっと優秀です。</p>
    </section>
    <section>
        <h2>C++11 or laterで乱数生成</h2>
        <p>いろいろと工夫してCのrand関数を使用してきましたが、やはり限界があります。</p>
        <ul>
            <li>rand() % N は一様では無い</li>
            <li>乱数生成アルゴリズムが固定（通常は線形合同法）</li>
            <li>正規分布など、一様でない乱数生成が面倒</li>
            <li>seedを作る方法がOS依存になったりCPU依存になったりする</li>
        </ul>
        <p>とまあ、C++っぽく作りましょうか。細けーことは後だ。</p>
        <pre class="brush: cpp;">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;random&gt;
class counter_iterator {
    std::size_t i;
public:
    counter_iterator() : i(0) { }
    counter_iterator(std::size_t n) : i(n) { }
    bool operator == (const counter_iterator &amp; rhs) const { return i == rhs.i; }
    bool operator != (const counter_iterator &amp; rhs) const { return i != rhs.i; }
    std::size_t &amp; operator * () { return i; }
    counter_iterator &amp; operator ++ () { ++i; return *this; }
};
class nth_loop {
private:
    std::size_t i;
public:
    nth_loop(std::size_t n) : i(n) { }
    counter_iterator begin() const { return counter_iterator(); }
    counter_iterator end() const { return counter_iterator(i); }
};
nth_loop rep(std::size_t n){ return nth_loop(n); }
nth_loop operator "" _( unsigned long long int n ){
	return nth_loop( n ) ;
}
int main(){
	// ランダムデバイス
	std::random_device rnd ;
	// 初期化用ベクタ
	std::vector< std::uint_least32_t> v(10) ;
	// ベクタの初期化
	std::generate( v.begin(), v.end(), std::ref(rnd) ) ;
	
	// 乱数エンジン
	std::mt19937 engine( std::seed_seq( v.begin(), v.end() ) ) ;
	// distribution
	std::uniform_real_distribution&amp;&lt;double&gt; distribution(0.0, 1.0) ;
	
	for (auto i : 10_)
		std::cout &lt;&lt; distribution(engine) &lt;&lt; std::endl ;
}</pre>
        <p>
            ちゃっかり前回のRange-base forと参考リンクに上げた固定回ループの書き方を使っています。だって「C++っぽく作りましょうか」って言ったでしょ。<br>
            ユーザー定義整数リテラルなんて習ってないだって？あー聞こえない聞こえない。<br>
            ・・・と言うわけにもいかないので簡単に補足。「operator "" _」と「auto i : 10_」に着目してください。あとは「ユーザー定義整数リテラル」でググればいいと思うよ。<br>
            range-base forで固定回ループをする | CodeGarage <br>
            <a href="http://codegarage.edisonthk.com/_p/snippet/252">http://codegarage.edisonthk.com/_p/snippet/252</a>
        </p>
        <p>
            話がそれました。random_device rndってのが真の乱数を作るやつで、作ったのを保管するのが変数v、seedを真の乱数から作るのがgenerateで、<br>
            srandにあたるseedを与えるのが16行目です。<br>
            uniform_real_distributionってのはできた乱数を指定した型で指定した範囲に加工するやつですのでなくてもいいですが・・・あったほうが楽やんね。
        </p>
    </section>
    <nav class="bottom">
        <ul>
            <li><a href="./16Range-base_for.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./18c_char_str_base.html" title="次頁">next</a></li>
        </ul>
    </nav>
</body>
</html>