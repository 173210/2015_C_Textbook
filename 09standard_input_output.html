<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>第9章 ～標準入出力～</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/sanitize.css/2.0.0/sanitize.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <script src="./syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushPlain.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushCpp_kai.js" type="text/javascript"></script>
    <link href="./syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css">
    <link href="./syntaxhighlighter/styles/shThemeMidnight_likeVS.css" rel="stylesheet" type="text/css">
    <script src="./scripts/common.js" type="text/javascript"></script>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <h1>第9章 ～標準入出力～</h1>
    <nav class="top">
        <ul>
            <li><a href="./08preprocess_and_constant.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./10introduction_of_pointer.html" title="次頁">next</a></li>
        </ul>
    </nav>
    <section>
        <h2>標準出力(stdout)</h2>
        <p>
            すでにputs関数やprintf関数を何気なく使っていますが、標準出力について説明していませんでした。<br>
            標準出力とは、プログラムが書き出すデータのストリームのことで、とくに指定しない限りコンソール画面に出力されます。<br>
            と、書けば察しがつくと思いますが、標準出力は変えられます。リダイレクトでググってください。<br>
            それ故、puts, printf関数などは「コンソール画面に文字を表示する関数」としばしば誤解されます。<br>
            なお、stdoutとはSTanDard OUTputの略です。C++は違いますが、他の言語でもこの言葉が使われることがおおいです。
        </p>
        <section>
            <h3>よく使う標準出力関係の関数</h3>
            <pre class="brush: cpp;">int puts(const char *str );
int printf(const char *format [,argument]...);
int fprintf(FILE *stream, const char *format [,argument ]...);
int fputc(int c, FILE *stream);
int putchar(int c );</pre>
        </section>
        <p>C言語の標準出力関数、とくにprintf関数はとても優秀で、正直C++の出力方法よりよほど使いやすいです。ちなみにC++では</p>
        <pre class="brush: cpp;">std::cout &lt;&lt; "arikitari na world!" &lt;&lt; std::endl;</pre>
        <p>のようにします・・・が、はっきり言って使いにくいです。C++はたしかに使いやすいですが、標準出力の使いにくさだけはいただけません。</p>
    </section>
    <section>
        <h2>標準エラー出力(stderr)</h2>
        <p>はっきりいって出番は少ないです。が、標準出力をたとえばファイルにリダイレクトした時、エラーはコンソールに出す、みたいなときには便利ですし、習慣的にエラーは標準エラー出力に出力することになっています。</p>
        <section>
            <h3>よく使う標準出力関係の関数</h3>
            <pre class="brush: cpp;">int fprintf(FILE *stream, const char *format [,argument ]...);</pre>
        </section>
    </section>
    <section>
        <h2>標準入力(stdin)</h2>
        <p>
            C言語の標準入力ははっきり言ってクソです。どれくらいクソかというと、標準ライブラリーにまともに数値を受ける関数がありません。<br>
            数値入力を受けたいだけなのに一度文字列として受け取りそれを数値に変換する処理を自前で書かないといけないなんてアホでしょ。<br>
            また、入力ストリームへの攻撃対策が弱かったり、しばしば改行文字を入力ストリームに置き去りにしたりと、文字すら安全に読み込むのは難しいのです。<br>
            その代表格がgets関数です。文字列を受け取る関数なのですが、あまりの危険性から、C99では非推奨、そしてついにC11では使用禁止になりました。<br>
            この背景には、後述しますがC言語にはそもそも「文字列」という概念がない、ということがあります。文字の実態はただの数字で、文字列はその集合でしかないのです。<br>
            そんなC言語でどうにかこうにか安全に標準入力を扱おう、というのが今回の目標です。
        </p>
        <p>
            まさかの愚痴スタートです、すみませんでした。標準入力とは、プログラムに入ってくるテキストデータのストリームです。<br>
            殆どの場合、キーボードから文字入力を受けます。言語を問わず数値入力を受けるためには一度文字列として読み込み、数値に変換する、という作業を行いますが、他の言語ではその作業を意識することはありません。
            先程から、C言語の標準入力は糞だ、と言っていますが、少なくとも文字列の入力を受けることに関しては改善されてきています。<br>
            MSVCではVisual Studio 2005の頃から、C標準ライブラリーを置き換える関数群を提供しています。scanf_sなどのように末尾に「_s」が付きます。<br>
            またC11でこれに追従する(というよりほぼパクリ・・・)ように同名の関数を提供しています。これはgcc4.9.1くらいからつかえます。<br>
            まあ、実例を見て行きましょうか。
        </p>
        <script src="http://gist-it.appspot.com/github/yumetodo/2015_C_Textbook/blob/gh-pages/src/stdin/stdin/Source.c"></script>
        <p>
            2通り目と3通り目の文字列読み込みでは、文字入力で大概の参考書で真っ先に使うscanf関数を紹介しましたが、個人的にはscanf関数は使いにくいなぁという印象です。<br>
            私はfgetsで改行文字ごと読み込んで改行文字をNULL文字に置き換えるほうが好きです。理屈が単純ということはそれだけバグを減らせるので。<br>
            もちろんscanfにはそれなりの良さがあるわけですが、だとしても3番目のように一度読み込んでからsscanfしますね。
        </p>
        <p>get_integer_num関数については簡単に説明すると、まず、fgets関数で文字列を受け、文字列をstrtol関数で数値に変換しています。</p>
        <p>ちなみにC++だともっとスマートです。</p>
        <pre class="brush: cpp;">#include &lt;iostrem&gt;
#include &lt;string&gt;
int main(){
    using std::cout;
    //文字列読み込み
    cout &lt;&lt; "文字列を入力してください" &lt;&lt; std::endl;
    std::string in_str;
    std::getline(std::cin, in_str);
    cout &lt;&lt; in_str &lt;&lt; std::endl;

    //数値読み込み
    cout &lt;&lt; "数値を入力してくだい" &lt;&lt; std::endl;
    const auto in_num = [](){
        int tmp;
        std::cin >> tmp;
        return tmp;
    }();
    cout &lt;&lt; in_num &lt;&lt; std::endl;
    
    return 0;
}</pre>
        <p>というわけでポインターと文字列について何一つ説明していないのにばんばん使っていますが、すみません。すぐに解説します。</p>
        <article>
            <h3>練習問題1</h3>
            <p>以下のソースコードは標準入力から数値を受け取り、指定範囲内でない数値に対しては再度入力を促すプログラムである。</p>
            <p>しかし、これは意図した動作をしない。問題点を可能な限り多くあげよ(getnum関数はget_integer_num関数のもとになった関数でエラー対策に難がありますが、そこはスルーしてください)</p>
            <pre class="brush: cpp;">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int getnum(void){
	char s[100];
	long t;
	char *endptr;
	fgets(s, 100, stdin);
	errno = 0;
	t = strtol(s, &amp;endptr, 10);
	if (errno != 0 || *endptr != '\n' || (t &lt; INT_MIN || INT_MAX &lt; t))
		return -1;
	return t;
}
int getnum_customized(const int max, const int min){
	if (max &lt; min)	return -1;
	int flag0;
	do{
		flag0 = getnum();
		if (flag0 &lt; min || flag0 > max)
			system("cls");
			printf("再入力してください。\n");
	} while (flag0 &lt; min || flag0 > max + 1);
	return flag0;
}
int main(void){
	printf("値を入力してください。\n");
	const int flag = getnum_customized(100, 0);
	printf("取得した値は%dです。\n", flag);

	return 0;
}</pre>
            <form><input type="button" value="表示/非表示" onclick="change_answer_state('answer1')"></form>
            <section id="answer1" style="display: none;">
                <h4>回答</h4>
                <ol>
                    <li>
                        <div>
                            <p>19-21行目は19行目の時の条件を満たした場合に20,21行目を実行することを意図していると思われるが、この書き方では21行目は条件判定にかかわらず実行される。</p>
                            <pre class="brush: cpp; first-line: 19">		if (flag0 &lt; min || flag0 > max){
			system("cls");
			printf("再入力してください。\n");
        }</pre>
                            <p>が正しい。前に「エラー処理等、明確に実行文が1行しかない、と言える時を除き、原則{}はつけましょう。」と言った理由はこれ。もともと20行目はなく、このコードを書いた人曰く後から追加したらしい。</p>
                        </div>
                    </li>
                    <li>
                        19行目と22行目に注目すると、条件判定がおかしいことに気がつく。つまり、先の修正を踏まえると、flag0がmaxと同値の時、再入力を求める文章が出るのにもかかわらず、実際には再入力することなdo-while文を抜けてしまう。
                    </li>
                    <li>
                        18行目に注目すると、getnum関数の戻り値チェックをしていないことに気がつく。このgetnum関数は11行目にあるようにエラー時は-1を返すので、その判定をする必要がある。つまり
                        <pre class="brush: cpp;">if (-1 == flag0 || flag0 &lt; min || flag0 > max){</pre>
                        とするべきである。
                    </li>
                </ol>
                <p>これらを踏まえ、また無駄な条件判定を減らし、getnum関数を上に上げたget_integer_num関数に置き換えると</p>
                <pre class="brush: cpp;">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;limits.h&gt;//in gcc
#include&lt;errno.h&gt;//in gcc
#ifndef __cplusplus
#define nullptr NULL
#endif
int get_integer_num(const int max, const int min){
    //機能：標準入力を数字に変換する。
    //引数：戻り値の最大値,戻り値の最小値
    //戻り値：入力した数字、エラー時はINT_MIN, EOFのときはEOF
    char s[100];

    if (nullptr == fgets(s, 100, stdin)){
        if (feof(stdin)){//エラーの原因がEOFか切り分け
            return EOF;
        }
        //改行文字が入力を受けた配列にない場合、入力ストリームにごみがある
        size_t i;
        for(i = 0; i &lt; 100 &amp;&amp; '\0' == s[i]; i++);//strlenもどき
        if('\n' != s[i - 1]) while(getchar() != '\n');//入力ストリームを掃除
        return INT_MIN;
    }
    if ('\n' == s[0]) return INT_MIN;
    errno = 0;
    const long t = strtol(s, nullptr, 10);
    if (0 != errno || t &lt; min || max &lt; t)
        return INT_MIN;
    return (int)t;
}
int getnum_customized(const int max, const int min){
	if (max &lt; min)	return -1;
	int buf;
    while(INT_MIN == (buf = get_integer_num(max, min))){
        system("cls");//Windows only. Use 'system("clear")' instead when you run on Linux or Mac.
        puts("再入力してください。");
    }
	return buf;
}
int main(void){
	puts("値を入力してください。");
	const int input_num = getnum_customized(100, 0);
	if(EOF == input_num){
		puts("ファイル終端です");
	}
	else{
		printf("取得した値は%dです。\n", input_num);
	}
	return 0;
}</pre>
            </section>
        </article>
        <article>
            <h3>練習問題2</h3>
            <p>
                ここでは、コンピュータがランダムに考えた数字を、回答とそれに対するヒントにより当てて行くゲームを数当てゲームと呼ぶことにします。<br>
                とりあえず乱数の範囲は5～80とし、10回まで回答できるものとします。<br>
                応答としてはこんなかんじです。
            </p>
            <form><input type="button" value="動作例の表示/非表示" onclick="change_answer_state('example2')"></form>
            <section id="example2" style="display: none;">
                <pre class="brush: plain; highlight:[3, 6, 9, 12, 15, 18, 21, 24, 27, 30]" title="動作例">
最大値80, 最小値5の間で乱数が生成されました。数当てゲームの開始です！
値を入力してください
40
もっと小さいよ
値を入力してください
20
もっと大きいよ
値を入力してください
10
もっと大きいよ
値を入力してください
15
もっと大きいよ
値を入力してください
17
もっと大きいよ
値を入力してください
19
もっと大きいよ
値を入力してください
30
もっと大きいよ
値を入力してください
35
もっと小さいよ
値を入力してください
33
もっと大きいよ
値を入力してください
34
成功！</pre>
            </section>
            <p>
                イメージは湧いたでしょうか？というわけでこれを作ってください・・・といっても穴埋めです。以下のmain関数をいじり、必要なら関数を追加してプログラムを完成させてください。<br>
                input関数の使い方は<br>
                <a href="http://www.biboro.org/snippet/398">http://www.biboro.org/snippet/398</a><br>
                を参照。
            </p>
            <pre class="brush: cpp;">
#if defined(_WIN32) || defined(_WIN64)
#include &lt;windows.h>
#include &lt;mmsystem.h>
#if defined(_MSC_VER) || defined (__clang__)
#pragma comment(lib, "winmm.lib")
#endif
#undef max//std::numeric_limitsとのconflict防止
#endif
#include &lt;iostream>
#include &lt;exception>
#include &lt;limits>
#include &lt;cstdint>
#include &lt;cstdio>
#include &lt;cstdlib>
#include &lt;ctime>
unsigned int libc_rand_32_normal(){
    unsigned int r = 0;
    r  = ((rand() >> 3) &amp; 0x0fff); // 12 bit
    r |= ((rand() >> 4) &amp; 0x07ff) &lt;&lt; 12; // 12+11 : 23 bit
    r |= ((rand() >> 6) &amp; 0x01ff) &lt;&lt; 23; // 12+11+9 : 32 bit
    return r;
}
unsigned int create_seed(int argc, char* argv[], uint32_t num = 0) {
    char* dst = static_cast&lt;char*>(malloc(sizeof(char) * 2));
    srand(static_cast&lt;unsigned int>(time(nullptr) % std::numeric_limits&lt;unsigned int>::max()));
#if defined(_WIN32) || defined(_WIN64)
    timeBeginPeriod(1);
#endif
    unsigned int seed = (
            (reinterpret_cast&lt;uint64_t>(argv) >> 2)
            + (reinterpret_cast&lt;uint64_t>(&amp;argc) >> (clock() % 16))
            ^ (static_cast&lt;uint64_t>(num + libc_rand_32_normal()) | clock() ^ time(nullptr))
            | (reinterpret_cast&lt;uint64_t>(dst) >> (time(nullptr) % 5))
            ^ (static_cast&lt;uint64_t>((rand() &amp; 0xff) &lt;&lt; 16) | (3457450835 >> ((rand() >> 4) % 4)))
            + ((rand() >> 4) &amp; 0x07ff) + (libc_rand_32_normal() &lt;&lt; (clock() % 7))
        ) % std::numeric_limits&lt;unsigned int>::max();
    free(dst);
#if defined(_WIN32) || defined(_WIN64)
    timeEndPeriod(1);
#endif
    return seed;
}
unsigned int distribution(unsigned int max, unsigned int min, unsigned int rand_max, auto (*random)() ->unsigned int) {
    return min + static_cast&lt;unsigned int>(random() * (max - min + 1.0) / (1.0 + rand_max));
}
template&lt;typename T_> using limit = std::numeric_limits&lt;T_>;//create new type. C++11:alias declaration
template&lt;typename T_> T_ input(const char* echo_str, const T_ max = limit&lt;T_>::max(), const T_ min = limit&lt;T_>::lowest()) noexcept {
    static_assert(std::is_arithmetic&lt;T_>::value, "unexpected type T_");//T_が整数か浮動小数点型でないならばコンパイルエラーを出す
    T_ buf;
    try {
        if (nullptr == echo_str) throw std::invalid_argument("echo_str is unexpected input");//エラー対策
        if ('\0' != echo_str[0]) std::cout &lt;&lt; echo_str &lt;&lt; std::endl;//文字列が空じゃなければ出力
        std::cin >> buf;//入力を受ける
        if (max &lt; buf || buf &lt; min) throw std::out_of_range("input is iligal");//範囲チェック
    }
    catch (std::exception&amp; er) {
        std::cerr &lt;&lt; er.what() &lt;&lt; std::endl;//エラーメッセージ表示
        return input("再入力してください。", max, min);//エラー時は再帰する方向で
    }
    return buf;
}
int main(int argc, char* argv[]) {
    constexpr unsigned int range_max = 80;
    constexpr unsigned int range_min = 5;
    constexpr size_t asl_lim = 10;
    srand(create_seed(argc, argv));
    const auto target_num = distribution(range_max, range_min, limit&lt;unsigned int>::max(), libc_rand_32_normal);
    printf("最大値%d, 最小値%dの間で乱数が生成されました。数当てゲームの開始です！\n", range_max, range_min);

    //ここを埋める
    return 0;
}</pre>
            <form><input type="button" value="答えの表示/非表示" onclick="change_answer_state('answer2')"></form>
            <section id="answer2" style="display: none;">
                <p>62行目以降のみ。</p>
                <pre class="brush: cpp; first-line: 62;">
void print_help_of_num(unsigned int target, unsigned int current) {
    std::cout &lt;&lt; ((target > current) ? "もっと大きいよ" : "もっと小さいよ") &lt;&lt; std::endl;;
}
int main(int argc, char* argv[]) {
    constexpr unsigned int range_max = 80;
    constexpr unsigned int range_min = 5;
    constexpr size_t ask_lim = 10;
    srand(create_seed(argc, argv));
    const auto target_num = distribution(range_max, range_min, limit&lt;unsigned int>::max(), libc_rand_32_normal);
    printf("最大値%d, 最小値%dの間で乱数が生成されました。数当てゲームの開始です！\n", range_max, range_min);

    unsigned int input_buf;
    for (size_t i = 0; i &lt; ask_lim &amp;&amp; target_num != (input_buf = input("値を入力してください", range_max, range_min)); i++) {
        print_help_of_num(target_num, input_buf);
    }
    if (target_num != input_buf) {
        printf("%s 正解は%dです\n", "残念でした", target_num);
    }
    else {
        puts("成功！");
    }
    return 0;
}</pre>
            </section>
        </article>
        <article>
            <h3>練習問題3</h3>
            <p>
                定員と重量制限が設けられているエレベータに乗っている人の体重を指定し、定員を超えるか重量制限を超えたら警告するプログラムを作成せよ。<br>
                但し、定員と重量制限は標準入力から入力を受けて決定すること。
            </p>
            <form><input type="button" value="ヒント　表示/非表示" onclick="change_answer_state('hint3')"></form>
            <section id="hint3" style="display: none;">
                <h4>ヒント</h4>
                <ol>
                    <li>ループを書く。毎回体重を入力してもらい、その都度現在乗っている人数を1加算、現在乗っている人の体重を加算します。</li>
                    <li>ループの継続条件は「乗っている人数が定員より少ない　かつ　乗っている人の体重の合計が重量制限より少ない」です。</li>
                    <li>ループが終了したということはもう乗れないということなので、警告を表示しましょう。</li>
                </ol>
            </section>
            <form><input type="button" value="C++11での回答表示/非表示" onclick="change_answer_state('answer3')"></form>
            <section id="answer3" style="display: none;">
                <h4>C++のクラスを用いた回答(C++11)</h4>
                <p>絶対クラス使うほうが楽にかけますし。とまあこんなかんじかな？</p>
                <pre class="brush: cpp;">
#include &lt;iostream>
#include &lt;limits>
#include &lt;exception>
using uint = unsigned int;
class ev_state_c
{
public:
    ev_state_c(uint weight, uint num_of_person) {
        this->weight = weight;
        this->num_of_person = num_of_person;
    }
    bool operator &lt; (const ev_state_c&amp; ref) const{
        return ((this->num_of_person &lt; ref.num_of_person) &amp;&amp; (this->weight &lt; ref.weight));
    }
    const ev_state_c operator - (const ev_state_c&amp; ref) const{
        return ev_state_c(this->weight - ref.weight, this->num_of_person - ref.num_of_person);
    }
    ev_state_c&amp; operator += (const ev_state_c&amp; ref) {
        this->weight += ref.weight;
        this->num_of_person += ref.num_of_person;
        return *this;
    }
    uint get_weight() const { return this->weight; }
private:
    uint num_of_person;
    uint weight;
};
template&lt;typename T_> using limit = std::numeric_limits&lt;T_>;//create new type. C++11:alias declaration
template&lt;typename T_> T_ input(const char* echo_str, const T_ max = limit&lt;T_>::max(), const T_ min = limit&lt;T_>::lowest()) noexcept {
    static_assert(std::is_arithmetic&lt;T_>::value, "unexpected type T_");//T_が整数か浮動小数点型でないならばコンパイルエラーを出す
    T_ buf;
    try {
        if (nullptr == echo_str) throw std::invalid_argument("echo_str is unexpected input");//エラー対策
        if ('\0' != echo_str[0]) std::cout &lt;&lt; echo_str &lt;&lt; std::endl;//文字列が空じゃなければ出力
        std::cin >> buf;//入力を受ける
        if (max &lt; buf || buf &lt; min) throw std::out_of_range("input is iligal");//範囲チェック
    }
    catch (std::exception&amp; er) {
        std::cerr &lt;&lt; er.what() &lt;&lt; std::endl;//エラーメッセージ表示
        return input("再入力してください。", max, min);//エラー時は再帰する方向で
    }
    return buf;
}
ev_state_c make_ev_state_c_from_cin(const ev_state_c&amp; lim) {
    return ev_state_c(input("重量(kg)を入力してください", lim.get_weight()), 1);
}
ev_state_c ask_lim() {
    return ev_state_c(input&lt;uint>("重量制限(kg)を入力してください"), input&lt;uint>("定員を入力してください"));//引数は後ろから評価される
}
int main() {
    ev_state_c buf(0, 0);
    const auto lim = ask_lim();
    for (ev_state_c i(0, 0); i &lt; (lim - (buf = make_ev_state_c_from_cin(lim))); i += buf);
    std::cout &lt;&lt; "もう乗り切れないよ" &lt;&lt; std::endl;
    return 0;
}</pre>
            </section>
        </article>
    </section>
    <nav class="bottom">
        <ul>
            <li><a href="./08preprocess_and_constant.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./10introduction_of_pointer.html" title="次頁">next</a></li>
        </ul>
    </nav>
</body>
</html>
