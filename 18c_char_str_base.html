<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>第18章 ～C言語の文字と文字列～</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/sanitize.css/2.0.0/sanitize.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <script src="./syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushPlain.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushCpp_kai.js" type="text/javascript"></script>
    <link href="./syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css">
    <link href="./syntaxhighlighter/styles/shThemeMidnight_likeVS.css" rel="stylesheet" type="text/css">
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <h1>第18章 ～C言語の文字と文字列～</h1>
    <nav class="top">
        <ul>
            <li><a href="./17rand-num.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./" title="次頁">next</a></li>
        </ul>
    </nav>
    <section>
        <h2>はじめに</h2>
        <p>
            C言語には文字列という概念がありません。NULL文字で終わるバイト集合があるだけです。<br>
            ・・・と書いても何が何やらさっぱりだと思うので、順番に解説します。<br>
            配列についでの理解があやふやな場合、ポインターを矢印に例えて誰かに説明できそうにない場合は引き返してください。
        </p>
    </section>
    <section>
        <h2>符号化文字集合と符号化方式</h2>
        <p>まずここが理解できないとすべてが宙ぶらりんでその場しのぎの理解になってしまいます。なのでプログラミングから一旦離れて解説しようと思います。</p>
        <!--http://equj65.net/tech/charcode/-->
        <p>まず、以下のキーワードを覚えてください。</p>
        <dl>
            <dt>文字</dt>
            <dd>私たちが普段見ている文字。その形そのもの</dd>
            <dt>符号点</dt>
            <dd>符号点は文字を割り当て「うる」点のことである、ようは文字に仮想的に数値（普通非負の整数）を割り当てた（文字を座標空間に対応付けた）ものである。</dd>
            <dt>バイト列</dt>
            <dd>実際にPC等であつかう数値の羅列。符号点と一致することもある</dd>
        </dl>
        <p>覚えたかな？もうちょっとだけ続くんじゃ。</p>
        <dl>
            <dt>符号化文字集合</dt>
            <dd>文字と符号点を対応付けるもの</dd>
            <dt>符号化方式</dt>
            <dd>符号点とバイト列を対応付けるもの</dd>
        </dl>
        <p>
            で、すべての文字の表し方がこれに従っているかというと、そうでもありません。もう一度いいます、必ずしも符号化文字集合と符号化方式の2つがあるわけではありません。<br>
            しかも、上の「符号化文字集合」と「符号化方式」の説明も必ずしも正しくありません。というのはいろんな規格でいろいろ言っていたり、定義があやふやだったりするからです。
            じゃあ今までの話は意味がなかったのか？というとそんなことはありません。
        </p>
        <blockquote>
            <p>
                シフトJISが符号化文字集合? - yanok.net<br>
                <a href="http://yanok.net/2011/08/jis-2.html">http://yanok.net/2011/08/jis-2.html</a>
            </p>
            <p>
                肝心なことは、「符号化文字集合と文字符号化方式」という区分は絶対的・本質的なものでは必ずしもないということです。そういう区分を設けた方が便利なときだけ、採用すればいいわけです。
            </p>
        </blockquote>
        <p>ということです。まあ、抽象的な話ばっかしていても仕方ないので実例を上げましょう</p>
        <dl>
            <dt>符号化文字集合</dt>
            <dd>JIS X 0208, JIS X 0213, Unicodeなど・・・</dd>
            <dt>符号化方式</dt>
            <dd>Shift-JIS, EUC, UTF-8, UTF-16, UTF-32など・・・</dd>
            <dt>そんな区分ねーから</dt>
            <dd>ASCII, Latin-1, Big5など・・</dd>
        </dl>
        <p>
            みんなテキストエディタの保存の設定でよく見たことが有りますよね？<br>
            最初に言ったようにShift-JISとかUTF-16やUTF-32だけ覚えてくれてればとりあえずいいです。
        </p>
        <p>
            ところが某Windowsのエディターのせいで混乱はますます広がってしまいます。詳しくは<br>
            <a href="http://equj65.net/tech/charcode/">http://equj65.net/tech/charcode/</a>
        </p>
    </section>
    <section>
        <h2>C/C++言語では文字をどう扱うか</h2>
        <p>でこれら文字符号化形式をC/C++でどう扱うかですが、実はいまだにごたついています(VCのせい)。あれれ～。</p>
        <dl>
            <dt>char型</dt>
            <dd>実装定義ですが、char型が1byteなので普通Shift-JISかUTF-8を入れます。</dd>
            <dt>wchar_t型</dt>
            <dd>
                これまた実装定義ですが、Unicodeには違いないです。今のところVCではUTF-16, mingw-gccではUTF-32のようです。<br>
                どちらになるかはマクロ__STDC_UTF_16__、__STDC_UTF_32__が1になってるのがどちらか、で分かります。
            </dd>
            <dt>char16_t型(C11/C++11 or later)</dt>
            <dd>UTF-16になります</dd>
            <dt>char32_t型(C11/C++11 or later)</dt>
            <dd>UTF-32になります</dd>
        </dl>
        <p>で、毎度のことですが、VCは規格を準拠する気がないので、さっぱり実装が進みませんでした。2015年夏に正式release予定のVisual Studio 2015でようやっと実装されます(Preview版でも実装されている)。遅っそいわ！</p>
    </section>
    <section>
        <h2>文字リテラル(Character literals)</h2>
        <p>整数リテラルや小数リテラルがあるんだから、当然文字リテラルも有ります。が、これまた揉めたんだ。</p>
        <pre class="brush: cpp;">/* 以前からある記法 */
// 型はchar、値は実装依存。
auto ordinary_c = 'x' ;
// 型はwchar_t、値は実装依存。
auto wide_c = L'x' ;

/* C11/C++11 以降で追加されている記法 */
// 型はchar16_t、符号化方式はUTF-16、値は、0x3042。
auto u16_c = u'あ' ;
// 型はchar32_t、符号化方式はUTF-32、値は、0x00003042。
auto u32_c = U'あ' ;

/* C++17以降の記法 */
//型はchar、符号化方式はUTF-8、 値は0x78
auto u8_c = u8'x';</pre>
        <p>LとかuとかUとかu8とかをprefixといいます。</p>
        <p>u8-prefixをつけるときは必ずその文字がsingle UTF-8 code unit、つまり8bitに収まる必要があります。ようは</p>
        <pre class="brush: cpp;">auto u8_c = u8'あ';//ill-formed</pre>
        <p>はダメです。同様にu-prefixをつけるときは必ずその文字が16bitに収まる必要があります。ようは</p>
        <pre class="brush: cpp;">auto u16_c = u'𠮷';//ill-formed</pre>
        <p>
            はダメです。なおこのように文字型に収まりきらない文字は2つで一つだったり3つで１つの文字を表すわけですが(文字列リテラルを参照)、こういうのをサロゲートペアといいます。<br>
            今のところ、UTF-32なら32bitですべての世界中の文字を表せる、ということになっています。
        </p>
        <p>
            で、なぜかu8のCharacter literalsのprefixとしての機能だけつまはじきにあってC++17に追いやられています(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf">n4296</a>)<br>
            uとUはC11/C++11で採用されました(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf">n3337</a>,<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf">n3797</a> )。<br>
            でVisualStudioはuとUにVisualStudio2015でようやく対応しました。u8はVisual Studio 2015で対応予定となっていますが、今のところPreview版では実装されていません。
        </p>
    </section>
    <section>
        <h2>エスケープシーケンス</h2>
        <p>いくつかの特殊な文字を表すために、\(バックスラッシュ)から始まるエスケープシーケンスが存在します。なお\(バックスラッシュ)自体が表せなくなるため、それ自体のエスケープもあります。</p>
        <table>
            <tr><th>エスケープシーケンス</th><th>文字名(日本語)</th><th>文字名(英語)</th><th>文字</th></tr>
            <tr><td>\n</td><td>改行</td><td>new-line</td><td>NL(LF)</td></tr>
            <tr><td>\t</td><td>水平タブ</td><td>horizontal tab</td><td>HT</td></tr>
            <tr><td>\v</td><td>垂直タブ</td><td>vertical tab</td><td>VT</td></tr>
            <tr><td>\b</td><td>バックスペース</td><td>backspace</td><td>BS</td></tr>
            <tr><td>\r</td><td>キャリッジリターン</td><td>carriage return</td><td>CR</td></tr>
            <tr><td>\f</td><td>フォームフィード</td><td>form feed</td><td>FF</td></tr>
            <tr><td>\a</td><td>アラート文字、ベル文字</td><td>alert</td><td>BEL</td></tr>
            <tr><td>\\</td><td>バックスラッシュ</td><td>backslash</td><td>\</td></tr>
            <tr><td>\?</td><td>疑問符</td><td>question mark</td><td>?</td></tr>
            <tr><td>\'</td><td>単一引用符</td><td>single quote</td><td>'</td></tr>
            <tr><td>\"</td><td>二重引用符</td><td>double quote</td><td>"</td></tr>
        </table>
        <pre class="brush: cpp;">'\n';//OK
'\\';//OK
'\"';//OK
'"';//OK
'\?';//OK
'?';//OK
'\';//エラー</pre>
    </section>
    <section>
        <h2>文字列リテラル</h2>
        <p>当然文字列リテラルもあります。文字列リテラルとは、<b>NULL文字で終端する</b>文字リテラルの集合です。例を見ましょう。</p>
        <pre class="brush: cpp;">auto str = "arikitari";//型はconst char*
auto w_str = L"arikitari";//型はconst wchar_t*

/* C11/C++11 以降で追加されている記法 */
//u8も文字列リテラルのprefixとしてはC++11の範疇でVisualStudio2015で対応
auto u8_str = u8"arikitari";//型はconst char*
auto u16_str = u"arikitari";//型はconst char16_t*
auto u32_str = U"arikitari";//型はconst char32_t*</pre>
        <p>まあ文字リテラルとあんま変わらないですね。注意点ですが文字リテラルはconstポインター型です。なのでこんなことはできません</p>
        <pre class="brush: cpp; highlight: [6,10];">#include &lt;iostream&gt;
#include &lt;cstdio&gt;
void do_something(char* in_str);
void do_something2(char const* in_str);
int main(void){
    char* str0 = "arikitari";//C++11以降ではエラー。constを暗黙のうちに消しさることは許されない
    auto str = "arikitari";
    "arikitari"[2] = 'a';//未定義動作。やるべきじゃない
    str[2] = 'a';//エラー。strはread-only pointer
    do_something(str);//C++11以降ではエラー。constを暗黙のうちに消しさることは許されない
    do_something2(str);//OK
    return 0;
}
void do_something(char* in_str){
    puts(in_str);
}
void do_something2(char const* in_str){
    puts(in_str);
}</pre>
        <p>10行目みたいなことは昔はできたらしいのですが(書いたことないから知らん)、するべきではありませんね。6行目は論外。</p>
        <p>ここで改めてputs関数のプロトタイプ宣言を見てみましょう。</p>
        <pre class="brush: cpp;">int puts(const char *str);</pre>
        <p>もうなんで引数がchar*型でなくてchar const*型かわかりますね。もちろん引数を変更しませんよ、という意味もあるのですが、それ以上に</p>
        <pre class="brush: cpp;">#include &lt;stdio.h&gt;
int main(void){
    puts("arikitari na world!");//画面に表示
    return 0;
}</pre>
        <p>のように文字リテラルを引数に指定できるようにするためです。</p>
        
        <p>ここまでで必然的に導き出される結論ですが、他のこれまで紹介したリテラルと異なり、<b>string literalsはread-only lValueである</b>、ということです。</p>
        <p>
            参考サイト<br>
            文字列リテラル（String literals）| C++11の文法と機能(C++11: Syntax and Feature)<br>
            <a href="http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#lex.string">http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#lex.string</a>
        </p>
    </section>
    <section>
        <h2>配列と文字列リテラル</h2>
        <p>
            さっきも述べたとおり文字列リテラルは変更不可能(読み取り専用)なlValueです。変更できません。<br>
            これでは困ります。そこで登場するのが配列です。初期化リストの代わりに文字列を使えます。
        </p>
        <pre class="brush: cpp;">char str[] = "arikitari";
char str2[10];
str2 = "arikitari";//エラー</pre>
        <p>なので定義と同時である必要があります。</p>
        <p>ところでここまで書けばもう既にわかっていると思いますが、以下の2つは同値です。</p>
        <pre class="brush: cpp;">// 以下の二行のコードは同じ意味である。
char s[4] = { 'a', 'b', 'c', '\0' } ;
char s[] = "abc" ;</pre>
        <p>なんどでもいいますが、Cの文字列は必ずNULL文字(\0)で終端します。なので<b>文字列の長さ+1の大きさの領域が必要となります</b>。</p>
        <pre class="brush: cpp;">char str1[9] = "arikitari";//conflicting declaration(矛盾する宣言)</pre>
        <p>
            ようはこれはダメってこと。
            で、こうしてできた配列は変更可能なlValueなので<b>変更できます。</b>やったね。
        </p>
        <pre class="brush: cpp;">char str[] = "arakitari";
puts(str);//arakitari
str[2] = 'i';
puts(str);//arikitari
</pre>
    </section>
    <section>
        <h2>Shift-JISなんて捨ててしまえ(Windowsの呪縛から逃げられない人の無駄なあがき)</h2>
        <p>
            何も考えずにShift-JISを普段使いがちですが(あるいは意識すらしていない？)、これは誤った選択です。<br>
            例えば、Win32APIの文字周りはUNICODE(UTF-16, UTF-32)とShift-JISの2つが選択できますが、後者は<b>下位互換性(バイナリ互換性)のためだけに存在する馬鹿げた機能なので使うべきではないのです</b><br>
            つまり以下の3箇所で文字コードに注意する必要があります。
        </p>
        <ul>
            <li>ソースコードの文字コード　→　問答無用でUTF-8 BOM付き、ただし最後の行は空行(EOFのみ)に</li>
            <li>文字・文字列リテラルの文字コード　→　u8prefixをつければいい</li>
            <li>コンパイラーの文字コード変換機能　→　本来はいじらなくていいんだけど(後述)</li>
        </ul>
        <p>
            ところがWindowsは日本語対応という点でLinuxに比べて非常に遅れています。<br>
            GNU/Linuxの方がWindowsより日本語サポートが優れている | 本の虫<br>
            <a href="http://cpplover.blogspot.jp/2012/04/gnulinuxwindows.html">http://cpplover.blogspot.jp/2012/04/gnulinuxwindows.html</a><br>
            コマンドラインを強化せよ! - Windows 7のコマンドプロンプトをカスタマイズする (3) コマンドプロンプトのフォントとウィンドウサイズを変更する.1 | マイナビニュース<br>
            <a href="http://news.mynavi.jp/articles/2011/07/05/commandline/002.html">http://news.mynavi.jp/articles/2011/07/05/commandline/002.html</a><br>
            コマンドラインを強化せよ! - windows 7のコマンドプロンプトをカスタマイズする (3) コマンドプロンプトのフォントとウィンドウサイズを変更する.1 | マイナビニュース<br>
            <a href="http://news.mynavi.jp/articles/2011/07/05/commandline/003.html">http://news.mynavi.jp/articles/2011/07/05/commandline/003.html</a><br>
            だれがレジストリいじったりフォント変えたりしてまでコマンドプロンプトでUTF-8を使うんですかねぇ。<br>
            というわけでもうしばらくコンパイラー側でShift-JISに変える日々が続きそうです。Windows10のコマンドプロンプトは改善されたのかな・・・？<br>
            なお、Unicode文字を一時的に表示させるにはコマンドプロンプトのtypeコマンドを使うのが手っ取り早いという奇妙な事態になっています。
        </p>
        <p>コンパイラーで出力文字列の文字コード変換をする方法ですが</p>
        <dl>
            <dt>Visual Studio</dt>
            <dd>デフォルトで</dd>
            <dt>gcc</dt>
            <dd>
                コンパイルオプションに<br>
                <pre class="brush: plain;">-fexec-charset=CP932</pre>
                但しutf-8なソースを読ませるために
                <pre class="brush: cpp;">--input-charset=utf-8</pre>
                も必要
            </dd>
            <dt>clang</dt>
            <dd>
                uft-8なソースはデフォルトで読めるから気にしなくていいけど出力は変換できないっぽい。コマンドプロンプトなんてクソや！
            </dd>
        </dl>
        <p>
            というわけで主にWindowsのせいで話がややこしくなっています。なので、<b>コンソールアプリケーションに限っては</b>コンパイラー側でShift-JISを使う日々になりそうです。<br>
            従ってprefixも<b>コンソールアプリケーションに限っては</b>なくていいや、という結論に至ります。おのれWindows！
        </p>
        <p>なお、言うまでもなくWin32APIを使ったGUIの文字はUNICODE対応ですから、<b>迷うことなくwchar_t型とLprefixを</b>使いましょう</p>
        <p>またGUI開発で有名なQTは事実上UTF-8 BOM付きを要求しますので、u8prefixの活躍の機会です(Visual Studio2015から使えるようになる)</p>
    </section>
    <nav class="bottom">
        <ul>
            <li><a href="./17rand-num.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./" title="次頁">next</a></li>
        </ul>
    </nav>
</body>
</html>
