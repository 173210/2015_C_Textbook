<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>第8章 ～プロプロセッサと定数まとめ～</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/sanitize.css/2.0.0/sanitize.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <script src="./syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushPlain.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushCpp_kai.js" type="text/javascript"></script>
    <link href="./syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css">
    <link href="./syntaxhighlighter/styles/shThemeMidnight_likeVS.css" rel="stylesheet" type="text/css">
    <script src="./scripts/common.js" type="text/javascript"></script>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <h1>第8章 ～プロプロセッサと定数まとめ～</h1>
     <nav class="top">
        <ul>
            <li><a href="./07roop_and_split_Sourcecode.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./09standard_input_output.html" title="次頁">next</a></li>
        </ul>
    </nav>
    <section>
        <h2>プリプロセッサー</h2>
        <p>
            お待たせしました。ようやくプリプロセッサーのお話です。<br>
            はい、#includeとかなにげに書いてきたものが何なのかわかります。
        </p>
        <ul>
            <li>#include</li>
            <li>#define</li>
            <li>#if/#else</li>
            <li>#ifdef/#ifndef</li>
            <li>#error</li>
            <li>#warning</li>
            <li>
                #pragma
                <ul>
                    <li>#pragma once</li>
                    <li>#pragma comment</li>
                    <li>#pragma ident</li>
                </ul>
            </li>
        </ul>
        <p>
            これだけ種類が有ります。解説するのは#includeと#define、#pragma once、#pragma commentにとどめます。他は<br>
            <a href="http://itref.fc2web.com/c/preprocessor.html">http://itref.fc2web.com/c/preprocessor.html</a><br>
            を参照してください。なお、#if/#else/#ifdef/#ifndefはこれまでもこれからもしれっと使います。
        </p>
        <section>
            <h3>#include</h3>
            <p>.cとか.cppが読み込めないわけではないのですが、ほぼ100%ヘッダーファイルを読み込むのに使います。</p>
            <pre class="brush: cpp;">#include "DxLib.h"
#include &lt;stdio.h&gt;</pre>
            <p>
                一般的なお話として、&lt;&gt;で囲むとコンパイラーの規定の場所とコンパイルオプションで指定した(gccなら-Iオプション)場所からヘッダーファイルを探します。<br>
                また、""で囲むと、それに加えて、#includeを書いたファイルと同じ場所も捜索対象になります。<br>
                ゆえに自分で作ったヘッダーは""で囲い、C/C++標準ライブラリ―のヘッダーは&lt;&gt;で囲むのが普通です。ありきたり。
            </p>
        </section>
        <section>
            <h3>#define</h3>
            <p>しばしば、const, enumと並んで定数を作る、と言われますが、残念ながらいずれも定数ではありません。</p>
            <p>#defineはコンパイル前にソースコードを置換するものです。で、「マクロ」と呼ばれます。Excelとかのマクロとはちと違うので注意です。</p>
            <pre class="brush: cpp;">#define WINDOW_HEIGH 1024</pre>
            <p>こんな風に定数っぽいのを作ることもできますし</p>
            <pre class="brush: cpp;">#define MAX(A, B) (A > B)? A : B</pre>
            <p>みたいに関数もどきも作れます。・・・がしかし、使いません。だってそれぞれ</p>
            <pre class="brush: cpp;">static const int WINDOW_HEIGH = 1024;
template&lt;typename T_&gt;
inline T_ max(T_ a, T_ b){
    return (a > b)? a : b;
}</pre>
            <p>のほうがわかりやすいじゃん。で、マクロを何に使うかというと、コンパイラー間の差異を吸収するために使います。どういうことでしょうか？</p>
            <p>
                最初に話したとおり、コンパイラーには何種類か有りますが、その中でも人口が多いVisual Studio C Compiler(以降VC)とGNU C Compiler(以降gcc)の２つだけ見ても、その差異は大きいです。<br>
                例えばfloat型とdouble型の計算速度のところで出したサンプルコードを見てみましょう。
            </p>
            <pre class="brush: cpp; first-line: 4">#if !defined (__GNUC__) || defined(__ICC) || defined(__clang__)
#pragma comment(lib, "setupapi.lib")
#pragma comment(lib, "hid.lib")
#pragma comment(lib, "winmm.lib")
#endif</pre>
            <p>
                ifndefというのはそのマクロ(この場合__GNUC__)が既に定義されているかを(プリプロセッサが)調べ、真なら対応するendifまでを有効にするものですが(偽ならその部分はコンパイラーに渡されない)<br>
                あとで説明する通りgccは「#pragma comment」という書き方はできません。この場合だとコンパイルオプションに
            </p>
            <pre class="brush: plain">-lsetupapi -lhid -lwinmm</pre>
            <p>つけるわけですが・・・ってそんな話はよくって、対応してない機能をコンパイラーに渡すと当然コンパイルエラーになるのでこのようにgccコンパイラーでコンパイルする時を考えてこのように書いています。</p>
            <p>すでに察しているかもしれませんが何も書かなくてもいくつかのマクロがdefineされています。例えばVCなら_MSC_VER、gccなら__GNUC__,__GNUC_MINOR__などがその代表的なものになります。</p>
            <pre class="brush: cpp; first-line: 3;" title="arikitari.h">#if (defined(_MSC_VER) && _MSC_VER > 1000) || (defined(__clang__) && (__clang_major__ > 3 || (__clang_major__ == 3 && __clang_minor__ > 2))) ||(defined(__ICC) && __ICC > 1000) ||defined (__GNUC__) && !defined(__ICC) && !defined(__clang__) && (__GNUC__ >= 4 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#pragma once
#endif</pre>
            <p>
                ヘッダーファイルに分ける、のところで書いたこの文の意味も今なら分かるでしょう。<br>
                #pragma onceという書き方に対応したのがVisual Studio.NET 2003以降、gcc3.4以降、clang3.3(3.2でバグが有ったっぽい)以降、Intel C Compiler10.00以降だからです。
            </p>
            <p>
                どのコンパイラーで何が定義されているかは<br>
                C/C++ tip: How to detect the compiler name and version using compiler predefined macros | Nadeau Software<br>
                <a href="http://nadeausoftware.com/articles/2012/10/c_c_tip_how_detect_compiler_name_and_version_using_compiler_predefined_macros">http://nadeausoftware.com/articles/2012/10/c_c_tip_how_detect_compiler_name_and_version_using_compiler_predefined_macros</a><br>
                の解説が非常に詳しくわかりやすいです。
            </p>
        </section>
        <section>
            <h3>#pragma comment</h3>
            <p>なんかすでに使っているので解説が必要か疑問ですが、.libファイルや.aファイルをリンカーにくっつけて、とお願いするために使います。ただし先述の通りVCやclang,bcc等限定の機能になります。</p>
            <p>なのでgccでコンパイルする予定があるなら(常にその可能性を想定するべきですが)さっきのような対策が必要です。</p>
        </section>
        <section>
            <h3>#pragma onceとインクルードガード</h3>
            <p>その昔#pragma onceが使えなかった頃、ヘッダーファイルが複数読み込まれると、2重定義です、と言われコンパイルエラーになりました。この対策として</p>
            <pre class="brush: cpp;">#ifndef _INC_STDIO
#define_INC_STDIO
//ヘッダーファイルの中身を書く
#endif /* _INC_STDIO */</pre>
            <p>といったことをしていました。こういう書き方をインクルードガードといいます。でもこんなの書くのはめんdいですよね？そこで生まれたのが#pragma onceです。</p>
            <p>ヘッダーファイルの冒頭に</p>
            <pre class="brush: cpp;">#pragma once</pre>
            <p>と書くだけです。</p>
            <p>ただし、普通は#defineを使ったインクルードガードと併用します。その理由は実際に使っていれば分かるはず。複数のヘッダーで同じことを書かないといけない時にこれがあると便利なんです。</p>
        </section>
        <section>
            <h3>#pragma warning</h3>
            <p>実例を見たほうが早いでしょう。プログラムはAviUtlプラグインで有名な透過性ロゴフィルター(makki氏)のSIMD化版(rigaya氏)の一部です。</p>
            <pre class="brush: cpp; highlight:[11,12];">#pragma warning (push)
#pragma warning (disable: 4244) //C4244: '=' : 'int' から 'short' への変換です。データが失われる可能性があります。
static BOOL create_adj_exdata(FILTER *fp, LOGO_HEADER *adjdata, const LOGO_HEADER *data)
{
	int i, j;
	if (data == NULL)
		return FALSE;
	// ロゴ名コピー
	memcpy(adjdata->name, data->name, LOGO_MAX_NAME);
	// 左上座標設定（位置調整後）
	adjdata->x = data->x + (int)(fp->track[LOGO_X]-LOGO_XY_MIN)/4 + LOGO_XY_MIN/4;
	adjdata->y = data->y + (int)(fp->track[LOGO_Y]-LOGO_XY_MIN)/4 + LOGO_XY_MIN/4;
	//中略
	return TRUE;
}
#pragma warning (pop)</pre>
            <p>
                このプログラムでは11,12行目がint型からshorに暗黙の型変換を行おうとしているのでコンパイル警告が出ます。<br>
                もしshort型で表せない大きさのデータだったら正常に変換できないのでこの警告はもっともな話です。むしろ警告してくれてありがとうです。<br>
                しかし、作者曰くこの場合はそうはならないらしいです。だとすればその警告は目障りです。なのでこのように#pragma warningを使って警告を消しています。<br>
                ただしプログラム全体でその警告が消えると不都合なので、この関数だけ警告が消えるように#pragma warning (push)/(pop)しています。
            </p>
            <p>
                ただしこの書き方はVCの書き方でgccだとまた書き方が違います。<br>
                VCだと警告番号ですがgccやclangだと警告の種類を指定するようです。<br>
                warning | MSDN<br>
                <a href="https://msdn.microsoft.com/ja-jp/library/2c8f766e.aspx">https://msdn.microsoft.com/ja-jp/library/2c8f766e.aspx</a><br>
                Diagnostic Pragmas - Using the GNU Compiler Collection (GCC)<br>
                <a href="https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Pragmas.html">https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Pragmas.html</a><br>
                controlling diagnostics via pragmas | clang 3.7 documentation<br>
                <a href="http://clang.llvm.org/docs/UsersManual.html#controlling-diagnostics-via-pragmas">http://clang.llvm.org/docs/UsersManual.html#controlling-diagnostics-via-pragmas</a>
            </p>
            <pre class="brush: cpp;" title="VC">#pragma warning (push)
#pragma warning (disable: [警告番号])
    //警告を無効にする部分のコード
#pragma warning (pop)</pre>
            <pre class="brush: cpp;" title="gcc">#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "[警告の種類]"
    //警告を無効にする部分のコード
#pragma GCC diagnostic pop</pre>
            <pre class="brush: cpp;" title="clang">#pragma clang diagnostic push
#pragma clang diagnostic ignored "[警告の種類]"
    //警告を無効にする部分のコード
#pragma clang diagnostic pop</pre>
            <p>
                大事なことを言います。本来警告が出たら出ないようなコードを書くべきなのです。このように警告を消したり、キャストして警告を消すのはやってはいけません。<br>
                なんどでもいいますが、本来は「警告を出していただき、コンパイラー様、ありがとうございます」なのです。<br>
                明確に問題ない、と言える警告を除き、警告を消すことのないようにしましょう。
            </p>
        </section>
    </section>
    <section>
        <h2>定数</h2>
        <p>C/C++における定数はC++11まで含めると5つあります。ただ、定数と一口にいっても3つに大きく分かれます。</p>
        <dl>
            <dt>実行時定数</dt>
            <dd>プログラムの実行中に変数を読み取り専用にすることで、書き換えができなくなるようにするもの</dd>
            <dd>ex.)const</dd>
            <dt>コンパイル時定数</dt>
            <dd>コンパイル時に値を決定できるので計算してしまい単なる数値などのリテラルにするもの</dd>
            <dd>ex.)enum X { ver = 0}, constexpr, enum class</dd>
            <dt>プリプロセス時定数</dt>
            <dd>プリプロセス時に値を決定できるのでソースコードを置換してしまうもの</dd>
            <dd>ex.)#define</dd>
        </dl>
        <p>ではそれぞれ見て行きましょう。</p>
        <section>
            <h3>const</h3>
            <p>constは例えばこんなふうに書けるのでした。</p>
<pre class="brush: cpp;">const int x = 7;
</pre>
            <p>
                ところで変数は関数のスタック上に確保されるのでした。<br>
                <code>int</code>型のように小さい型ならいいのですが、この後出てくる構造体や大きな配列は大きいサイズなので、(まずないと思いますが)スタックを使い尽くすことがあるかもしれません。<br>
                そこで
            </p>
<pre class="brush: cpp;">static const int x = 7;</pre>
            <p>
                のように<code>static</code>をつけるといいです。<code>static</code>変数の生存期間はスコープに左右されず(だってスタックに積まれないもん)プログラムの開始から終了までとなります。<br>
                中には<code>const</code>をつけるなら<code>static const</code>にするべきだ、という宗教も存在しますが、マルチスレッドや、非同期処理やポインタがからむと話が厄介になるのでおすすめしません。
            </p>
            <p class="strong">第一いちいち<code>static</code>って書くなんてめんdじゃないですか。</p>
            <p>
                一方で<b>関数の外に書く場合は</b>、グローバル変数(どこからでもアクセスできる変数)になるのを防ぐために<b>必ず<code>static</code>をつけるべき</b>です。<br>
                こうすることで有効範囲がそのファイルに限定されます。includeしても使えません。<br>
                <code>constexpr</code>あるんだからそんな場面ないと思いますが。
            </p>
        </section>
        <section>
            <h3> #define</h3>
            <p>これはプリプロセッサマクロで、例えばこんなふうに書けるのでした。</p>
<pre class="brush: cpp;">#define var 5 </pre>
            <p>ところで<code>#define</code>マクロにはいくつかの問題点があり、コンパイラー間の差異やターゲット環境の差異を吸収する時を除き使うことはありません。当然定数として使うこともありません。では問題点を見て行きましょう。</p>
            <section>
                <h4>型がないことに起因する冗長さ</h4>
                <p>verに型はありません。C言語ではそれでもいいかもしれませんが、C++ではオーバーロードという、変数の型によって同名の関数とかとかを呼び分ける機能があるのでこれでは困ります。</p>
                <pre class="brush: cpp;">//int16_t型はshort型、int32_t はint型、int64_t型はlong long型と仮定する
int64_t add(int32_t a, int32_t b);
int32_t add(int16_t a, int16_t b);
#define ver1 5
#define ver2 10
int main(void){
    auto x = add(ver1, ver2);
    return 0;
}</pre>
                <p>ここでxの型は何でしょうか？正解はlong long型です。つまり関数addは上のほうが呼ばれています。では下の方を呼ぶには？</p>
                <pre class="brush: cpp; first-line: 7;">auto x = add(static_cast&lt;int16_t>(ver1), static_cast&lt;int16_t&gt;(ver2));</pre>
                <p>冗長でしょ。<code>constexpr</code>使えば</p>
                <pre class="brush: cpp;">int64_t add(int32_t a, int32_t b);
int32_t add(int16_t a, int16_t b);
constexpr int16_t ver1 = 5;
constexpr int16_t ver2 = 10;
int main(void){
    auto x = add(ver1, ver2);
    return 0;
}</pre>
                <p>すっきり。</p>
            </section>
            <section>
                <h4>単なるソースコード置換であることに起因する問題</h4>
                <p>早速例を見ましょう。</p>
                <pre class="brush: cpp;">#define BASE_SIZE 1 &lt;&lt; 8
int main(void){
    auto tmp = BASE_SIZE + 4;
    return 0;
}</pre>
                <p>tmpの型はいうまでもなく<code>int</code>ですね。で、tmpには何が入るでしょうか？260？いえいえ、4096です。なぜならばこれは以下のように置換されるからです。</p>
                <pre class="brush: cpp;">auto tmp = 1 &lt;&lt; 8 + 4;</pre>
                <p>つまり</p>
                <pre class="brush: cpp;">auto tmp = 1 &lt;&lt; 12;</pre>
                <p>となっています。まあ、この場合は</p>
                <pre class="brush: cpp;">#define BASE_SIZE (1 &lt;&lt; 8)</pre>
                <p>とすればいいんですけどね。めんdでしょ。きっと忘れるし。今回の例の場合は回避方法は2通りですかね</p>
                <pre class="brush: cpp;">static const unsigned int BASE_SIZE = 1 &lt;&lt; 8;
constexpr unsigned int BASE_SIZE = 1 &lt;&lt; 8;</pre>
            </section>
            <section>
                <h4>置換がプロプロセス時であることに起因する問題</h4>
                <p>#defineの値はコンパイルより前、プリプロセス時に置換されます。なのでコンパイラーには変数名がわからないのです。これによりコンパイルエラーなどで原因究明が著しく困難になります。</p>
            </section>
            <section>
                <h4>スコープがないことに起因する問題</h4>
                <p>
                    #defineとenum以外はすべてスコープの概念があります。<br>
                    スコープの概念がないと何が問題かというと、#defineに関して言えば書いたファイルとそれをincludeしているファイルでその名前が消費されるので、変数名の衝突が起こしやすくなります。
                </p>
            </section>
        </section>
        <section>
            <h3>enum</h3>
            <p>enumを使った定数っぽい書き方はこんな感じでした。</p>
            <pre class="brush: cpp;">enum { var = 5 };
int main(void){
    int tmp1 = var;
}</pre>
            <p>しかしこれにも問題点が有ります。</p>
            <section>
                <h4>冗長</h4>
                <p>定数を使いたいだけなのに書く量がおおく、普通の変数宣言と書き方が少し違う。そもそも幾つもの関連のある定数もどきを列挙して宣言するためのものなんだから、なにか間違っている</p>
            </section>
            <section>
                <h4>スコープがない</h4>
                <p>#defineと同じ理由なので以下略。</p>
            </section>
        </section>
        <section>
            <h3>enum class(scoped enumeration)</h3>
            <p>enum　classを使った定数っぽい書き方はこんな感じでした。</p>
            <pre class="brush: cpp;">enum class tag{ var = 5 };
int main(void){
    int tmp1 = static_cast&lt;int&gt;(tag::var);
}</pre>
            <p>しかしこれにも問題が有ります。</p>
            <section>
                <h3>冗長</h3>
                <p>キャストを無駄に強いる。それが便利なこともあるだろうけど、なんか間違っている気がする。あとはenumと同様。</p>
            </section>
        </section>
        <section>
            <h3>constexpr</h3>
            <p>これはC++11で導入された記法でコンパイル時定数を作るために導入されました。既に何度か使用していますが改めて。書き方は</p>
            <pre class="brush: cpp;">constexpr unsigned long tmp = 32;
static_assert(2147483647L &lt;= std::numeric_limits&lt;int&gt;::max(), “”); 
</pre>
            <p>
                です。すっきり。コンパイル時定数なのでこの後習う配列や、template、static_assartにも使用できます。
                が、C++で定数を返す関数もこれに対応しているはずなんですけど、Visual Studio 2013 Novenber 2013 CTPでは対応しない。VC2015使えってことね。
            </p>

<pre class="brush: cpp;">
constexpr size_t tmp = 32;
int tmp[tmp];
static_assert(2147483647L &lt;= std::numeric_limits&lt;int&gt;::max(), “”);//VC2015以降
</pre>
            <p>
                <code>constexpr</code>に関する非常にわかりやすく、詳しい解説はこちら<br>
                <a href="http://www.slideshare.net/GenyaMurakami/onstexprcpu">constexpr関数はコンパイル時処理。これはいい。実行時が霞んで見える。cpuの嬌声が聞こえてきそうだ</a>
            </p>
            <section>
                <h4>constexprとrVarue reference</h4>
                <p>
                    クラスを作るまでお世話になることはありませんが、C++にはrVarue Referenceという物があります。<br>
                    こいつとこの<code>constexpr</code>を組み合わせるとC++11の範囲だと正常に<code>std::move</code>できないそうです。<br>
                    この辺についてはこのテキストではほとんど解説しないので、<a href="./15value.html">rvarueの解説</a>の参考リンクを参照してください。<br>
                    constexprとrvalue参照問題 - とくにあぶなくないRiSKのブログ<br>
                    <a href="http://sscrisk.hatenablog.com/entry/2014/05/31/constexpr%E3%81%A8rvalue%E5%8F%82%E7%85%A7%E5%95%8F%E9%A1%8C">http://sscrisk.hatenablog.com/entry/2014/05/31/constexprとrvalue参照問題</a>
                </p>
            </section>
        </section>
        <section>
            <h3>まとめ</h3>
            <ul>
                <li>実行中に定数に(Read-Only)にしたいならconst</li>
                <li>コンパイル時定数が作りたいなら<code>constexpr</code></li>
                <li>ポインターを取る必要があるならconst</li>
            </ul>
            <p>を使う。実にスッキリした結論。C++最高！</p>
        </section>
        <p>
            参考サイト<br>
            定数の定義は，const intか，#defineか，それとも - わさっき<br>
            <a href="http://d.hatena.ne.jp/takehikom/20140807/1407420548">http://d.hatena.ne.jp/takehikom/20140807/1407420548</a><br>
            #defineの罠<br>
            <a href="http://www.geocities.co.jp/bleis_tift/cpp/baddefine.html">http://www.geocities.co.jp/bleis_tift/cpp/baddefine.html</a><br>
            C言語のマクロの注意点<br>
            <a href="http://www.c-lang.org/detail/macro_caution.html">http://www.c-lang.org/detail/macro_caution.html</a>
        </p>
    </section>
    <nav class="bottom">
        <ul>
            <li><a href="./07roop_and_split_Sourcecode.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./09standard_input_output.html" title="次頁">next</a></li>
        </ul>
    </nav>
</body>
</html>