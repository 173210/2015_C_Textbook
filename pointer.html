<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>ポインター</title>
    <script src="./syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushPlain.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushCpp_kai.js" type="text/javascript"></script>
    <link href="./syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css">
    <link href="./syntaxhighlighter/styles/shThemeMidnight_likeVS.css" rel="stylesheet" type="text/css">
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <section>
        <h2>変数の住所</h2>
        <p>
            いままで変数はメモリー上に確保されると言ってきました。ところでメモリーと言っても実際にはCPUのキャッシュ領域(L1,L2,L3キャッシュ)、物理メモリー、HDDやSSDに置く仮想メモリーなどがあり、<br>
            これらをOSが管理してくれているお陰で、プログラマーは(高速化を意識しない限り)これらを1つのメモリーとして扱えているわけです。<br>
            GPGPUとかやるとOS管理領域のメモリーとGPU側のメモリーを別個に管理しないといけないのでものすご～く面倒なのです。一回一回メモリー転送するコードを書いたり。<br>
            で、そのひとまとめの空間には仮想的に住所が割り振られます。<br>
            言い換えるとすべての変数には住所があるわけです(関数だって住所がある)。<br>
            では早速その住所(アドレス)を取得してみましょう。
        </p>
        <pre class="brush: cpp;">#include &lt;stdio.h&gt;
int main(void){
    int p = 20,;
    printf(
        "変数p: %d\n"
        "変数pのアドレス: %p\n",
        p, &amp;p
    );
}</pre>
        <p>
            変数に入っている数値と変数のアドレスは無関係です、念のため。<br>
            変数のアドレス(住所)は「&amp;」を変数名の前につけると取得できます。便利。<br>
            なお、printfで表示するときは%pを使います。いや、たいていの処理系なら%xとか%dでもちゃんと表示してくれるだろうけどさ。<br>
            実行例はこんなかんじかな。
        </p>
        <pre class="brush: plain">変数p: 20
変数pのアドレス: 0038FBA4</pre>
        <p>
            このアドレスは実行するごとに変わっていると思います(まともなOSなら)。<br>
            もしこれが変化しないor予測可能な場合を考えてみましょう。プログラムAで使っている変数やら関数やらのデータを、プログラムBから書き換えることが容易になります。<br>
            これを利用したウィルスとかが一時期流行ったらしく、まともなOSならこれを防ぐためにスタック領域をランダムに配置する機能がついています。<br>
            このおかげで毎回変数のアドレスが変化するわけです。OSに感謝。え？MS-DOS?知らない子ですね。<br>
            なお、ほぼ同時に2回起動すると結果が同じになるかもしれません。これは、OSがプログラムを立ち上げるたびに適切に各プロセスにメモリーを割り当てた仮想的な空間の住所をポインターが表しているからです、まともなOSならね。
        </p>
    </section>
    <section>
        <h2>ポインター</h2>
        <p>
            みなさま、大変ながらくお待たせいたしました。ようやくポインターのお話です。まあ既に何回もチラチラ出てきてるわけですが。<br>
            ポインターとは、矢印のことで、矢印であるからには、根本と指示す先が有ります。以上です。<br>
            ・・・うそです。まあ大体今の説明でいいんだけど、例とか上げつつ実際に見てみましょう。でも今の矢印に例えるのは、C言語のポインターの理解にはものすごく役立つので覚えておいてください。<br>
            どのくらい大事かていうと、冷蔵庫の卵を入れるとこくらいには重要です。
        </p>
        <pre class="brush: cpp;">int a = 20;
int *p;
p = &amp;a;
printf("%d, %p, %d", a, p, *p);</pre>
        <p>3行目はさっきの変数のアドレスを取得するやつですね。こうすることでint*型の変数、pはaを指します。図を書いたほうがわかりやすいかな。</p>
        <div style="background-color: white;"><img alt="スタック領域" src="./pic/de_pointer_01.png"></div>
        <p>ポインターが指し示す先を取得するには変数名の前に「*」をつけます。「int *p;」の「*」とは意味が違います。なお</p>
        <pre class="brush: cpp;">int *p;
int* p;</pre>
        <p>は同値ですが、</p>
        <pre class="brush: cpp;">int* p1, p2;</pre>
        <p>とした時、p2の型は「int型」です。もっとも</p>
        <pre class="brush: cpp;">typedef int* int_ptr;
int_ptr pi, p2;</pre>
        <p>とすればどちらともint*型になりますが。C言語ってよぐわがんね。</p>
        <p>
            ポインターは、なにかを指すことで初めて意味を持つから派生型、とかいう言い方をするのですが、<br>
            ポインターと言っても、他の型から派生するという違いこそあるものの、所詮ただの型であり、型なんだからポインター型の変数もポインター型の値もあるわけです。<br>
            int型から派生したからint*型だったわけで、char型から派生すればchar*型になりますし、その他も以下略です。派生型ですから派生元の型しか差せません。
        </p>
        <p>
            なお、どんな型でもさせるポインター型というのもあり、void*型がそれです。ただし、使用時はキャストして元の型をコンパイラーに教える必要があります。<br>
            といったように内部的にchar*やint*があるわけではなく、単にコンパイラーが何から派生したか覚えてくれている、というだけのことなのです。
        </p>
        <pre class="brush: cpp;">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;limits.h&gt;//in gcc
#include&lt;errno.h&gt;//in gcc
#ifndef __cplusplus
#define nullptr NULL
#endif
int get_integer_num(const int max, const int min){
	//機能：標準入力を数字に変換する。
	//引数：戻り値の最大値,戻り値の最小値
	//戻り値：入力した数字、エラー時は-1,EOFのときはEOF
	char s[100];
	char *endptr;
	if (nullptr == fgets(s, 100, stdin)){
		if (feof(stdin)){//エラーの原因がEOFか切り分け
			return EOF;
		}
		return INT_MIN;
	}
	if ('\n' == s[0]) return INT_MIN;
	errno = 0;
	const long t = strtol(s, &endptr, 10);
	if (0 != errno || '\n' != *endptr || t < min || max < t)
		return INT_MIN;
	return (int)t;
}
int compare_int(const void *a, const void *b){
    return *static_cast&lt;int*&gt;(a) - *static_cast&lt;int*&gt;(b);
}
int main(void){
    const int num1 = get_integer_num(INT_MAX, INT_MIN);
    if(num1 == INT_MIN) return -1;
    const int num1 = get_integer_num(INT_MAX, INT_MIN);
    if(num2 == INT_MIN) return -1;
    const int result = compare_int(&amp;num1, &amp;num2);
    if(result > 0){
        puts("num1のほうが大きい");
    }
    else if(0 == result){
        puts("num1とnum2は等しい");
    }
    else{
        puts("num2のほうが大きい");
    }
}</pre>
        <section>
            <h3>NULLポインター</h3>
            <p>
                さて、ポインターは宣言した時は普通の変数がそうであるように、変数の値に何が入っているかわかりません。つまり、どこを指しているかわからないポインター、というわけです。<br>
                それで、どこも指していないことが保証されているポインターというのがあり、NULLポインターと呼ばれます。<br>
                詳細は省きますが、C言語的にはNULLがNULLポインターなのですが、みなさんC言語といいつつC++なので、<b>nullptrを使って</b>ください。<br>
                上のプログラムでもちゃっかり使っています。というかC言語でもnullptrって書きたいがためにむりくりdefineしてますが。<br>
                下を見てください。C++11以降のC++と思ってください。
            </p>
            <pre class="brush: cpp;">bool hoge1 = (NULL == nullptr);//false
void* hoge_ptr1 = NULL;
void* hoge_ptr2 = nullptr;
bool hoge2 = (hoge_ptr1 == hoge_ptr2);//true</pre>
            <p>
                とくに理由のない限り皆さんはC++としてコンパイルするわけで、標準規格への準拠がとっても遅いことで有名なVCもさすがにnullptrには対応しているので、こちらを使いましょう。<br>
                え？なんでNULL使っちゃダメかって？・・・ええっとそれを説明するにはC++の関数のオーバーロードのお話をしないといけないので、自分で調べてください。<br>
                C++ - NULL と nullptr って何が違う？ - Qiita<br>
                <a href="http://qiita.com/go_astrayer/items/6afb1592a8a5763fede1">http://qiita.com/go_astrayer/items/6afb1592a8a5763fede1</a><br>
                nullptrキーワード - yohhoyの日記<br>
                <a href="http://d.hatena.ne.jp/yohhoy/20120503/p1">http://d.hatena.ne.jp/yohhoy/20120503/p1</a><br>
                らへんが参考になると思います。ちなみにnullptrの型はstd::nullptr_t型です。javascriptだとnullポインターはnullです。・・・まあ、細けーことはいいんだよ、<b>nullptr使え</b>。
            </p>
        </section>
    </section>
    <section>
        <h2>ポインターと初期化</h2>
        <p>
            改めて、初期化です。<br>
            プログラマがその変数に何が入っているかわかるようにすることを初期化といいます。<br>
            ポインターは矢印に例えられますが、矢印の根本と、指示す先があるわけです。<br>
            したがって、矢印の根本(どこを指すか、というアドレス)と矢印の先(さされている確保されたメモリー空間)の双方がプログラマーにとって既知である必要があります。<br>
            断じて矢印の先を0埋めしたり、根本にnullptrを代入することではありません。<br>
            0やnullptrを代入する処理は他の値を代入する処理に比べて処理速度が早いというだけで、デバッグのしやすさを考えたら0xccとかを入れたほうがいいことも有ります。<br>
            ようはケース・バイ・ケース。
        </p>
    </section>
    <section>
        <h2>配列とポインター演算</h2>
        <p>
            はい、配列です。しょっちゅうポインターと混同されるかわいそうな子です。<br>
            ・・・ちゃんと説明します。配列とは、英語ではarrayと言います。配列は、（宣言時に指定される要素数）×（配列の要素の型の大きさ）分メモリーをスタック領域に確保し、<br>
            それを配列の要素の型の大きさづつに区切ってつかいます。忘れがちなことですが、<b>配列は0から始まります。</b><br>
            宣言する方法は
        </p>
        <pre class="brush: cpp;">int cell[10];</pre>
        <p>
            みたいに書きます。[]の中に要素数を指定するのですが、この要素数はコンパイル時にきまっている必要が有ります(C99/C11以外)。<br>
            なのでC99/C11以外ではこんな書き方はできません。C99/C11ではこの場合は厳密には配列ではないらしいです。まあC++で書けない書き方に価値なんてないね
        </p>
        <pre class="brush: cpp">unsigned int i = 10;
int tmp[i];</pre>
        <p>
            まあ実際に使ってみましょう。
        </p>
        <pre class="brush: cpp; highlight:[8,15,25];">#include&lt;stdio.h&gt;
#include&lt;time.h&gt;
#if !defined (_countof)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#endif
int main(void){
    int num[10] = { 0 };//宣言時に指定される要素数）×（配列の要素の型の大きさ）分メモリーをスタック領域に確保
    for(unsigned int i = 0; i < (sizeof(num) / sizeof(*num)); i++){
        *(num + i) = clock();
    }
    for(unsigned int i = 0; i < (sizeof(num) / sizeof(*num)); i++){
        printf("%d,", *(num + i));
    }
    putchar('\n');
    int* num_p = num;
    printf(
    	"_countof(num):%d,_countof(num_p):%d, sizeof(num_:%d, sizeof(num_p):%d\n",
    	_countof(num), _countof(num_p), sizeof(num), sizeof(num_p)
    );
    for(unsigned int i = 0; i < _countof(num); i++){
        printf("%d,", *(num_p + i));
    }
    putchar('\n');
    for(unsigned int i = 0; i < _countof(num); i++){
        printf("%d,", num[i]);
    }
    putchar('\n');
    for(unsigned int i = 0; i < _countof(num); i++){
        printf("%d,", num_p[i]);
    }
    putchar('\n');
    for(unsigned int i = 0; i < _countof(num); i++){
        printf("&amp;num[%d]:%p\n", i, (void*)&amp;num[i]);
    }
    return 0;
}</pre>
        <p>実行例としてはこんなかんじでしょうか。</p>
        <pre class="brush: plain">4859,4860,4860,4861,4861,4861,4862,4862,4862,4863,
_countof(num):10,_countof(num_p):1, sizeof(num_:40, sizeof(num_p):4
4859,4860,4860,4861,4861,4861,4862,4862,4862,4863,
4859,4860,4860,4861,4861,4861,4862,4862,4862,4863,
4859,4860,4860,4861,4861,4861,4862,4862,4862,4863,
&num[0]:0xbfa4d84c
&num[1]:0xbfa4d850
&num[2]:0xbfa4d854
&num[3]:0xbfa4d858
&num[4]:0xbfa4d85c
&num[5]:0xbfa4d860
&num[6]:0xbfa4d864
&num[7]:0xbfa4d868
&num[8]:0xbfa4d86c
&num[9]:0xbfa4d870</pre>
        <p>
            7行目で「{}」という見慣れないものが有りますが、初期化子リストとかいうものです。この場合初期化する意味はないのですが、説明のために使っています。<br>
            リストに書いた値の個数が配列の要素数より小さい場合、残りの要素が0で埋められる、という性質を利用しています。<br>
            C++ならこんな面倒なことをしないでも{}と書けば十分なんですけどね。まあC++でも「初期化している感が出る」という理由でCっぽく{ 0 }と書く人もかなりいるんですが。<br>
            この2者、微妙に意味が違い、さらにCとC++でも若干意味が違うので、興味があるなら下のサイトを見るといいかもしれません。<br>
            本の虫: aggregateと初期化リストの不思議<br>
            <a href="http://cpplover.blogspot.jp/2010/09/aggregate.html">http://cpplover.blogspot.jp/2010/09/aggregate.html</a><br>
            本の虫: 多くのプログラマは言語を表面的な理解だけで使っている<br>
            <a href="http://cpplover.blogspot.jp/2010/09/blog-post_18.html">http://cpplover.blogspot.jp/2010/09/blog-post_18.html</a>
        </p>
        <p>
            11～23行目と24～34行目を比較すれば分かるかと思いますが、以下の3つはすべて同値です。というより1番目の簡便記法が2番目と3番目です。
        </p>
        <pre class="brush: cpp;">*(num + i)
num[i]
i[num]</pre>
        <p>ただし、<b>3行目の書き方はしないように</b>しましょう。普通1行目の書き方はめんどいので2行目のように「num[i]」と書きます。といえば分かるように、演算子「[]」は配列とはなんの関係もない演算子です(添字演算子って言います)。</p>
        <p>
            よく勘違いされますが、numの型は「int*」型ではありません。「int[10]」型です。どう違うかは多次元配列のとこで説明します。
        </p>


        <p>
            ただし、sizeof演算子と&amp;演算子(アドレス演算子)のオペランドと配列初期化時の文字列リテラルと(lvalue)参照に代入するときは配列として扱われ、読み替えはされません。詳細はおいおい。
        </p>
        <p>
            15行目を見てください。ここでnum代入したことでnum_pは配列numの先頭要素をさしています。だから配列と同じく*(num_p + i)とかnum_p[i]のように書けるわけです。<br>
            ここについてはすぐに詳細解説をします。<br>
            ちなみにこのポインターが配列を挿してなかった場合、num_pは要素数1の配列のように扱われるので、num_p[1]とすることは許されてもnum_p[2]と書いたり、num_p[1]に何かを代入することは許されません。
        </p>
        <pre class="brush: cpp;">sizeof(num) / sizeof(*num)</pre>
        <p>
            と書きましたが、これ自体は配列の要素数を求めています。さっきの話通り、numはint[10]型だからsizeof(num)でnumの配列全体の大きさが分かるわけです。あとは要素1つの大きさで割れば要素数が求まるよね？<br>
            ちなみにこの方法は有名なのでnumofマクロとか_countofマクロとして知られ、Visual Studioでは、stdlib.hをincludeすると_countofマクロが使えます。(日本語版のMSDNの訳が腐ってるので英語版を見てください)<br>
            <a href="https://msdn.microsoft.com/en-US/library/ms175773.aspx">https://msdn.microsoft.com/en-US/library/ms175773.aspx</a><br>
            gccの場合は・・・ここを参照してください。<br>
            <a href="http://stackoverflow.com/questions/4415530/equivalents-to-msvcs-countof-in-other-compilers">http://stackoverflow.com/questions/4415530/equivalents-to-msvcs-countof-in-other-compilers</a><br>
            これらを使うと配列以外に使用するとコンパイルエラーになってくれます。だってあくまでint[10]型だからこんなことが出来るわけで、int*型に対して使えるわけがないよね？<br>
            C++なら参照を使えよ、という指摘はさておき。<br>
            参考までにVCでの実装を書いておきます。C++の参照が何か理解してないと全く意味不明だろうけどね。
        </p>
        <pre class="brush: cpp; first-line: 356;">/* _countof helper */
#if !defined (_countof)
#if !defined (__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else  /* !defined (__cplusplus) */
extern "C++"
{
template &lt;typename _countoftype, size_t _sizeofarray&gt;
char (*__countof_helper(_UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
#define _countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
}
#endif  /* !defined (__cplusplus) */
#endif  /* !defined (_countof) */</pre>
        <section>
            <h3>ポインター演算</h3>
            <p>
                さて、先ほど*(num_p + i)のようにさらっとポインター演算という機能を使っていました。これはもともとC言語の前身、B言語にあった機能です。<br>
                ポインター演算とは、ポインターに整数を足したり引いたりポインター同士で引き算を行ったりする演算です。<br>
                コンパイラーには、numの要素の型の大きさがわかっています。だってでっかく確保したメモリー空間をint型の大きさで区切っただけだもんね、あたりまえだよね。<br>
                この区切り一つ一つを配列の要素と言うわけですが、これに1加算すると隣の区切りが見られる、ということになります。例を見てください。
            </p>
            <pre class="brush: cpp;">int hoge[] = {5, 7, 9, 4};
int * hoge_p = hoge;
printf("sizeof(int)=%d", sizeof(int));
printf("hoge_p..%p:%d", hoge_p, *hoge_p);
hoge_p++;
printf("hoge_p..%p:%d", hoge_p, *hoge_p);</pre>
            <p>hoge_pの値がsizeof(int)分加算されているのがわかると思います。配列でhoge[2]とか書けるのはこの機能のおかげなのです。まあ普段は意識することはないのですが。</p>
        </section>
        <section>
            <h3>添字演算子とポインターと配列と</h3>
            <pre class="brush: cpp; first-line: 14; highlight:[15];">    putchar('\n');
    int* num_p = num;
    printf(
    	"_countof(num):%d,_countof(num_p):%d, sizeof(num_:%d, sizeof(num_p):%d\n",
    	_countof(num), _countof(num_p), sizeof(num), sizeof(num_p)
    );
</pre>
            <p>
                改めてさっきのプログラムの15行目を見てください。numはここでは配列の名前です。が、しかし単なるポインター型に読み替えられます。つまり、numと書いた瞬間それはint[10]型からint*型に読み替えられているわけです。<br>
                注意して欲しいのが、「Cでは、配列名の後に[]を付けずに配列名だけ単独で書くと、配列の先頭要素へのポインター、という意味になります」というのは嘘だ、ということです。<br>
                配列の宣言時に確かに[]を使いますが(俺は宣言時のをstd::vectorみたいに()にしてればこんな誤解はなかったと思うんだが)、それ以外では先にちらっと話した4つの例外を除き、<br>
                <b>配列は問答無用でポインターに読み替えられます</b>。<br>
                だって、これら全部同じ意味だもんね。あたりまえだよね。(プログラム例は前橋和弥著 C言語ポインター完全制覇p57-p61を改変)
            </p>
            <blockquote>
                <pre class="brush: cpp; highlight:[6,7,8];" title="プログラムA">#include&lt;stdio.h&gt;
int main(void){
    int array[5] = { 0, 1, 2, 3, 4 };
    unsigned int i;
    int* p;
    for(p = &amp;array[0]; p != &amp;array[5]; p++){
        printf("%d," *p);
    }
    
    return 0;
}
</pre>
                <pre class="brush: cpp; first-line: 6;" title="プログラムB">p = &amp;array[0];
for(i = 0; i < 5; i++){
    printf("%d," *(p + i));
}</pre>
                <pre class="brush: cpp; first-line: 6;" title="プログラムC">p = array;
//&amp;array[0] -&gt; &amp;*(array + 0) -&gt; array + 0 -&gt; array
//みたいなイメージ。&amp;*(array + 0)なんて書き方はできないけど。
for(i = 0; i < 5; i++){
    printf("%d," *(p + i));
}</pre>
                <pre class="brush: cpp; first-line: 6;" title="プログラムD">p = array;
for(i = 0; i < 5; i++){
    printf("%d," p[i]);
}</pre>
                <pre class="brush: cpp; first-line: 6;" title="プログラムE">for(i = 0; i < 5; i++){
    printf("%d," array[i]);
}</pre>
            </blockquote>
            <p>それで、上記のプログラムからついでに</p>
            <pre class="brush: cpp;">*(num + i)
num[i]
i[num]</pre>
            <p>の証明もできたわけですが。</p>
            <p>ちなみに、C++にはイテレータというポインターもどきのようなものが有り、これの使い方がプログラムAにそっくりなので頭の片隅に入れておきましょう。(サンプルはC++11の機能を使っています)</p>
            <pre class="brush: cpp;">std::vector&lt;int&gt; data{ 0, 1, 2, 3, 4 };//This usage is a thing of C++11.
int total = 0;
for(data_it = data.begin(); data_it != data.end(); data_it++) {
    total += *data_it; 
}</pre>
        </section>
    </section>
    <section>
        <h2>多次元配列・・・という名の幻想</h2>
        <p>
            結論から言うとほとんど使いません。ほとんど後述する構造体配列、もしくはポインター型の配列で代替が効き、またそのほうが扱いやすいです。<br>
            私なんかプログラミング講習会で習って以降、1回くらいしか使ったことがない気がします。<br>
            多次元配列を使おうと思う前にまず、本当に構造体配列ではダメなのかを考えましょう。どうしても、って場合でもC++のvectorのvectorとか、C99の可変長配列を使いましょう。
        </p>
        <p>
            そうはいってもこれを説明しないわけにはいかないので、無理やり例を考えました。この例の場合、私なら迷うことなく後述するmallocとか使ってポインター型の配列にしてしまいますが。
        </p>
        <script src="http://gist-it.appspot.com/github/yumetodo/2015_C_Textbook/blob/gh-pages/src/Multidimensional_array/Multidimensional_array/Multidimensional_array.cpp"></script>
        <p>まずはmain関数から見て行きましょう。22行目を見てください。</p>
        <pre class="brush: cpp; first-line: 21; highlight:[22];">int main(void){
	int working_time[12][31] = { { 0 } };
	const int64_t time_sum = calc_annual_working_time(working_time, 12);</pre>
        <p>2次元配列も宣言・定義の仕方や初期化の仕方は普通の配列と大差ありません。</p>
        <p>
            sum_array関数は1次元配列(普通の配列)を合計するごくごくありきたりな関数です。問題はcalc_annual_working_time関数です。<br>
            2つの関数のプロトタイプ宣言を見比べてみましょう。
        </p>
        <pre class="brush: cpp; first-line: 13;">int sum_array(int const* in_array, const size_t array_num);</pre>
        <pre class="brush: cpp; first-line: 13;">int64_t calc_annual_working_time(const int working_time[][31], const int month_per_year);</pre>
        <p>
            1次元配列を受け取るsum_array関数はint const* in_arrayのように受け取っていますが、<br>
            2次元配列を受け取るcalc_annual_working_time関数はconst int working_time[][31]のようにややこしくなっています。<br>
            なぜint** working_timeのように書けないのでしょうか？
        </p>
        <p>
            その理由はタイトルでネタバレしている通り、多次元配列という存在が幻想にすぎないことに由来します。例えば2次元配列は、配列の配列として存在しています。<br>
            上記の例の場合、例えばworking_time[6][7]にアクセスしたい場合、内部ではsizeof(working_time[0])*6 + 7のようにポインター演算しています。<br>
            この演算をコンパイラーにしてもらうためには、sizeof(working_time[0])がコンパイラーに分かる必要が有ります。ここで大事なのが「型」です。
        </p>
        <p>
            そもそも変数hanako_worked_timeの型は何でしょうか？<br>
            答えはint[12][31]型です。ところで、配列は式の中では4つの例外を除きポインターに読み替えられるのでした。<br>
            １次元配列を渡しているsum_array関数でint in_array[31]と書かず、int const* in_arrayと書いた理由がこれでした。どうせ[31]の部分は失われるので。
            ２次元配列を渡しているcalc_annual_working_time関数に渡すときも同様に[12]の部分は情報が失われます。しかし、[31]の部分は失われません。<br>
            つまり、calc_annual_working_time関数内では変数working_timeの型はint(*)[31]となっているわけです。<br>
            このおかげでcalc_annual_working_time関数内でworking_time[2][0]とかworking_time[i]みたいにアクセス出来るわけです。<br>
            もしint** working_timeのように書いた場合こういうことはできませんね。
        </p>
        <p>
            で、やっと「結論から言うとほとんど使いません」と最初に言った理由が説明できます。<br>
            もし、hanako_worked_timeの配列の要素数、たとえば宣言がint hanako_worked_time[12][33]とかなった場合、calc_annual_working_time関数の引数も変更しなければなりません。<br>
            ・・・めんdいし、忘れそうですよね？だいいち、いちいち要素数を関数の引数に書くなんてめんdいじゃないですか。<br>
            殆どの場合構造体配列か構造体にポインターを入れるか、ポインター型の配列にするか、1次元配列を2次元配列っぽく使うかの4択で解決します。
        </p>
        <pre class="brush: cpp;">typedef struct RGB{
    uint8_t r;
    uint8_t g;
    uint8_t b;
}rgb_t;
void do_something(rgb_t* color);
int64_t calc_annual_working_time(int const* const* working_time, const int month_per_year);
int main(void){
    int* hanako_worked_time[12];
    for(auto i : hanako_worked_time){
        i = new int[31];
    }
    rgb_t color[720 * 408];
    
    do_something(color);
    const int64_t time_sum = calc_annual_working_time(hanako_worked_time, 12);
    for(auto i : hanako_worked_time){
        delete[] i;
    }
    return 0;
}
</pre>
        <p>こんな感じ。え？何やってるかわかんねー？いいんだよ、今はわかんなくても。</p>
    </section>
    <section>
        <h2>構造体</h2>
        <p>
            お待たせしました。構造体です。無茶めちゃ使います。え？C++にはクラスあるから使わないだろって？<br>
            いやいや、こいつにはこいつの良さがあるんですよ、そこの奥さん。<br>
            上で既にさらっと使っています。幾つか特徴とか用途とか利点とかグチャグチャに書くと
        </p>
        <ul>
            <li>幾つかセットで必ず扱うデータは必ずこれを使う。配列？そんなもの知らないなぁ</li>
            <li>宣言順にメモリー上に並ぶ</li>
            <li>型の大きさが異なるデータだってまとめられる。ただしたいていはアラインメント(詰め物して全部同じ大きさに)される</li>
            <li>関数ポインターと組み合わせればクラスっぽく使うこともできなくはない(めんどいけど)</li>
            <li>Cでリストや木構造を実現するにはこれを使うしかない</li>
        </ul>
        <p>な感じ？使い方を改めて書きましょう。</p>
        <pre class="brush: cpp;">struct{
    unsigned int high_num;
    unsigned int low_num;
} big_num;</pre>
        <p>ここでhigh_numとかlow_numをメンバー変数と言います。なお変数名であるbig_numまでが型名です。はい、むちゃんこ長いです。こんな長い型名いちいち書いていられません。そこで</p>
        <pre class="brush: cpp;">struct BIGNUM{
    unsigned int high_num;
    unsigned int low_num;
};

struct BIGNUM big_num;</pre>
        <p>
            とすると幾分かましになります。「BIGNUM」の部分はタグ名、と言います。<br>
            1～3行目は普通関数の外に書きます。しかし変数宣言時にいちいち「struct」と書くのはめんdいです。なので
        </p>
        <pre class="brush: cpp;">struct BIGNUM{
    unsigned int high_num;
    unsigned int low_num;
};
typedef struct BIGNUM bignum_t;

bignum_t big_num;</pre>
        <p>とか構造体定義とtypedefも一緒にやるようにして</p>
        <pre class="brush: cpp;">typedef struct BIGNUM{
    unsigned int high_num;
    unsigned int low_num;
}bignum_t;

bignum_t big_num;</pre>
        <p>
            のように、これら最後の２つの書き方のどちらかで普通書きます。<br>
            注意として、構造体定義の中で今目下つくろうとしている型名を使うにはtypedefと構造体定義は別々にやるかtypedef前に型名を書く必要が有ります。
        </p>
        <p>
            実際にどう使うかを見るにはやはり世の中で使われているソフトのソースコードが一番です。今回はL-SMASH WorksというAviUtlとかとかのプラグインから。
        </p>
        <pre class="brush: cpp;" title="./common/libavsmash.hと./common/libavsmash.cより">typedef struct
{
    int                   error;
    int                   update_pending;
    int                   dequeue_packet;
    uint32_t              count;
    uint32_t              index;    /* index of the current decoder configuration */
    uint32_t              delay_count;
    uint8_t              *input_buffer;
    AVCodecContext       *ctx;
    libavsmash_summary_t *entries;
    extended_summary_t    prefer;
    lw_log_handler_t      lh;
    int  (*get_buffer)( struct AVCodecContext *, AVFrame *, int );
    struct
    {
        uint32_t       index;       /* index of the queued decoder configuration */
        uint32_t       delay_count;
        uint32_t       sample_number;
        AVPacket       packet;
        enum AVCodecID codec_id;
        uint8_t       *extradata;
        int            extradata_size;
        /* Parameters stored in audio summary doesn't always tell appropriate info.
         * The followings are imported from CODEC specific extensions. */
        int sample_rate;
        int bits_per_sample;
        int channels;
    } queue;
} codec_configuration_t;
AVCodec *libavsmash_find_decoder
(
    codec_configuration_t *config
)
{
    assert( config->ctx );
    enum AVCodecID codec_id = config->ctx->codec_id;
    if( codec_id == AV_CODEC_ID_NONE )
    {
        /* Try to get any valid codec_id from summaries. */
        for( uint32_t i = 0; i < config->count && codec_id == AV_CODEC_ID_NONE; i++ )
            codec_id = get_codec_id_from_description( config->entries[i].summary );
        config->ctx->codec_id = codec_id;
    }
    return avcodec_find_decoder( codec_id );
}
</pre>
        <p>この様にtypedefと同時ならタグ名は省略できます(無名構造体)。</p>
        <p>構造体のメンバー変数にアクセスするには変数名の後に「.」をつけます</p>
        <pre class="brush: cpp;">codec_configuration_t conf;
const uint32_t max = conf.count;</pre>
        <p>配列同様初期化リストも使えます。また、配列と違い、「=」でコピーができます。</p>
        <pre class="brush: cpp;">typedef struct BIGNUM{
    unsigned int high_num;
    unsigned int low_num;
}bignum_t;
const bignum_t big_num = { 327, 2268 };
const bignum_t big_num2 = big_num;</pre>
        <p>
            ところでこれでは困ることが有ります。関数に構造体を渡す時です。<br>
            配列の場合は勝手にポインターに読み替えられたので、配列がまるまるコピーされる、なんて自体にはならなかったのですが、構造体の場合はコピーされます。<br>
            構造体はさっきの実例のように大きなデータになりやすいのでコピーにも時間がかかります。例えば構造体の一部を書き換えるだけの関数だったら2回もコピーする必要が有ります。
        </p>
        <pre class="brush: cpp;">typedef struct RGB{
    uint8_t r;
    uint8_t g;
    uint8_t b;
}rgb_t;
rgb_t toGrayscale_stupid(rgb_t color){
    const uint8_t y = ((4918 * (uint32_t)color.r + 354) >> 10)
                        + ((9655 * (uint32_t)color.g + 585) >> 10)
                        + ((1875 * (uint32_t)color.b + 523) >> 10);
    const rgb_t re = {y, y, y};
    return re;
}
int main(void){
    rgb_t pic[720 * 408];
    //picに値をセット
    for(auto i : pic){
        i = toGrayscale_stupid(i);
    }
    return 0;
}</pre>
        <p>いくらなんでも無駄すぎます。そこで</p>
        <pre class="brush: cpp; first-line: 7;">rgb_t* toGrayscale_stupid2(rgb_t* color){
    const uint8_t y = ((4918 * (uint32_t)(color->r) + 354) >> 10)
                        + ((9655 * (uint32_t)(color->g) + 585) >> 10)
                        + ((1875 * (uint32_t)(color->b) + 523) >> 10);
    color->r = y;
    color->g = y;
    color->b = y;
    return color;
}
int main(void){
    rgb_t pic[720 * 408];
    //picに値をセット
    for(size_t i = 0; i < 720 * 408; i++){
        color[i] = toGrayscale_stupid(color[i]);
    }
    return 0;
}</pre>
        <p>
            としましょう。最も、for文はこの場合toGrayscale関数内に書いたほうがいいです。関数がinline展開されなかった場合、無茶めちゃ遅いコードになります。<br>
            第一配列を受け取るように改造するのはとっても楽ですからね。<br>
            なお「->」はアロー演算子とかいう大層な名前がついていますが、「(*).」の略記です。つまり、
        </p>
        <pre class="brush: cpp;">color->r
(*color).r</pre>
        <p>が同値になる、という意味です。さて、グレースケール化関数を使いやすくしましょう。</p>
        <pre class="brush: cpp; first-line: 7;">void toGrayscale(rgb_t* color, size_t pixel_num){
    for(size_t i = 0; i < pixel_num; i++){
        const uint8_t y = ((4918 * static_cast&lt;uint32_t&gt;(color[i].r) + 354) >> 10)
                            + ((9655 * static_cast&lt;uint32_t&gt;(color[i].g) + 585) >> 10)
                            + ((1875 * static_cast&lt;uint32_t&gt;(color[i].b) + 523) >> 10);
        color[i].r = y;
        color[i].g = y;
        color[i].b = y;
    }
}
int main(void){
    rgb_t pic[720 * 408];
    //picに値をセット
    toGrayscale(pic, _countof(pic));
    return 0;
}</pre>
        <p>
            こんな感じかな？すごいね、なんと写真のグレースケール化ができちゃったよ(SIMD化など、高速化の余地は有り)。<br>
            ちなみに変換式はITU-R BT.601-7のRGB-YCbCr変換の式を利用しています。<br>
            ほかにITU-R BT.709-5の式があります。<br>
            AviUtlの内部形式について-【copied】MakKi's SoftWare<br>
            <a href="https://e182bb01e8864f37f9ce365b879822eb6da3f1f1.googledrive.com/host/0B-PAN4aatmy1ZGctNFU0YlFJc2c/doc/aviutlyc.html">https://e182bb01e8864f37f9ce365b879822eb6da3f1f1.googledrive.com/host/0B-PAN4aatmy1ZGctNFU0YlFJc2c/doc/aviutlyc.html</a><br>
            ITU-R BT.601 について|まるも<br>
            <a href="http://www.marumo.ne.jp/bt601/">http://www.marumo.ne.jp/bt601/</a><br>
            Aviutl の内部形式と x264guiEx の色空間変換について | rigaya<br>
            <a href="https://onedrive.live.com/view.aspx?cid=6BDD4375AC8933C6&resid=6BDD4375AC8933C6!755">https://onedrive.live.com/view.aspx?cid=6BDD4375AC8933C6&resid=6BDD4375AC8933C6!755</a><br>
            この辺を参考にしてみてください。
        </p>
        <p>
            話がそれています。配列の時は各要素へのアクセスは内部的にポインター演算をしていました。構造体はどうなのでしょうか？<br>
            実は同じです。ただし構造体は配列と違って異なる型も格納できます。なので内部的に詰め物をしていることが多いです。<br>
            そのほうが楽だもんね。
        </p>
    </section>
    <section>
        <h2>ポインタと動的確保</h2>
        <p>
            配列では要素数が固定でした。やっぱり途中で要素数を変更したいことは有りますよね。そして多くの場合要素数は可変でなければならない局面が多いです。<br>
            しかし、純粋な動的確保はほとんどやりません。なぜなら、自分で要素数を増やしたり減らしたりするコード書くのは面倒だからです。<br>
            C++のSTLにはこういうことをやってくれるコンテナ型がたくさんあり、それぞれ様々な特徴があります。<br>
        </p>
        <blockquote>
            vector, list, forward_list#, deque, priority_queue,<br>
            set, multiset, unordered_set#, unordered_multiset#,<br>
            map, multimap, unordered_map#, unordered_multimap#,<br>
            array#, bitset, stack, queue<br>
            #：C++11で規格化
        </blockquote>
        <p>
            よく使うのはvector, unordered_map, deque, forward_list, listくらいかな。詳細は<br>
            [C++] STLの型の使い分け - Qiita<br>
            <a href="http://qiita.com/h_hiro_/items/a83a8fd2391d4a3f0e1c">http://qiita.com/h_hiro_/items/a83a8fd2391d4a3f0e1c</a>
        </p>
        <p>
            しかし裏でどんなことやってるかわかっておく必要はあるので解説していきます。まあさっきさらっと使ったんですけどね。
        </p>
        <p>これまで、変数はすべてスタック領域に確保してきました。今回はヒープ領域に確保していきます。違いとしては</p>
        <ul>
            <li>速度が気持ち落ちる</li>
            <li>確保したら開放しなければならない</li>
        </ul>
        <p>
            というところでしょうか。まあ、"動的"確保というだけあって、確保するサイズを実行中に決められたり、途中で大きさを変えられるわけです。<br>
            まあ使ってみましょう。とりあえず連結リストと呼ばれる物を作ってみましょう。目指すは蔵書管理システム。
        </p>
        <script src="http://ideone.com/e.js/MJn3Un" type="text/javascript"></script>
        <p>なんか50行くらいで終わるはずだったんだけどちょっと長くなったな・・・。Cで文字列扱う気にはならなかったのでC++のstd::string、splitする都合上std::vectorを利用しています。説明？するする、そのうち。</p>
        <p>自分でライブラリーでも作んない限りC++を使えばお世話になることはまず無いです。あとはC++のクラスのコンストラクタの中くらいか・・・？</p>
    </section>
    <section>
        <h2>lValueとrvalue</h2>
        <p>一度ポインターから話が離れます。lValueとrValueです。左辺値と右辺値という風に訳されることが多いですが(JISのC++規格書日本語訳版がそう訳してる)、誤解を招くのでlValueとrValueと呼ぶことにします。</p>
        <p>でこれらが何者か？ですが、ちょっと幾つか引用したいと思います(書くのが面倒だったわけじゃないんだからねっ！)。</p>
        <blockquote cite="http://cpplover.blogspot.jp/2009/11/rvalue-reference_23.html">
            <p>
                rvalue reference 完全解説 | 本の虫<br>
                <a href="http://cpplover.blogspot.jp/2009/11/rvalue-reference_23.html">http://cpplover.blogspot.jp/2009/11/rvalue-reference_23.html</a>
            </p>
            <p>
                Cの時代では、lvalueとrvalueの違いは、代入演算子の左側か右側かという違いだけであった。つまり、left hand value, right hand valueの略である。<br>
                従って、訳語も、左辺値、右辺値であった。C++においては、これはもはや正しくはない。従って、右辺値、左辺値というのも、誤訳である。<br>
                それ故に、ここでは、これ以上、左辺値、右辺値という名称を使用しない。
            </p>
            <p><b>誤解を恐れずにいえば、lvalueとは、明示的に実体のある、名前付きのオブジェクトであり、rvalueとは、一時的に生成される無名のオブジェクトである。</b></p>
            <pre class="brush: cpp;">struct X{} ;
int f() { return 0 ; }
int main()
{
　　int i = 0 ;
　　i ;　　 // lvalue
　　0 ;　　 // rvalue
　　X x ;
　　x ;　　 // lvalue
　　X() ;　 // rvalue
　　f() ;　 // rvalue
}</pre>
            <p>上記のコードを読めば、lvalueとrvalueの違いが、なんとなく分かってくれる事と思う。lvalueはrvalueに変換できるが、その逆、rvalueをlvalueに変換することは出来ない。 </p>
        </blockquote>
        <blockquote cite="https://msdn.microsoft.com/ja-jp/library/f90831hc.aspx">
            <p>
                左辺値と右辺値 | MSDN<br>
                <a href="https://msdn.microsoft.com/ja-jp/library/f90831hc.aspx">https://msdn.microsoft.com/ja-jp/library/f90831hc.aspx</a>
</p>
            <p>
                すべての C++ の式は左辺値または右辺値です。 左辺値は、1 つの式を超えて保持するオブジェクトを参照します。 <br>
                lvalue は、名前を持つオブジェクトと考えることができます。 変更不可能な (const) 変数を含めて、すべての変数は左辺値です。 <br>
                右辺値は、それを使用する式を超えて保持されない一時的な値です。 lvalues と rvalues の相違点をより詳しく理解するために、次の例について考えてみましょう。 
            </p>
            <pre class="brush: cpp;">#include &lt;iostream&gt;
using namespace std;
int main()
{
   int x = 3 + 4;
   cout << x << endl;
}</pre>
            <p>この例では、x は、これを定義する式の外側で保持されるので、左辺値です。 式 3 + 4 は右辺値です。定義した式を超えては存在しない一時的な値と評価されるためです。 </p>
            <p>次の例は、左辺値と右辺値の正しい使用方法と間違った使用方法のいくつかを示しています。</p>
            <pre class="brush: cpp;">int main()
{
   int i, j, *p;
   // Correct usage: the variable i is an lvalue.
   i = 7;
   // Incorrect usage: The left operand must be an lvalue (C2106).
   7 = i; // C2106
   j * 4 = 7; // C2106
   // Correct usage: the dereferenced pointer is an lvalue.
   *p = i; 
   const int ci = 7;
   // Incorrect usage: the variable is a non-modifiable lvalue (C3892).
   ci = 9; // C3892
   // Correct usage: the conditional operator returns an lvalue.
   ((i < 3) ? i : j) = 7;
}</pre>
        </blockquote>
        <p>もう説明やめていいかな・・・(なにも説明してないけど)？ようはlvalueは明確に実体があって、rvalueは一時的なものなんだよ。</p>
        <p>
            もっと詳しく知りたい人は<br>
            何が lvalue で何が rvalue なのか - iorateの日記<br>
            <a href="http://d.hatena.ne.jp/iorate/20111207/1323280542">http://d.hatena.ne.jp/iorate/20111207/1323280542</a><br>
            を見てください。
        </p>
    </section>
    <section>
        <h2>template入門</h2>
        <p>はい、入門です。こんなのまじめに解説したら本が一冊書けます。まあすでに出てきましたが。</p>
        <pre class="brush: cpp;">template&lt;typename T_&gt;
inline T_ max(T_ a, T_ b){
    return (a > b)? a : b;
}</pre>
        <p>みれば分かるように最大値を返す関数ですが、型が「T_」になってます。どういうことだってばよ？</p>
        <p>これまで最大値を求める関数を作ろうと思ったら全部の型ごとに関数を書く必要が有りました。事実C言語のmath.hを見ると同じような機能の型が違う関数が乱造されています。んなもんいちいち覚えてらんないですよね？</p>
        <p>そういった背景からC++では関数をオーバーロード出来るようになりました。つまり、<b>引数の型が異なれば</b>同名の関数をいくつでも作れるようになりました。</p>
        <p>関数のオーバーロードをするのにもっとも楽なのはtemplateを使って上のように書く方法です。コンパイラーはコンパイル時にどの型の関数が必要かわかるのでコンパイラーが型だけ違えた関数を勝手に作ってくれます。便利。</p>
        <p>まあ関数のオーバーロードよりは、クラスのオーバーロードで使うことのほうが多いんですけどね・・・、まいっか。</p>
        <p>ちなみにこの関数、もしchar*型の変数が引数になったらどうなるでしょうか？多分意図した動作では無いですよね？気をつけないと後述するスタックオーバーフローとかが起きかねないので注意です。</p>
    </section>
    <section>
        <h2>C++のlValue参照</h2>
        <p>すでに何回か登場していますが、今説明しないとあとで説明できなさそうなので。</p>
        <p>"lValue"参照って言うんだから当然"rValue"参照があるのですが、解説しません。</p>
        <blockquote>
            <p>
                C++マニアック,リファレンス＝参照の使い方,how to use reference,C++入門,C++言語講座<br>
                <a href="http://homepage2.nifty.com/well/Reference.html">http://homepage2.nifty.com/well/Reference.html</a>
            </p>
            <p>リファレンスとは何かということを解説するために、まず、最も簡単な例をあげましょう。次のコードを見てください。int 型の変数 iABitComplex のリファレンス riSimple を定義しています。</p>
            <pre class="brush: cpp;">int main() {
    int iABitComplex;               // ちょっと複雑な名前の変数
    int& riSimple = iABitComplex;   // 変数のリファレンスを定義する。
    riSimple = 1;                   // リファレンスを使って iABitComplex にアクセスする。
    return 0;
}</pre>
        </blockquote>
        <p>
            <b>参照とはあくまで元からあるlValue(変数とか)に別名をつける機能です。</b><br>
            たしかにポインターに似ていますが、<b>参照とポインターの関連性について意識してはいけません</b>。
        </p>
        <p>当面クラスとか使わないわけで、役に立つシーンは配列を関数に渡す場合です。例を見ましょう。</p>
        <pre class="brush: cpp;">#include &lt;stdio.h&gt;
#if !defined (_countof)
#if !defined (__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else  /* !defined (__cplusplus) */
extern "C++"
{
	template&lt;typename TYPE,	std::size_t SIZE&gt;
	std::size_t array_length(const TYPE(&)[SIZE]){
		return SIZE;
	}
#define _countof(_Array) array_length(_Array)
}
#endif  /* !defined (__cplusplus) */
#endif  /* !defined (_countof) */
void func(const int (&amp;in_arr)[4]) {
	printf("in_arr[0]:%d, sizeof(in_arr):%d, _countof(in_arr):%d\b", in_arr[0], sizeof(in_arr), _countof(in_arr));
}
int main () {
    int arr[] = {3,4,5,6};
    func(arr);
    return 0;
}</pre>
        <p>思い出してください、ここで変数arrの型はint[4]型でした。なので引数の型もint(&amp;)[4]にします。どういうことかというと、下の例はエラーになるということです。</p>
        <pre class="brush: cpp;">#include &lt;stdio.h&gt;
#if !defined (_countof)
#if !defined (__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else  /* !defined (__cplusplus) */
extern "C++"
{
	template&lt;typename TYPE,	std::size_t SIZE&gt;
	std::size_t array_length(const TYPE(&)[SIZE]){
		return SIZE;
	}
#define _countof(_Array) array_length(_Array)
}
#endif  /* !defined (__cplusplus) */
#endif  /* !defined (_countof) */
void func(const int (&amp;in_arr)[4]) {
	printf("in_arr[0]:%d, sizeof(in_arr):%d, _countof(in_arr):%d\b", in_arr[0], sizeof(in_arr), _countof(in_arr));
}
int main () {
    int arr[] = {3, 4, 5, 6, 7};
    int arr2[] = {3, 4, 5, 6};
    func(arr);//エラー。arrの型はint[5]型
    auto arr3 = arr2;
    func(arr3);//エラー。arr3の型はint*型であってint[4]型ではない。配列は4つの例外を除きポインターに読み替えられる。
    return 0;
}</pre>
        <p>まあ当たり前ですよね？ただ、<b>参照にポインター配列は渡せない、というのは忘れがちなので注意</b>ですね。</p>
        <p>配列の要素数が変わったぐらいで関数をいくつも作るなんであまりにもめんd過ぎます。そこでtemplate先生の出番です。先生、任せた！</p>
        <pre class="brush: cpp;">#include &lt;stdio.h&gt;
#if !defined (_countof)
#if !defined (__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else  /* !defined (__cplusplus) */
extern "C++"
{
	template&lt;typename TYPE,	std::size_t SIZE&gt;
	std::size_t array_length(const TYPE(&)[SIZE]){
		return SIZE;
	}
#define _countof(_Array) array_length(_Array)
}
#endif  /* !defined (__cplusplus) */
#endif  /* !defined (_countof) */
template&lt;size_t SIZE&gt;
void func(const int(&in_arr)[SIZE]){
	printf("in_arr[0]:%d, sizeof(in_arr):%d, _countof(in_arr):%d\b", in_arr[0], sizeof(in_arr), _countof(in_arr));
}
int main(){
    int arr[] = {3, 4, 5, 6, 7};
    int arr2[] = {3, 4, 5, 6};
    func(arr);//OK
    func(arr2);//OK
    auto arr3 = arr2;
    func(arr3);//エラー。arr3の型はint*型。配列は4つの例外を除きポインターに読み替えられる。
    return 0;
}</pre>
        <p>注意ですが、SIZEはコンパイル時に置き換えられるrValueです。変数ではないので要注意です。</p>
        <p>いい忘れましたが、関数funcで変数in_arrの型はint(&amp;)[SIZE]なので、当然sizeof演算子で配列の大きさを求められます。あたりまえだよね、参照って所詮別名だもん。</p>
        <pre class="brush: cpp; first-line: 16;">void func(const int* in_arr){
	printf("in_arr[0]:%d, sizeof(in_arr):%d, _countof(in_arr)", in_arr[0], sizeof(in_arr), _countof(in_arr));
    //sizeof(in_arr)はint*型の大きさを表し、ポインター型は要素数1の配列と同じなので_countof(in_arr)は1になる
}</pre>
        <p>
            ちなみに参照渡しでなくてポインター渡しで書くとこんな感じ。<br>
            配列の参照渡しとポインター渡しの違いをまとめておきます。ポインター配列ってのはmallocみたいに動的確保したやつね。
        </p>
        <table>
            <tr>
                <th>ポインター渡し</th><th>参照渡し</th>
            </tr>
            <tr>
                <td>ポインター配列を渡せる</td><td>ポインター配列を渡せない</td>
            </tr>
            <tr>
                <td>ポインター演算出来る</td><td>ポインター演算出来ない</td>
            </tr>
            <tr>
                <td>
                    渡された関数側で配列の要素数を<br>
                    知るには別途変数を渡す必要がある
                </td>
                <td>
                    渡された関数側で配列の要素数を<br>
                    知るにはsizeofや_countofを用いて分かる
                </td>
            </tr>
        </table>
        <p>
            まあなにが一番楽って、配列の要素数を別変数で渡さなくていいことですね。<br>
            多くの場合はポインター渡しと参照渡し両方を想定して関数をオーバーロードします。<br>
            引数が違えば同名の関数を複数作れるのがC++のオーバーロード機能だもんね。
        </p>
        <p>というわけで_countofが何をしているかもわかったはず。やったね。</p>
    </section>
    <section>
        <h2>改めましてfor文～Range-base for～</h2>
        <p>for文なら前にやっただろ、と思ったあなた、あれで説明が終わりだとほんとに思っていたのですか？</p>
        <p>復習ですがfor文とはこんなやつでした。</p>
        <pre class="brush: cpp;" title="Range-base for無使用1">#include &lt;stdio.h&gt;
#if !defined (_countof)
#if !defined (__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else  /* !defined (__cplusplus) */
extern "C++"
{
	template&lt;typename TYPE,	std::size_t SIZE&gt;
	std::size_t array_length(const TYPE(&)[SIZE]){
		return SIZE;
	}
#define _countof(_Array) array_length(_Array)
}
#endif  /* !defined (__cplusplus) */
#endif  /* !defined (_countof) */
template&lt;size_t SIZE&gt;
int max_of_arr(int (&amp;in_arr)[SIZE]){
    int re = 0;
    for(size_t i = 0; i < _countof(in_arr); i++){
        re = (re < in_arr[i])? in_arr[i] : re;
    }
    return re;
}
int main(void){
    static const int arr[] = {5, 7, 2, -6, 27463, -24724, 387472, 392};
    const int max = max_of_arr(arr);
    printf("max:%d\n");
    return 0;
}</pre>
        <p>ちなみに19行目はこれと同値です。</p>
        <pre class="brush: cpp; first-line: 19;" title="Range-base for無使用2">   {
        size_t i;
        for(i = 0; i < _countof(in_arr); i++){
            re = (re < in_arr[i])? in_arr[i] : re;
        }
    }</pre>
        <p>ですが配列の全要素に何かするたびに</p>
        <pre class="brush: cpp;">for(size_t i = 0; i < _countof(in_arr); i++)</pre>
        <p>と書くのは非常にめんdいですよね？めんdいことをすればするほどコーディングミスが増えます。C++11ではこれに対処するべく「Range-base for」という機能が追加されました。つまり</p>
        <pre class="brush: cpp; first-line: 19;" title="Range-base for使用">for(auto i : arr){
        re = (re < i)? i : re;
    }</pre>
        <p>と書けます。言うまでもないですが、iの型はint型になりますね、この場合。</p>
        <p>もちろんC++のコンテナにも使えます(というよりこっちがメイン)</p>
        <pre class="brush: cpp;" title="Range-base for無使用">std::vector&lt;int&gt; data{ 0, 1, 2, 3, 4 };//This usage is a thing of C++11.
int total = 0;
for(data_it = data.begin(); data_it != data.end(); data_it++) {
    total += *data_it; 
}</pre>
        <pre class="brush: cpp;" title="Range-base for使用">std::vector&lt;int&gt; data{ 0, 1, 2, 3, 4 };//This usage is a thing of C++11.
int total = 0;
for(auto i : data) {
    total += i; 
}</pre>
        <p>
            スッキリ。言うまでもなくiの型はint型です。なのでautoの代わりにintと書くこともできますが、いちいち型がなにか考えるのはめんdいですね。<br>
            ちなみにTarse Range-Based forというこの進化版がC++17に提案されていたんですが、採用されなかったっぽい。<br>
            Tarse Range-Based forがClangから取り除かれていた | 本の虫<br>
            <a href="http://cpplover.blogspot.jp/2014/12/tarse-range-based-forclang.html">http://cpplover.blogspot.jp/2014/12/tarse-range-based-forclang.html</a>
        </p>
        <p>Range-base forは内部的には上のRange-base for未使用の例と同様に読み替えられています。ということが分かるようにちょっと引用させてもらいましょう</p>
        <blockquote cite="http://cpplover.blogspot.jp/2009/08/n2930-range-based-for-loop.html">
            <p>
                n2930: Range-based for loopについて | 本の虫<br>
                <a href="http://cpplover.blogspot.jp/2009/08/n2930-range-based-for-loop.html">http://cpplover.blogspot.jp/2009/08/n2930-range-based-for-loop.html</a>
            </p>
            <p>Range-based forは以下のような構文になっている。 </p>
            <pre class="brush: cpp;">for ( for-range-declaration : expression ) statement</pre>
            <p>これは、コンパイラによって、以下のように変換される。</p>
            <pre class="brush: cpp;">{
    auto && __range = ( expression );
    for (auto __begin = begin-expr, __end = end-expr; __begin != __end; ++__begin ) {
       for-range-declaration = *__begin;
       statement
    }
}</pre>
        </blockquote>
        <p>
            実はこのRange-base forはconceptとADL(argument-dependent lookup)とunqualified lookup周りをめぐってそこそこ議論が有り、<br>
            解説サイトによって詳細が違ったりしますが、結局unqualified lookupは行われないことになったので、下記参考サイトを見るときは注意してください。
        </p>
        <ol>
            <li>
                <b>range-based forとstd名前空間 - にゃははー</b><br>
                <a href="http://flast.hateblo.jp/entry/2014/08/28/235657">http://flast.hateblo.jp/entry/2014/08/28/235657</a>
            </li>
            <li>
                <b>1442. Argument-dependent lookup in the range-based for | C++ Standard Core Language Defect Reports and Accepted Issues</b><br>
                <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1442">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1442</a>
            </li>
            <li>
                Range-based for loop  (since C++11) - cppreference.com<br>
                <a href="http://en.cppreference.com/w/cpp/language/range-for">http://en.cppreference.com/w/cpp/language/range-for</a>
            </li>
            <li>
                Range-based for Statement (C++) | MSDN<br>
                <a href="https://msdn.microsoft.com/en-US/library/jj203382.aspx">https://msdn.microsoft.com/en-US/library/jj203382.aspx</a>
            </li>
            <li>
                range-based forで固定回ループ | 本の虫<br>
                <a href="http://cpplover.blogspot.jp/2015/02/range-based-for.html">http://cpplover.blogspot.jp/2015/02/range-based-for.html</a>
            </li>
            <li>
                <b>Learning C++: range based for</b><br>
                <a href="http://cxx11.blogspot.jp/2012/01/range-based-for.html">http://cxx11.blogspot.jp/2012/01/range-based-for.html</a>
            </li>
            <li>
                C++ - 任意のメンバ関数でrange-based-forをする - Qiita<br>
                <a href="http://qiita.com/ikaro1192/items/c212bc258bcc729b4a17">http://qiita.com/ikaro1192/items/c212bc258bcc729b4a17</a>
            </li>
            <li>
                <b>range-based forに対する意見求む | 本の虫</b><br>
                <a href="http://cpplover.blogspot.jp/2011/02/range-based-for.html">http://cpplover.blogspot.jp/2011/02/range-based-for.html</a>
            </li>
            <li>
                <b>2011-02-27 これはC++ですか？ 第２話「いえ、まだドラフトです」 | range-based for - 野良C++erの雑記帳</b><br>
                <a href="http://d.hatena.ne.jp/gintenlabo/20110227/1298816842">http://d.hatena.ne.jp/gintenlabo/20110227/1298816842</a>
            </li>
            <li>
                n2930: Range-based for loopについて | 本の虫<br>
                <a href="http://cpplover.blogspot.jp/2009/08/n2930-range-based-for-loop.html">http://cpplover.blogspot.jp/2009/08/n2930-range-based-for-loop.html</a>
            </li>
            <li>
                n2930: Range-Based For Loop Wording (Without Concepts)<br>
                <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html</a>
            </li>
        </ol>
        <p>
            まとめると、Range-base forが使えるのは<b>配列(sizeof等で配列の要素数を求められるもの)かメンバー関数begin,endを持つクラスに</b>のいずれかということになります。<br>
            (実はADLが絡むからもっと複雑だがADLなんて覚えないほうがいい、参考サイト参照のこと)
        </p>
        <article>
            <h3>問題</h3>
            <p>下記のコードは2次元配列の総和を求めるコードだが(オーバーフロー対策は省略)、誤りがある。誤りを指摘せよ。</p>
            <pre class="brush: cpp;">#include &lt;stdio.h&gt;
int main(void){
    uint16_t arr[][7] = { {5, 7, 34, 6535, 332, 4, 8}, {3, 56, 23, 756, 76, 103, 5}, {34, 2, 44, 4, 7, 9, 10} };
    uint32_t sum = 0;
    for(auto j : arr){
        for(auto i : j){
            sum += i;
        }
    }
    return 0;
}</pre>
            <section>
                <h4>回答</h4>
                <p>
                    何度でも言いますが、<br>
                    <b>「配列はsizeof演算子と&演算子(アドレス演算子)のオペランドと配列初期化時の文字列リテラルと(lvalue)参照に代入するときを除き常にポインターに読み替えられる」</b><br>
                    のでした。つまり変数jの型はuint16_t*型です。もう一度言います、uint16_t*型です。断じてuint16_t[7]型ではありません<br>
                    Range-base forは配列(sizeof等で配列の要素数を求められるもの)かメンバー関数begin,endを持つクラスに適応できるのでした。<br>
                    そうです、ポインター型じゃなくて配列に適応出来るのです。ところが変数jの型はuint16_t*型。<b>あなた、それ配列じゃないですよ？</b><br>
                    対処策ですが、参照で一度受ければ配列として認識できます（配列の参照も、配列も、sizeof等で配列の要素数を求められるのでこの場合同じこと）。<br>
                    つまり5行目はこう書き換える必要があります。
                </p>
                <pre class="brush: cpp; first-line: 5;">    for(auto&amp; j : arr){</pre>
                <p>念のため確認しますが、この時のjの型はuint16_t(&)[7]型となっています。ほら、_countofマクロで配列の要素数を求められるでしょ？</p>
            </section>
        </article>
    </section>
    <section>
        <h2>C言語で乱数生成を頑張る人の奮闘</h2>
        <p>
            プログラミングにおいて、乱数の生成はゲームや暗号化などの場面で非常に多用されます。<br>
            しかし、C言語ではまともな乱数を作り出すのは困難です。素直にSFMTみたいな外部ライブラリや(DxLibraryも内部ではこれを使っています)、C++の乱数生成を使うべきです。<br>
            しかし、SFMTは変数名や型名の競合があり、かと言ってC++の乱数生成はやや煩雑な手順を必要とし、C標準ライブラリ―の乱数生成法のような手軽さはC++17を待つ必要があります。<br>
            というわけで乱数生成をやっていきましょう。
        </p>
        <section>
            <h3>コンピューター乱数概論</h3>
            <p>一口に「乱数」といっても2種類が有ります。</p>
            <dl>
                <dt>真の乱数</dt>
                <dd>
                    予測が困難な乱雑性のある数字。一般に生成には時間がかかったり、別途ハードウェアが必要になったりします。<br>
                    ex.)時刻、CPUの温度、GPUの温度、マウスポインタの座標、プロセスID、main関数の引数のアドレス、起動中のプロセス数、環境光の照度、CPU周辺のノイズ量、ユーザーが入力する任意の数、ラジウムの崩壊数
                </dd>
                <dt>擬似乱数</dt>
                <dd>
                    ある種のアルゴリズム(計算式)にseed値を与えることにより、高速に数字をつくりだす。<br>
                    一般に擬似乱数の評価基準は、生成速度、生成の分布の一様性、周期、全数探索可能性などになります。
                </dd>
            </dl>
            <p>どんな方法を使うにせよ、必ず真の乱数をseed値として擬似乱数生成アルゴリズムを使い擬似乱数を作ることになります。よって以下、seed値を作るということと、擬似乱数を生成することを明確に区別して読み進めてください</p>
        </section>
        <section>
            <h3>ありきたりなC言語的乱数生成</h3>
            <p>まずは大抵の参考書に乗っているごくごくありきたりなソースコードを載せます。さして精度を求めなかったり、同じ数が連続して出ても良い場合はこれで十分だったりします。</p>
            <pre class="brush: cpp;">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
int main(void){
	unsigned int i,j;
	/* 乱数系列の変更 */
	srand(static_cast&lt;unsigned int&gt;(time(nullptr)));
	/* 1～100の擬似乱数を10個ずつ10行発生 */
	for (i = 1; i <= 10; i++) {
		for (j = 0; j < 10; j++) {
			printf("%3d ", rand() % 100 + 1);
		}
		putchar('\n');
	}
	return 0;
}</pre>
            <p>seed値は現在時刻を求めるtime関数を利用し、擬似乱数生成にはC標準ライブラリ―のrand関数を利用しています。rand関数にseedを渡すにはsrand関数を使用します。</p>
            <p>上記の例では、乱数を任意の範囲に加工するのに余りを求める計算を利用していますが、これは余り賢いやり方ではありません。なのでこんな風にすれば使いやすい・・・のかな？</p>
            <pre class="brush: cpp;">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
unsigned int gen_uirand(unsigned int max, unsigned int min){
	return min + (rand() * (max-min+1.0) / (1.0 + RAND_MAX));
}
int main(void){
	unsigned int i,j;
	/* 乱数系列の変更 */
	srand(static_cast&lt;unsigned int&gt;(time(nullptr)));
	/* 1～100の擬似乱数を10個ずつ10行発生 */
	for (i = 1; i <= 10; i++) {
		for (j = 0; j < 10; j++) {
			printf("%3d ", gen_uirand(100, 1));
		}
		putchar('\n');
	}
	return 0;
}</pre>
        </section>
        <section>
            <h3>擬似乱数の生成を改善する</h3>
            <p>
                ところでC標準ライブラリーのrand関数はとても便利なのですが、あまりまともな擬似乱数を作ってくれません。<br>
                擬似乱数はちょうど大きなリング上の数字が順に吐き出されるように周期が有りますが、この周期もあまり良くありません。<br>
                さらにMSVCみたいにいまだにRAND_MAX(生成される乱数の最大値)が15bit変数と同じ、なんていう処理系も有ります。<br>
                そこでもう少し頭のいい方法を使ってみましょう。<br>
                ３月１４日（水）　疑似乱数の話 | Diary 2012-3 | まるも<br>
                <a href="http://www.marumo.ne.jp/db2012_3.htm#14">http://www.marumo.ne.jp/db2012_3.htm#14</a><br>
                よりパク・・・げふんげふん、引用します。
            </p>
            <pre class="brush: cpp;">unsigned int libc_rand_32_normal()
{
	unsigned int r = 0;
	r  = ((rand() >> 3) & 0x0fff)      ; // 12 bit
	r |= ((rand() >> 4) & 0x07ff) << 12; // 12+11 : 23 bit
	r |= ((rand() >> 6) & 0x01ff) << 23; // 12+11+9 : 32 bit
	return r;
}</pre>
            <p>参考サイトの記述によれば周期は 0x80000000 (2,147,483,648)なのだそうです(どうやっても参考サイトのコードが動かないorz)。</p>
            <p>まあこれの場合seedを変えても開始点が変わるだけで同じ所をグルグル回るというおまけ付きなんですが。</p>
        </section>
        <section>
            <h3>seed値の生成を改善する(OS非依存)</h3>
            <p>先の関数ではseed値に、time関数の戻り値を利用しましたが、こいつ1秒に1回しか変わりません。また、時刻はある程度予測可能なため真の乱数とは言いがたいです。</p>
            <p>まずはOS非依存な範囲で何とかしてみましょう。こんな感じ・・・？</p>
            <pre class="brush: cpp;">unsigned int create_seed(int argc, char* argv[], uint32_t num){
	char* dst = (char*)malloc(sizeof(char) * 2);
	unsigned int seed = ((uint64_t)argv + (uint64_t)&argc + (uint32_t)time(NULL) + clock() + libc_rand_32_normal() + ((uint32_t)dst * (uint32_t)((rand() & 0xff) << 16) * (uint32_t)&dst)) % UINT_MAX;
	free(dst);
	return seed;
}</pre>
            <p>
                main関数の引数のアドレスは最近のOSなら大体ランダムになるようなので十分使えます。また、ヒープ領域にメモリーを確保するmalloc関数もそのアドレスはある程度ランダムに選ばれると言っていいでしょう。<br>
                擬似乱数生成器自身もseed値を予測しにくくするのに役立つでしょう。初回呼び出し前になんでもいいのでsrandしないといけなくなりますが。<br>
                PC起動時からの経過tick数を返すclock関数はほぼ必ず呼び出しごとに値が変わると言えるのでseedには持ってこいです。
            </p>
        </section>
        <section>
            <h3>seed値の生成を改善する(WindowsとLinux)</h3>
            <p>
                実行ファイルを実行するとたいていはOSが管理するためにそれぞれにプロセスID(pid)が割り当てられます。こいつもseedに使えそうです。<br>
                Windowsではwin32apiのGetCurrentProcessId関数を使用します。Linuxでは・・・きっとあるでしょう。
            </p>
            <p>
                また、マウスポインタの位置は完全に予測不能ですのでseedにもってこいです。<br>
                WindowsではGetCursorPos関数を使用します。Linuxは、そもそもGUIの作り方がわからん。まあQtとかXWindowとか大抵のGUIフレームワークでそれっぽい関数があるでしょう。<br>
                <a href="http://doc.qt.io/qt-5/qcontextmenuevent.html#globalPos">http://doc.qt.io/qt-5/qcontextmenuevent.html#globalPos</a><br>
                Qtではこれ使うっぽい。さっぱり使い方がわからんけど。
            </p>
            <p>とまぁ、こういう感じになる・・・のかな？</p>
            <pre class="brush: cpp;">unsigned int create_seed(int argc, char* argv[], uint32_t num){
	POINT point;
	GetCursorPos(&point);
	char* dst = (char*)malloc(sizeof(char) * 2);
	unsigned int seed = ((uint64_t)argv + (uint64_t)&argc + (num * (uint64_t)(point.x + point.y)) + (uint64_t)GetCurrentProcessId() 
        + (uint32_t)time(NULL) + clock() + libc_rand_32_normal() + ((uint32_t)dst * (uint32_t)((rand() & 0xff) << 16) * (uint32_t)&dst) + 3457450835) % UINT_MAX;
	free(dst);
	return seed;
}</pre>
            <p>せっかくなのでこれを利用してなんか動くものを作る。</p>
            <script src="http://ideone.com/e.js/1wxKrF" type="text/javascript"></script>
        </section>
        <section>
            <h3>そもそも乱数のseed作成にはIntelCPUのRDRAND命令やRDSEED命令が使える</h3>
            <p>
                さきほどseedを作る方法を紹介しましたが、Intel Core i シリーズ第3世代からはRDRAND命令、第5世代からはRDSEED命令という乱数生成命令が追加されました。<br>
                こいつはハードウェア乱数生成器で擬似乱数生成程ではないにしろ、比較的高速にほとんど真の乱数と呼べる数値を作ってくれます。<br>
                なのでこいつをseedに使ってやればいいです。またさほど生成が遅くないので(200tick程度？)これ自体を乱数として採用するのもありです。
            </p>
            <p>
                実際にRDRAND命令を乱数として採用したのがこちらのプロジェクトです。DLして試してみてください。<br>
                Using Intel’s Secure Key (RDRAND) in MS Visual C++ 2013 | GiuHub<br>
                <a href="https://github.com/yumetodo/rdrand_msvc_2010">https://github.com/yumetodo/rdrand_msvc_2010</a><br>
            </p>
            <pre class="brush: plain;">git clone https://github.com/yumetodo/rdrand_msvc_2010.git</pre>
            <p><a href="https://github.com/yumetodo/rdrand_msvc_2010/blob/master/README.md">readme</a>に書いているように、わざわざアセンブリを書かなくても</p>
            <pre class="brush: cpp;">static bool RDRAND(void) { return CPU_Rep.f_1_ECX_[30]; }
extern int __cdecl _rdrand16_step(unsigned short *);
extern int __cdecl _rdrand32_step(unsigned int *);
#if defined (_M_X64)
extern int __cdecl _rdrand64_step(unsigned __int64 *);
#endif  /* defined (_M_X64) */</pre>
            <p>これらの関数群が使えるんですけどね。</p>
        </section>
        <section>
            <h3>そもそもwin32apiに乱数生成関数がある</h3>
            <p>
                MSVCにはrand_sという関数が有り、勝手に適当なseedを与えて擬似乱数を作ってくれる関数があります。<br>
                こいつは内部で「RtlGenRandom API」というWindowsXP以降に対応しているAPIを叩いています。
            </p>
            <pre class="brush: cpp;">errno_t rand_s(unsigned int* randomValue);</pre>
            <p><a href="https://msdn.microsoft.com/ja-jp/library/sxtz2fa8.aspx">rand_s | MSDN</a></p>
            <p>乱数の精度にさほどこだわらない時はこれを使うといいです。少なくともrand関数よりはずっと優秀です。</p>
        </section>
    </section>
    <section>
        <h2>C++11 or laterで乱数生成</h2>
        <p>いろいろと工夫してCのrand関数を使用してきましたが、やはり限界があります。</p>
        <ul>
            <li>rand() % N は一様では無い</li>
            <li>乱数生成アルゴリズムが固定（通常は線形合同法）</li>
            <li>正規分布など、一様でない乱数生成が面倒</li>
            <li>seedを作る方法がOS依存になったりCPU依存になったりする</li>
        </ul>
        <p>とまあ、C++っぽく作りましょうか。細けーことは後だ。</p>
        <pre class="brush: cpp;">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;random&gt;
nth_loop operator "" _( unsigned long long int n ){
	return nth_loop( n ) ;
}
int main(){
	// ランダムデバイス
	std::random_device rnd ;
	// 初期化用ベクタ
	std::vector< std::uint_least32_t> v(10) ;
	// ベクタの初期化
	std::generate( v.begin(), v.end(), std::ref(rnd) ) ;
	
	// 乱数エンジン
	std::mt19937 engine( std::seed_seq( v.begin(), v.end() ) ) ;
	// distribution
	std::uniform_real_distribution&amp;&lt;double&gt; distribution(0.0, 1.0) ;
	
	for (auto i : 10_)
		std::cout << distribution(engine) << std::endl ;
}</pre>
        <p>
            ちゃっかり前回のRange-base forと参考リンクに上げた固定回ループの書き方を使っています。だって「C++っぽく作りましょうか」って言ったでしょ。<br>
            演算子のオーバーロードなんて習ってないだって？あー聞こえない聞こえない。<br>
            ・・・と言うわけにもいかないので簡単に補足。「operator "" _」と「auto i : 10_」に着目してください。あとは「演算子のオーバーロード」でググればいいと思うよ。
        </p>
        <p>
            話がそれました。random_device rndってのが真の乱数を作るやつで、作ったのを保管するのが変数v、seedを真の乱数から作るのがgenerateで、<br>
            srandにあたるseedを与えるのが16行目です。<br>
            uniform_real_distributionってのはできた乱数を指定した型で指定した範囲に加工するやつですのでなくてもいいですが・・・あったほうが楽やんね。
        </p>
    </section>
</body>
</html>
