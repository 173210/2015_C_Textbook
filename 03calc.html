<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>第3章 ～四則演算～</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/sanitize.css/2.0.0/sanitize.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <script src="./syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushPlain.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushCpp_kai.js" type="text/javascript"></script>
    <link href="./syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css">
    <link href="./syntaxhighlighter/styles/shThemeMidnight_likeVS.css" rel="stylesheet" type="text/css">
    <script src="./scripts/common.js" type="text/javascript"></script>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <h1>第3章 ～四則演算～</h1>
    <nav class="top">
        <ul>
            <li><a href="./02variable.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./04bit.html" title="次頁">next</a></li>
        </ul>
    </nav>
    <section>
        <h2>四則演算</h2>
        <p>やっぱり計算出来ないとプログラミングは始まりません。というわけでまずは四則演算。</p>
        <pre class="brush: cpp;">int i = 0, delay_time;
//中略
i = i + 1;
double time = 8.5 - 2.1;
double cure = 1.5 * time;
double damage = cure / 10;
unsigned int temp1 = delay_time / 60;
tm_sec += delay_time % 60;
i += 1;
cure -= 10;
i++;
++i;
i--;
--i;</pre>
        <p>3行目から7行目が四則演算ですね。6行目の割り算は整数精度で行われ、小数点以下は0に近い方向に切り捨てられることを忘れないで下さい。</p>
        <p>8行目は割り算の余りを求めるものです。これは整数精度の時のみ使えます。もし浮動小数点型で割り算のあまりを求めたいときは、math.hのfmod関数を使いましょう。</p>
        <p>9行目は2行目の略記です。10行目のように引き算などほかの演算記号も同じように使えます。</p>
        <p>11行目と12行目はインクリメント演算子、13行目と14行目はデクリメント演算子と呼ばれます。1増やしたり1減らしたりする処理を簡便に書くことができます。</p>
        <table>
            <tr> <th>演算</th><th>演算子</th><th>例</th><th>意味</th> </tr>
            <tr> <td rowspan="2">インクリメント</td><td rowspan="2" class="Cent">++</td><td>a++</td><td>a に 1 を加える（後置演算）</td> </tr>
            <tr> <td>++a</td><td>a に 1 を加える（前置演算）</td> </tr>
            <tr> <td rowspan="2">デクリメント</td><td rowspan="2" class="Cent">--</td><td>a--</td><td>a から 1 を引く（後置演算）</td> </tr>
            <tr> <td>--a</td><td>a から 1 を引く（前置演算）</td> </tr>
        </table>
        <p>使用上の注意です。下のコードを見てくだい。</p>
        <script src="http://gist-it.appspot.com/github/yumetodo/2015_C_Textbook/blob/gh-pages/src/increment_decrement.c"></script>
        <p>インクリメント・デクリメント演算子は前置と後置で意味が変わるので注意です。私は覚えるのがめんdいので、後置しか使わない派です。</p>
    </section>

    <section>
        <h2>暗黙の型変換とキャスト</h2>
        <p>ここまでの例ではすべて計算するものの型は揃っていました。では違う場合はどうなるでしょう？</p>
        <pre class="brush: cpp;">const int a = 10;
const double b = 3;
auto ans = a / b;
int ans2 = ans;
auto ans3 = (int)ans;</pre>
        <p>変数ansの型はdouble、ansには3.3333333(以下略)が入ります。</p>
        <p>一方でans2の型はint、ans2には3が入ります。</p>
        <p>また3行目のように型を明示することもできます。これを「キャスト」といいます。ans3の型はint型になります。</p>
        <dl>
            <dt>式の中で行われる変換</dt>
            <dd>
                優先順位の高い型に変換されます。優先順位は<br>
                <q>bool &lt; char &lt; short &lt; int &lt; long &lt; long long &lt; float &lt; double</q><br>
                です。
            </dd>
            <dt>代入時の変換</dt>
            <dd>左辺の型と右辺の型が異なっている場合は、左辺の型に変換します。</dd>
            <dt>キャスト時の変換</dt>
            <dd>有無をいわさずに指定した型に変換されます。</dd>
        </dl>
        <p>
            この法則にしたがって解釈すると、3行目は、aの型はint、bの型はdoubleなのでaがdouble型に変換され(式の中で行われる変換)、double型同士の計算となります。<br>
            また4行目は変数ansの型はdoubleですが、左辺のans2の型がintなのでint型に変換されます(代入時の変換)。
        </p>
        <p>このことを利用して割り算の余り(surplus)を求めてみましょう。</p>
        <pre class="brush: cpp;">const double input = 23;
const int divisor = 7;
const int temp = (int)input / divisor;
const double surplus = input - (divisor * temp);</pre>
        <p>inputをキャストする必要があるのか？と怒られそうですが、べつに整数精度の結果で事足るのでキャストしました。</p>
        <p>よくキャストを「ある型とみなす」と説明する人が居ますが、誤りです。bitの並びが変わることもあることからわかるように、実際に変換されます。</p>
        <section class="technique">
            <h3>コーディングの作法</h3>
            <p>C言語のキャストは、非常に強力で、どんな型にでも変換ができます。ゆえにしてはいけない型変換もできてしまいます。</p>
            <p>そこでC++ではキャストが4種類にわかれました。</p>
            <table>
                <tbody>
                    <tr><th> 名称 </th><th> 説明 </th><th> 使用 </th></tr>
                    <tr><td>dynamic_cast</td><td> 基本クラスから派生クラスへのキャスト</td><td>使用するべきではない</td></tr>
                    <tr><td>const_cast</td><td> const を外すキャスト</td><td>使用するべきではない</td></tr>
                    <tr><td>static_cast</td><td> double から int など暗黙の変換のあるキャスト </td><td>使用可</td></tr>
                    <tr><td>reinterpret_cast</td><td> double * から long long などの無理やりキャスト </td><td>なるべく使用しない</td></tr>
                </tbody>
            </table>
            <p>
                詳細な説明は<br>
                キャスト | プログラマーズ雑記帳<br>
                <a href="http://yohshiy.blog.fc2.com/blog-category-9.html">http://yohshiy.blog.fc2.com/blog-category-9.html</a><br>
                に譲りますが、Cのキャストは理由がない限り使わず、C++のstatic_castを使用しましょう。キャストしないに越したことはありませんが、
            </p>
            <p class="strong">static_castならかなり安全に使用できます。Cのキャストは使うな。</p>
            <pre class="brush: cpp;">const int temp = static_cast&lt;int&gt;(input) / divisor;</pre>
            <p>
                もっとも、まともなコーディングをしていれば、malloc,calloc,realloc関数以外でキャストを使う場面はないはずです。<br>
                もしあなたがキャストを使おうとしているならば、それはあなたが寝ぼけているのか、ライブラリ作者がうっかりしている、ということになります。<br>
                後者なら、作者に文句を言いましょう。(実際私はDxLibraryの作者に色の扱いについて文句を言って、Ver 3.13eで修正してもらいました)
            </p>
            <p>signedとunsignedの変換はとくに理由のない限りしないようにしましょう。</p>
        </section>
        <article>
            <h3>問題</h3>
            <p>
                画像処理、映像処理の分野において、色を表すのにRGB系のほかにYUV系、YCbCr系、Y'PbPr系などがある。<br>
                RGB座標系からYCbCr系への変換にはBT.601 (ITU-R BT.601-7 より) という規格があり、
                RGB座標系からY'PbPr系への変換にはBT.709 (ITU-R BT.709-5 より) という規格がある。
                変換行列は以下のとおりである。
            </p>
            <img src="./pic/bt601_bt709.png">
            <p>BT.709の式に従いY'を求めるプログラムが以下に示すものである。完成させよ。</p>
            <pre class="brush: cpp;">#include &lt;cstdio&gt;
#include &lt;cstdint&gt;
typedef uint8_t color_e_t;
int main(void){
    const color_e_t r = 137;
    const color_e_t g = 195;
    const color_e_t b = 235;

    const color_e_t y = static_cast&lt;color_e_t&gt;(  );

    printf("R:%d G:%d B:%d -> Y':%d\n", r, g, b, y);
    return 0;
}</pre>
            <form><input type="button" value="表示/非表示" onclick="change_answer_state('answer1')"></form>
            <section id="answer1" style="display: none;">
                <h4>回答</h4>
                <p>9行目のみ。</p>
                <pre class="brush: cpp;">const color_e_t y = static_cast&lt;color_e_t&gt;(0.2126* r +  0.7152 * g + 0.0722 * b)</pre>
            </section>
        </article>
    </section>

    <section>
        <h2>promotionsとconversions</h2>
        <p>型変換、と一口に言っても2つあり、promotionsとconversionsとそれぞれ呼ばれます。</p>
        <p>
            promotionsがなにか、については<br>
            C++11の文法と機能(C++11: Syntax and Feature)<br>
            <a href="http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#conv.prom">http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#conv.prom</a><br>
            に丸投げするとして、promotionsでなければconversionsである(そりゃそーだ)。
        </p>
        <p>conversionsは一般に危険をはらんでいます。何故かというと、変換元の数値を変換先の型で表せないかもしれないからです。</p>
        <p>unsigned charが8ビット、unsigned intが16ビットと仮定して実例を上げてみましょう。</p>
        <pre class="brush: cpp;">int main(void){
    unsigned int ui = 1234 ;
    unsigned char uc = ui ; // 210
}</pre>
        <p>この場合、unsigned int型は、16ビット、uiの値は、2進数で表すと0000010011010010になります。unsigned char型は8ビット。つまり、この場合の対応する下位桁の値は、2進数で11010010（uiの下位8ビット）です。よって、ucは、10進数で210となります。 </p>
        <p>しかし、そもそも型変換でオーバーフローやアンダーフローを起こさないようにコーディングするべきでしょう。</p>
    </section>
    <nav class="bottom">
        <ul>
            <li><a href="./02variable.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./04bit.html" title="次頁">next</a></li>
        </ul>
    </nav>
</body>
</html>