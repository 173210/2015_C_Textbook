<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>第16章 ～Range-base for～</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/sanitize.css/2.0.0/sanitize.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <script src="./syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushPlain.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushCpp_kai.js" type="text/javascript"></script>
    <link href="./syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css">
    <link href="./syntaxhighlighter/styles/shThemeMidnight_likeVS.css" rel="stylesheet" type="text/css">
    <script src="./scripts/common.js" type="text/javascript"></script>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <h1>第16章 ～Range-base for～</h1>
    <nav class="top">
        <ul>
            <li><a href="./15value.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./17rand-num.html" title="次頁">next</a></li>
        </ul>
    </nav>
    <section>
        <h2>改めましてfor文～Range-base for～</h2>
        <p>for文なら前にやっただろ、と思ったあなた、あれで説明が終わりだとほんとに思っていたのですか？</p>
        <p>復習ですがfor文とはこんなやつでした。</p>
        <pre class="brush: cpp;" title="Range-base for無使用1">#include &lt;stdio.h&gt;
#if !defined (_countof)
#if !defined (__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else  /* !defined (__cplusplus) */
extern "C++"
{
	template&lt;typename TYPE,	std::size_t SIZE&gt;
	std::size_t array_length(const TYPE(&amp;)[SIZE]){
		return SIZE;
	}
#define _countof(_Array) array_length(_Array)
}
#endif  /* !defined (__cplusplus) */
#endif  /* !defined (_countof) */
template&lt;size_t SIZE&gt;
int max_of_arr(int (&amp;in_arr)[SIZE]){
    int re = 0;
    for(size_t i = 0; i &lt; _countof(in_arr); i++){
        re = (re &lt; in_arr[i])? in_arr[i] : re;
    }
    return re;
}
int main(void){
    static const int arr[] = {5, 7, 2, -6, 27463, -24724, 387472, 392};
    const int max = max_of_arr(arr);
    printf("max:%d\n");
    return 0;
}</pre>
        <p>ちなみに19行目はこれと同値です。</p>
        <pre class="brush: cpp; first-line: 19;" title="Range-base for無使用2">   {
        size_t i;
        for(i = 0; i &lt; _countof(in_arr); i++){
            re = (re &lt; in_arr[i])? in_arr[i] : re;
        }
    }</pre>
        <p>ですが配列の全要素に何かするたびに</p>
        <pre class="brush: cpp;">for(size_t i = 0; i &lt; _countof(in_arr); i++)</pre>
        <p>と書くのは非常にめんdいですよね？めんdいことをすればするほどコーディングミスが増えます。C++11ではこれに対処するべく「Range-base for」という機能が追加されました。つまり</p>
        <pre class="brush: cpp; first-line: 19;" title="Range-base for使用">for(auto i : arr){
    re = (re &lt; i)? i : re;
}</pre>
        <p>と書けます。言うまでもないですが、iの型はint型になりますね、この場合。</p>
        <p>もちろんC++のコンテナにも使えます(というよりこっちがメイン)</p>
        <pre class="brush: cpp;" title="Range-base for無使用">std::vector&lt;int&gt; data{ 0, 1, 2, 3, 4 };//This usage is a thing of C++11.
int total = 0;
for(auto data_it = data.begin(); data_it != data.end(); data_it++) {
    total += *data_it; 
}</pre>
        <pre class="brush: cpp;" title="Range-base for使用">std::vector&lt;int&gt; data{ 0, 1, 2, 3, 4 };//This usage is a thing of C++11.
int total = 0;
for(auto i : data) {
    total += i; 
}</pre>
        <p>
            スッキリ。言うまでもなくiの型はint型です。なのでautoの代わりにintと書くこともできますが、いちいち型がなにか考えるのはめんdいですね。
        </p>
    </section>
    <section>
        <h2>Range-based forの内部構造</h2>
        <p>Range-base forは内部的には上のRange-base for未使用の例と同様に読み替えられています。どういうことが分かるようにちょっと引用させてもらいましょう</p>
        <blockquote cite="http://cpplover.blogspot.jp/2009/08/n2930-range-based-for-loop.html">
            <p>
                n2930: Range-based for loopについて | 本の虫<br>
                <a href="http://cpplover.blogspot.jp/2009/08/n2930-range-based-for-loop.html">http://cpplover.blogspot.jp/2009/08/n2930-range-based-for-loop.html</a>
            </p>
            <p>Range-based forは以下のような構文になっている。 </p>
            <pre class="brush: cpp;">for ( for-range-declaration : expression ) statement</pre>
            <p>これは、コンパイラによって、以下のように変換される。</p>
            <pre class="brush: cpp; highlight: [4]">{
    auto &amp;&amp; __range = ( expression );
    for (auto __begin = begin-expr, __end = end-expr; __begin != __end; ++__begin ) {
       for-range-declaration = *__begin;
       statement
    }
}</pre>
        </blockquote>
        <blockquote>
            <p>
                Learning C++: range based for <br>
                <a href="http://cxx11.blogspot.jp/2012/01/range-based-for.html">http://cxx11.blogspot.jp/2012/01/range-based-for.html</a>
            </p>
            <p>リストのすべての要素を捜査するときには、for文を次のように記述します。</p>
            <pre class="brush: cpp;">// 配列の場合
int array[] = {1, 2, 3, 4};
for (int val : array) {
  std::cout &lt;&lt; val &lt;&lt; std::endl;
}
// 配列以外の場合
std:vector&lt;int> vec = {1, 2, 3, 4};
for (int val : vec) {
  std::cout &lt;&lt; val &lt;&lt; std::endl;
}</pre>
            <p>range based forは、配列と配列以外の場合それぞれ次のように展開され処理されます。</p>
            <pre class="brush: cpp; highlight: [10]">// 配列の場合
int array[] = {1, 2, 3, 4};
for (int i = 0; i &lt; sizeof(array) / sizeof(decltype(*array)); ++i) {
  auto val = *(array + i);
  std::cout &lt;&lt; val &lt;&lt; std::endl;
}
// 配列以外の場合
std:vector&lt;int> vec = {1, 2, 3, 4};
for (auto i = begin(vec); i != end(vec); ++i) {
  auto val = *i;
  std::cout &lt;&lt; val &lt;&lt; std::endl;
}</pre>
        </blockquote>
    </section>
    <section>
        <h2>for-range-declarationの考察</h2>
        <p>
            for-range-declarationの部分の型指定ですが、もちろんintやdoubleなど自分で書いてもいいのですが、<br>
            <b>殆どの場合型推論させます</b><br>
            というわけで幾つかパターンを見て行きましょう。
        </p>
        <section>
            <h3>auto&amp;&amp;</h3>
            <p>
                rvalue referenceで受ける場合ですね。<b>ほぼ例外なくこれ書いておけば間違いないです。</b><br>
                何故かと言うと、本の虫の引用部分で言うbegin-exprの部分はコンテナのbeginメンバー関数が呼ばれるのですが、これで得られるイテレータのoperator*が、std::vector&lt;bool>に代表されるようにrvalueを返す場合があって、これはauto&amp;&amp;かautoでしか受けられないのです。<br>
                かと言ってautoで受けると殆どの場合でコピーされてしまいます。なのでこれの出番です。
            </p>
            <pre class="brush: cpp;">#include &lt;iostream>
#include &lt;vector>
#include &lt;array>
#include &lt;utility>
#include &lt;string>
int main(){
    std::vector&lt;std::pair&lt;std::string, std::array&lt;int, 4>>> data;
    //中略
    for(auto&amp;&amp; i : data){
        std::cout &lt;&lt; i.first;
        for(auto&amp;&amp; j : i.second) std::cout &lt;&lt; j &lt;&lt; ", ";
        std::cout &lt;&lt; std::endl;
    }
    return 0;
}</pre>
            <p>
                ちなみにTarse Range-Based forというこの進化版がC++17に提案されていたんですが、採用されなかったっぽい。<br>
                Tarse Range-Based forがClangから取り除かれていた | 本の虫<br>
                <a href="http://cpplover.blogspot.jp/2014/12/tarse-range-based-forclang.html">http://cpplover.blogspot.jp/2014/12/tarse-range-based-forclang.html</a><br>
                なのになぜかVisual Studio 2015 RCではサポートのアナウンス。どうしたんだ、MIcrosoft。<br>
                Visual Studio 2015 RC | Release Notes<br>
                <a href="https://www.visualstudio.com/en-us/news/vs2015-vs.aspx#C++">https://www.visualstudio.com/en-us/news/vs2015-vs.aspx#C++</a>
            </p>
        </section>
        <section>
            <h3>const auto&amp;</h3>
            <p>const lvalue referenceで受ける場合ですね。変更しないぞアピールをするときに。ただし前述のとおりrvalueを受けられないという問題があります。</p>
        </section>
        <section>
            <h3>auto&amp;</h3>
            <p>前述のような問題はありますが、一文字type数が少ないので使うことも。</p>
        </section>
        <section>
            <h3>auto</h3>
            <p>基本型(int, doubleとかとか)などコピーのコストが重くない場合はこれで良かったりします。</p>
        </section>
    </section>
    <section>
        <h3>リンクとか</h3>
        <p>
            実はこのRange-base forはconceptとADL(argument-dependent lookup)とunqualified lookup周りをめぐってそこそこ議論が有り、<br>
            解説サイトによって詳細が違ったりしますが、結局unqualified lookupは行われないことになったので、下記参考サイトを見るときは注意してください。
        </p>
        <ol>
            <li>
                <b>range-based forとstd名前空間 - にゃははー</b><br>
                <a href="http://flast.hateblo.jp/entry/2014/08/28/235657">http://flast.hateblo.jp/entry/2014/08/28/235657</a>
            </li>
            <li>
                <b>1442. Argument-dependent lookup in the range-based for | C++ Standard Core Language Defect Reports and Accepted Issues</b><br>
                <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1442">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1442</a>
            </li>
            <li>
                Range-based for loop  (since C++11) - cppreference.com<br>
                <a href="http://en.cppreference.com/w/cpp/language/range-for">http://en.cppreference.com/w/cpp/language/range-for</a>
            </li>
            <li>
                Range-based for Statement (C++) | MSDN<br>
                <a href="https://msdn.microsoft.com/en-US/library/jj203382.aspx">https://msdn.microsoft.com/en-US/library/jj203382.aspx</a>
            </li>
            <li>
                range-based forで固定回ループ | 本の虫<br>
                <a href="http://cpplover.blogspot.jp/2015/02/range-based-for.html">http://cpplover.blogspot.jp/2015/02/range-based-for.html</a>
            </li>
            <li>
                <b>Learning C++: range based for</b><br>
                <a href="http://cxx11.blogspot.jp/2012/01/range-based-for.html">http://cxx11.blogspot.jp/2012/01/range-based-for.html</a>
            </li>
            <li>
                C++ - 任意のメンバ関数でrange-based-forをする - Qiita<br>
                <a href="http://qiita.com/ikaro1192/items/c212bc258bcc729b4a17">http://qiita.com/ikaro1192/items/c212bc258bcc729b4a17</a>
            </li>
            <li>
                <b>C++ - range-based for loopsの要素の型について - Qiita</b><br>
                <a href="http://qiita.com/rinse_/items/cdfce8aa6a685a8ebe0c">http://qiita.com/rinse_/items/cdfce8aa6a685a8ebe0c</a>
            </li>
            <li>
                <b>range-based forに対する意見求む | 本の虫</b><br>
                <a href="http://cpplover.blogspot.jp/2011/02/range-based-for.html">http://cpplover.blogspot.jp/2011/02/range-based-for.html</a>
            </li>
            <li>
                <b>2011-02-27 これはC++ですか？ 第２話「いえ、まだドラフトです」 | range-based for - 野良C++erの雑記帳</b><br>
                <a href="http://d.hatena.ne.jp/gintenlabo/20110227/1298816842">http://d.hatena.ne.jp/gintenlabo/20110227/1298816842</a>
            </li>
            <li>
                n2930: Range-based for loopについて | 本の虫<br>
                <a href="http://cpplover.blogspot.jp/2009/08/n2930-range-based-for-loop.html">http://cpplover.blogspot.jp/2009/08/n2930-range-based-for-loop.html</a>
            </li>
            <li>
                n2930: Range-Based For Loop Wording (Without Concepts)<br>
                <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html</a>
            </li>
        </ol>
        <p>
            まとめると、Range-base forが使えるのは<b>配列(sizeof等で配列の要素数を求められるもの)かメンバー関数begin,endを持つクラスに</b>のいずれかということになります。<br>
            (実はADLが絡むからもっと複雑だがADLなんて覚えないほうがいい、参考サイト参照のこと)
        </p>
        <article>
            <h3>問題</h3>
            <p>下記のコードは2次元配列の総和を求めるコードだが(オーバーフロー対策は省略)、誤りがある。誤りを指摘せよ。</p>
            <pre class="brush: cpp;">#include &lt;stdio.h&gt;
int main(void){
    uint16_t arr[][7] = { {5, 7, 34, 6535, 332, 4, 8}, {3, 56, 23, 756, 76, 103, 5}, {34, 2, 44, 4, 7, 9, 10} };
    uint32_t sum = 0;
    for(auto j : arr){
        for(auto i : j){
            sum += i;
        }
    }
    return 0;
}</pre>
            <form><input type="button" value="表示/非表示" onclick="change_answer_state('answer1-1')"></form>
            <section id="answer1-1" style="display: none;">
                <h4>回答</h4>
                <p>
                    何度でも言いますが、<br>
                    <b>「配列はsizeof演算子と&amp;演算子(アドレス演算子)のオペランドと配列初期化時の文字列リテラルと(lvalue)参照に代入するときを除き常にポインタに読み替えられる」</b><br>
                    のでした。つまり変数jの型はuint16_t*型です。もう一度言います、uint16_t*型です。断じてuint16_t[7]型ではありません<br>
                    Range-base forは配列(sizeof等で配列の要素数を求められるもの)かメンバー関数begin,endを持つクラスに適応できるのでした。<br>
                    そうです、ポインタ型じゃなくて配列に適応出来るのです。ところが変数jの型はuint16_t*型。<b>あなた、それ配列じゃないですよ？</b><br>
                    対処策ですが、参照で一度受ければ配列として認識できます（配列の参照も、配列も、sizeof等で配列の要素数を求められるのでこの場合同じこと）。<br>
                    つまり5行目はこう書き換える必要があります。
                </p>
                <pre class="brush: cpp; first-line: 5;">    for(auto&amp; j : arr){</pre>
                <p>念のため確認しますが、この時のjの型はuint16_t(&amp;)[7]型となっています。ほら、_countofマクロで配列の要素数を求められるでしょ？</p>
            </section>
        </article>
    </section>
    <nav class="bottom">
        <ul>
            <li><a href="./15value.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./17rand-num.html" title="次頁">next</a></li>
        </ul>
    </nav>
</body>
</html>