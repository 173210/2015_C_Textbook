<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>第20章 ～関数の再帰と関数ポインタ～</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/sanitize.css/2.0.0/sanitize.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <script src="./syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushPlain.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushCpp_kai.js" type="text/javascript"></script>
    <link href="./syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css">
    <link href="./syntaxhighlighter/styles/shThemeMidnight_likeVS.css" rel="stylesheet" type="text/css">
    <script src="./scripts/common.js" type="text/javascript"></script>
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <h1>第20章 ～関数の再帰と関数ポインタ～</h1>
    <nav class="top">
        <ul>
            <li><a href="./19str_manipulate.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./21std_string.html" title="次頁">next</a></li>
        </ul>
    </nav>
    <section>
        <h2>関数の再帰</h2>
        <p>
            はっきりいって名前のまんまです。ある関数の中でその関数自体を呼ぶことを言います。関数型プログラミングではループの代わりに使われるごくごくありきたりな手法です。<br>
            C/C++においてはコンパイラがまだそこまで賢くないので、末尾最適化とかいう、コンパイラにやさしい書き方をしないとループより遅くなる傾向にあります。<br>
            C++ではmain関数だけは再帰できません。ご注意あれ。<br>
            C++11ではconstexpr関数内でループは書けなかったので、再帰する必要がありました。C++14ではその必要はありませんが。<br>
            再帰の面倒なのは、速度を求めるときは再帰深度を考慮したりしないといけないということです(深すぎるとループとみなされず速度が大幅に下がる) <br>
            なので普段は素直にループを書けばいいと思いますが、エラー時処理は再帰を使うとうまくかけることが多いですね。
        </p>
        <pre class="brush: cpp;">#include &lt;iostream>
#include &lt;exception>
#include &lt;stdexcept>
#include &lt;type_traits>
#include &lt;limits>
template&lt;typename T_> using limit = std::numeric_limits&lt;T_>;//create new type. C++11:alias declaration
template&lt;typename T_> T_ input(const char* echo_str, const T_ max = limit&lt;T_>::max(), const T_ min = limit&lt;T_>::lowest()) noexcept{
    static_assert(std::is_arithmetic&lt;T_>::value, "unexpected type T_");//T_が整数か浮動小数点型でないならばコンパイルエラーを出す
    T_ buf;
    try {
        if (nullptr == echo_str) throw std::invalid_argument("echo_str is unexpected input");//エラー対策
        if ('\0' != echo_str[0]) std::cout &lt;&lt; echo_str &lt;&lt; std::endl;//文字列が空じゃなければ出力
        std::cin >> buf;//入力を受ける
        if (max &lt; buf || buf &lt; min) throw std::out_of_range("input is iligal");//範囲チェック
    }
    catch (std::exception&amp; er) {
        std::cerr &lt;&lt; er.what() &lt;&lt; std::endl;//エラーメッセージ表示
        return input("再入力してください。", max, min);//エラー時は再帰する方向で
    }
    return buf;
}</pre>
        <p>てかすでに何気なく使ってましたね。再帰深度とかとか、これ以上は解説しません。なにより書いている私(=yumetodo)がわからん。</p>
    </section>
    <section>
        <h2>関数ポインタ</h2>
        <p>これまでデータ(動的配列、配列、変数)へのポインタを使ってきましたが、今度は関数へのポインタです。では関数へのポインターとは一体何でしょうか。</p>
        <p>そのことを知るためにはまず関数をどのように呼んでいるかを知る必要があります。</p>
        <img src="./pic/memory_map.png" alt="memory_map">
        <p>
            これは一般的な処理系のメモリーの様子を表したものです。というのは別にスタック領域だのヒープ領域だのは一切言語規格には含まれていないからです。<br>
            それだと話が進まないので一般的な処理系について今回は見ていきます。<br>
            メモリーの様子といっても「プログラムから見える」メモリーです。実際にはOSとCPUが連携してL1～L3キャッシュ、RAM、ページファイルに分散しています。
        </p>
        <pre class="brush: cpp;">#include &lt;stdio.h>
#include &lt;stdlib.h>
typedef struct {
    char name[20];
    int age;
} Animal;

static Animal a1 = { 0 };
Animal a2 = { 0 };
static const int b = 33;
int main(void){
    Animal a3 = { 0 };
    int a = 32;
    Animal* a4 = malloc(1 * sizeof(Animal));
    printf("a1:%p, a2:%p, a3:%p, a4:%p, a:%p, b:%p\n", 
        (void*)&amp;a1, (void*)&amp;a2, (void*)&amp;a3, (void*)a4, (void*)&amp;a, (void*)&amp;b
    );
    free(a4);
    printf("puts:%p\n", puts);
    return 0;
}</pre>
        <pre class="brush: plain;" title="実行例">a1:0x80498d4, a2:0x80498bc, a3:0xbf91dd80, a4:0x98f9008, a:0xbf91dd7c, b:0x80486c4
puts:0x8048440</pre>
        <p>
            19行目はもしかしたらコンパイルエラーになるかも。<br>
            変数a1, a2, b はstatic領域(勝手に命名)に、変数a3, a はスタック領域に、変数a4の指し示す先はヒープ領域にあるのがわかると思います。<br>
            で関数はどこにあるのかというとコード領域にあるのがわかると思います。
        </p>
        <p>
            ここで抑えておかないといけないことがあります。<br>
            関数、つまりその処理の手順ももちろんメモリー上にあるのですが、処理過程でつかう変数とは明確にべつの領域にあります。<br>
            もう一度言います、コードとデータは別です。
        </p>
        <img src="./pic/stack_area.png" alt="stack_area">
        <p>
            ここで思い出して欲しいのがこの図です。<br>
            関数を呼ぶときは、引数、returnアドレス、ebpがスタックに積まれ、そのあと関数が実行され適宜関数内の自動変数がスタックに積まれるのでした。<br>
            returnアドレスとは他でもなくコード領域へのポインタです。
        </p>
        <p>まとめましょう。関数を呼ぶまでには</p>
        <ol>
            <li>スタックに必要なものを積む</li>
            <li>関数を実行する</li>
        </ol>
        <p>という手順を踏んでいます。</p>
        <p>ところで変数に型があるように、関数にも型があります。</p>
        <pre class="brush: cpp;" title="puts関数の型は　int(const char*) 型">int puts ( const char * str );</pre>
        <p>たとえばおなじみputs関数の型は、int(const char*) 型です。ではこの型はなにを表しているのでしょうか？</p>
        <pre class="brush: cpp;">int num;</pre>
        <p>
            ここで振り返るべきは普通の変数です。言うまでもなく変数numの型はint型です。つまりメモリー上にsizeof(int)分のメモリーが確保されるということを意味します。<br>
            これを踏まえて関数の型が何を示すのか考えましょう。
        </p>
        <p>
            ・・・考えましたか？<br>
            関数の型が表しているのは戻り値と、引数の型および順序です。<br>
            つまり、関数呼び出し時にどのようにスタックにデータを書き込むか、という情報です。
        </p>
        <p>
            まとめます。<br>
            <b>関数の型とは、関数を呼び出す手順その1の「スタックに必要なものを積む」ために必要な情報です</b>
        </p>
        <p>話は少し変わります。先ほどの手順2ですが、「関数を実行する」とありました。で、これまでどのように関数を呼び出していたかというと、</p>
        <pre class="brush: cpp;">puts("arikitari_na_world!");</pre>
        <p>
            みたいに、関数名を書けば関数を呼び出せていたと思います。<br>
            ところで、先ほど言ったように、関数の実体は(inline展開されない限り)メモリー上のコード領域にあるのでした。<br>
            で、コンパイラー(リンカー)はそのアドレスがわかるので、関数名を書くだけで関数をcallできたわけです。
        </p>
        <p>
            要するに大事なのは関数実体の場所です。そこが分かりさえすれば関数が実行できます。<br>
            つまり、そこへのポインタがあれば関数、実行できますよね？
        </p>
        <p>
            話が長くなりました。<b>関数ポインタとはある関数の実体(コード領域にある)へのポインタ</b>です。<br>
            関数ポインタも当然型があります。なぜならば、ポインタとは、基本型から派生してできる型だからです。
        </p>
        <pre class="brush: cpp;">#include &lt;stdio.h>
int puts ( const char * str );//型はint(const char*)
typedef int(*puts_t1)(const char*);
using puts_t2 = int(*)(const char*);//C++11:alias declaration
int main(){
    int (*f1)(const char*) = puts;
    puts_t1 f2 = puts;
    puts_t2 f3 = puts;

    f1("f1");
    f2("f2");
    f3("f3");
    return 0;
}</pre>
        <p>
            6, 7, 8行目は全部同じ意味です。<br>
            2行目はtypedefしています。新しくできる型名はputs_t1型です。なんとわかりにくい。<br>
            3行目はC++11のalias declarationをつかっています。わかりやすい。
            このように、Cの文法はちっとも直感的ではないので、<b>alias declarationを使って、型を作ってから使うことを強く推奨します</b>。
        </p>
    </section>
    <nav class="bottom">
        <ul>
            <li><a href="./19str_manipulate.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            li><a href="./21std_string.html" title="次頁">next</a></li>
        </ul>
    </nav>
</body>
