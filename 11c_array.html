<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>第11章 ～配列とポインタ演算～</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/sanitize.css/2.0.0/sanitize.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <script src="./syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushPlain.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushCpp_kai.js" type="text/javascript"></script>
    <link href="./syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css">
    <link href="./syntaxhighlighter/styles/shThemeMidnight_likeVS.css" rel="stylesheet" type="text/css">
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <h1>第11章 ～配列とポインタ演算～</h1>
    <nav class="top">
        <ul>
            <li><a href="10introduction_of_pointer.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="12m.d.c_array.html" title="次頁">next</a></li>
        </ul>
    </nav>
    
    <section>
        <h2>配列とポインタ演算</h2>
        <p>
            はい、配列です。しょっちゅうポインタと混同されるかわいそうな子です。<br>
            ・・・ちゃんと説明します。配列とは、英語ではarrayと言います。配列は、（宣言時に指定される要素数）×（配列の要素の型の大きさ）分メモリーをスタック領域に確保し、<br>
            それを配列の要素の型の大きさづつに区切ってつかいます。忘れがちなことですが、<b>配列は0から始まります。</b><br>
            宣言する方法は
        </p>
        <pre class="brush: cpp;">int cell[10];</pre>
        <p>
            みたいに書きます。[]の中に要素数を指定するのですが、この要素数はコンパイル時にきまっている必要が有ります(C99/C11以外)。<br>
            なのでC99/C11以外ではこんな書き方はできません。
        </p>
        <pre class="brush: cpp;">const unsigned int tmp1 = 5;
int cell1[tmp1];//NG without C99/C11
constexpr unsigned int tmp2 = 5;
int cell2[tmp2];//OK. However, it's able to use VC November 2013 CTP or later.</pre>
        <p>constexprはコンパイル時定数ですから使えます。が、constexprが使えるのはVCだとNovember 2013 CTPからみたいですね。さすが実装は最遅。C99/C11では2行目の場合は厳密には配列ではないらしいです。</p>
        <p>
            で、この配列宣言時の要素数指定に非コンパイル時定数を使う記法はC++では使えません。<code>std::array</code>がある以上必要ないと思いますが。allocaを書かずに済む以外メリットあんの？<br>
            C++14(N3639)で導入されかけて廃止され、n3820で再提案されているそうです。<br>
            <a href="http://isocpp.org/files/papers/N3639.html">N3639 Runtime-sized arrays with automatic storage duration (revision 5)</a><br>
            <a href="http://faithandbrave.hateblo.jp/entry/20130507/1367916341"> C++14 実行時サイズの配列(コア言語版) - Faith and Brave - C++で遊ぼう</a><br>
            <a href="http://qiita.com/raccy/items/bfcb62086c5f027d57b6">C言語(C11)で可変長の配列を使う方法 - Qiita</a>
        </p>
        <pre class="brush: cpp">unsigned int i = 10;
int tmp[i];</pre>
        <p>
            まあ実際に使ってみましょう。
        </p>
        <pre class="brush: cpp; highlight:[8,15,25];">#include&lt;stdio.h&gt;
#include&lt;time.h&gt;
#if !defined (_countof)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#endif
int main(void){
    int num[10] = { 0 };//(宣言時に指定される要素数)×(配列の要素の型の大きさ)分メモリーをスタック領域に確保
    for(unsigned int i = 0; i < (sizeof(num) / sizeof(*num)); i++){
        *(num + i) = clock();
    }
    for(unsigned int i = 0; i < (sizeof(num) / sizeof(*num)); i++){
        printf("%d,", *(num + i));
    }
    putchar('\n');
    int* num_p = num;
    printf(
    	"_countof(num):%d,_countof(num_p):%d, sizeof(num_:%d, sizeof(num_p):%d\n",
    	_countof(num), _countof(num_p), sizeof(num), sizeof(num_p)
    );
    for(unsigned int i = 0; i < _countof(num); i++){
        printf("%d,", *(num_p + i));
    }
    putchar('\n');
    for(unsigned int i = 0; i < _countof(num); i++){
        printf("%d,", num[i]);
    }
    putchar('\n');
    for(unsigned int i = 0; i < _countof(num); i++){
        printf("%d,", num_p[i]);
    }
    putchar('\n');
    for(unsigned int i = 0; i < _countof(num); i++){
        printf("&amp;num[%d]:%p\n", i, &amp;num[i]);
    }
    return 0;
}</pre>
        <p>実行例としてはこんなかんじでしょうか。</p>
        <pre class="brush: plain">4859,4860,4860,4861,4861,4861,4862,4862,4862,4863,
_countof(num):10,_countof(num_p):1, sizeof(num_:40, sizeof(num_p):4
4859,4860,4860,4861,4861,4861,4862,4862,4862,4863,
4859,4860,4860,4861,4861,4861,4862,4862,4862,4863,
4859,4860,4860,4861,4861,4861,4862,4862,4862,4863,
&num[0]:0xbfa4d84c
&num[1]:0xbfa4d850
&num[2]:0xbfa4d854
&num[3]:0xbfa4d858
&num[4]:0xbfa4d85c
&num[5]:0xbfa4d860
&num[6]:0xbfa4d864
&num[7]:0xbfa4d868
&num[8]:0xbfa4d86c
&num[9]:0xbfa4d870</pre>
        <p>
            7行目で「{}」という見慣れないものが有りますが、初期化子リストとかいうものです。この場合初期化する意味はないのですが、説明のために使っています。<br>
            リストに書いた値の個数が配列の要素数より小さい場合、残りの要素が0で埋められる、という性質を利用しています。<br>
            C++ならこんな面倒なことをしないでも{}と書けば十分なんですけどね。まあC++でも「初期化している感が出る」という理由でCっぽく{ 0 }と書く人もかなりいるんですが。<br>
            この2者、微妙に意味が違い、さらにCとC++でも若干意味が違うので、興味があるなら下のサイトを見るといいかもしれません。<br>
            本の虫: aggregateと初期化リストの不思議<br>
            <a href="http://cpplover.blogspot.jp/2010/09/aggregate.html">http://cpplover.blogspot.jp/2010/09/aggregate.html</a><br>
            本の虫: 多くのプログラマは言語を表面的な理解だけで使っている<br>
            <a href="http://cpplover.blogspot.jp/2010/09/blog-post_18.html">http://cpplover.blogspot.jp/2010/09/blog-post_18.html</a>
        </p>
        <p>
            11～23行目と24～34行目を比較すれば分かるかと思いますが、以下の3つはすべて同値です。というより1番目の簡便記法が2番目と3番目です。
        </p>
        <pre class="brush: cpp;">*(num + i)
num[i]
i[num]</pre>
        <p>ただし、<b>3行目の書き方はしないように</b>しましょう。普通1行目の書き方はめんどいので2行目のように「num[i]」と書きます。といえば分かるように、演算子「[]」は配列とはなんの関係もない演算子です(添字演算子って言います)。</p>
        <p>
            よく勘違いされますが、numの型は「int*」型ではありません。「int[10]」型です。どう違うかは多次元配列のとこで説明します。
        </p>


        <p>
            ただし、sizeof演算子と&amp;演算子(アドレス演算子)のオペランドと配列初期化時の文字列リテラルと(lvalue)参照に代入するときは以外は常にポインタ型に読み替えられます。詳細はおいおい。
        </p>
        <p>
            15行目を見てください。ここでnum代入したことでnum_pは配列numの先頭要素をさしています。だから配列と同じく*(num_p + i)とかnum_p[i]のように書けるわけです。<br>
            ここについてはすぐに詳細解説をします。<br>
            ちなみにこのポインタが配列を挿してなかった場合、num_pは要素数1の配列のように扱われるので、num_p[1]とすることは許されてもnum_p[2]と書いたり、num_p[1]に何かを代入することは許されません。
        </p>
        <pre class="brush: cpp;">sizeof(num) / sizeof(*num)</pre>
        <p>
            と書きましたが、これ自体は配列の要素数を求めています。さっきの話通り、numはint[10]型だからsizeof(num)でnumの配列全体の大きさが分かるわけです。あとは要素1つの大きさで割れば要素数が求まるよね？<br>
            ちなみにこの方法は有名なのでnumofマクロとか_countofマクロとして知られ、Visual Studioでは、stdlib.hをincludeすると_countofマクロが使えます。(日本語版のMSDNの訳が腐ってるので英語版を見てください)<br>
            <a href="https://msdn.microsoft.com/en-US/library/ms175773.aspx">https://msdn.microsoft.com/en-US/library/ms175773.aspx</a><br>
            gccの場合は・・・ここを参照してください。<br>
            <a href="http://stackoverflow.com/questions/4415530/equivalents-to-msvcs-countof-in-other-compilers">http://stackoverflow.com/questions/4415530/equivalents-to-msvcs-countof-in-other-compilers</a><br>
            これらを使うと配列以外に使用するとコンパイルエラーになってくれます。だってあくまでint[10]型だからこんなことが出来るわけで、int*型に対して使えるわけがないよね？<br>
            C++なら参照を使えよ、という指摘はさておき。<br>
            参考までにVCでの実装を書いておきます。C++の参照が何か理解してないと全く意味不明だろうけどね。
        </p>
        <pre class="brush: cpp; first-line: 356;">/* _countof helper */
#if !defined (_countof)
#if !defined (__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else  /* !defined (__cplusplus) */
extern "C++"
{
template &lt;typename _countoftype, size_t _sizeofarray&gt;
char (*__countof_helper(_UNALIGNED _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
#define _countof(_Array) (sizeof(*__countof_helper(_Array)) + 0)
}
#endif  /* !defined (__cplusplus) */
#endif  /* !defined (_countof) */</pre>
    </section>
    <section>
        <h3>ポインタ演算</h3>
        <p>
            さて、先ほど*(num_p + i)のようにさらっとポインタ演算という機能を使っていました。これはもともとC言語の前身、B言語にあった機能です。<br>
            ポインタ演算とは、ポインタに整数を足したり引いたりポインタ同士で引き算を行ったりする演算です。<br>
            コンパイラーには、numの要素の型の大きさがわかっています。だってでっかく確保したメモリー空間をint型の大きさで区切っただけだもんね、あたりまえだよね。<br>
            この区切り一つ一つを配列の要素と言うわけですが、これに1加算すると隣の区切りが見られる、ということになります。例を見てください。
        </p>
        <pre class="brush: cpp;">int hoge[] = {5, 7, 9, 4};
int * hoge_p = hoge;
printf("sizeof(int)=%d", sizeof(int));
printf("hoge_p..%p:%d", hoge_p, *hoge_p);
hoge_p++;
printf("hoge_p..%p:%d", hoge_p, *hoge_p);</pre>
        <p>hoge_pの値がsizeof(int)分加算されているのがわかると思います。配列でhoge[2]とか書けるのはこの機能のおかげなのです。まあ普段は意識することはないのですが。</p>
    </section>
    <section>
        <h3>添字演算子とポインタと配列と</h3>
        <pre class="brush: cpp; first-line: 14; highlight:[15];">    putchar('\n');
    int* num_p = num;
    printf(
    	"_countof(num):%d,_countof(num_p):%d, sizeof(num_:%d, sizeof(num_p):%d\n",
    	_countof(num), _countof(num_p), sizeof(num), sizeof(num_p)
    );
</pre>
        <p>
            改めてさっきのプログラムの15行目を見てください。numはここでは配列の名前です。が、しかし単なるポインタ型に読み替えられます。つまり、numと書いた瞬間それはint[10]型からint*型に読み替えられているわけです。<br>
            注意して欲しいのが、「Cでは、配列名の後に[]を付けずに配列名だけ単独で書くと、配列の先頭要素へのポインタ、という意味になります」というのは嘘だ、ということです。<br>
            配列の宣言時に確かに[]を使いますが(俺は宣言時のをstd::vectorみたいに()にしてればこんな誤解はなかったと思うんだが)、それ以外では先にちらっと話した4つの例外を除き、<br>
            <b>配列は問答無用でポインタに読み替えられます</b>。<br>
            だって、これら全部同じ意味だもんね。あたりまえだよね。(プログラム例は前橋和弥著 C言語ポインタ完全制覇p57-p61を改変)
        </p>
        <blockquote>
            <pre class="brush: cpp; highlight:[6,7,8];" title="プログラムA">#include&lt;stdio.h&gt;
int main(void){
    int array[5] = { 0, 1, 2, 3, 4 };
    unsigned int i;
    int* p;
    for(p = &amp;array[0]; p != &amp;array[5]; p++){
        printf("%d," *p);
    }
    
    return 0;
}
</pre>
            <pre class="brush: cpp; first-line: 6;" title="プログラムB">p = &amp;array[0];
for(i = 0; i < 5; i++){
    printf("%d," *(p + i));
}</pre>
            <pre class="brush: cpp; first-line: 6;" title="プログラムC">p = array;
//&amp;array[0] -&gt; &amp;*(array + 0) -&gt; array + 0 -&gt; array
//みたいなイメージ。&amp;*(array + 0)なんて書き方はできないけど。
for(i = 0; i < 5; i++){
    printf("%d," *(p + i));
}</pre>
            <pre class="brush: cpp; first-line: 6;" title="プログラムD">p = array;
for(i = 0; i < 5; i++){
    printf("%d," p[i]);
}</pre>
            <pre class="brush: cpp; first-line: 6;" title="プログラムE">for(i = 0; i < 5; i++){
    printf("%d," array[i]);
}</pre>
        </blockquote>
        <p>それで、上記のプログラムからついでに</p>
        <pre class="brush: cpp;">*(num + i)
num[i]
i[num]</pre>
        <p>の証明もできたわけですが。</p>
        <p>ちなみに、C++にはイテレータというポインタもどきのようなものが有り、これの使い方がプログラムAにそっくりなので頭の片隅に入れておきましょう。(サンプルはC++11の機能を使っています)</p>
        <pre class="brush: cpp;">std::vector&lt;int&gt; data{ 0, 1, 2, 3, 4 };//This usage is a thing of C++11.
int total = 0;
for(auto data_it = data.begin(); data_it != data.end(); data_it++) {
    total += *data_it; 
}</pre>
    </section>
    <section>
        <h2>配列とメモリー空間とオーバーフローとバッファオーバーラン</h2>
        <p>なんどでもいいますが配列は単に大きく確保したメモリー空間を指定型に区切っているだけです。では確保していない領域に書き込もうとすると？</p>
        <pre class="brush: cpp;">int arr[5];
for(size_t i = 0; i <= __countof(arr); i++){
    arr[i] = i;//配列の範囲をこえて値を書き込んでいる
}</pre>
        <p>
            i=__countof(arr)の時、つまりi=5の時、書き込む位置は確保されていない領域です。<br>
            <b>確保していない領域まで書き込んでしまうことをバッファオーバーランとかバッファオーバーフローといいます</b>。でこれの何が問題なのでしょうか？
        </p>
        <p>以前も関数のところで紹介した図を再度掲示します。よく見てください。</p>
        <img alt="スタック領域" src="./pic/stack_area.png">
        <p>
            配列も自動変数なのでスタック領域に確保されます。で注意するべきなのが、配列の要素番号が大きい物のほうがebpレジスタ(スタックの底を示すもの)に近い方に確保されるということです。<br>配列のアドレスを要素数の小さい方から表示させた時にちゃんと値が増えていたことを思い出してください。
        </p>
        <p>
            つまりなにが問題なのかというと、配列よりebpレジスタに近い方に確保された(配列より先に確保された)自動変数やebpレジスタ自身、はたまた関数のリターンアドレスがバッファオーバーランによって書き換えられることを意味しています。<br>
            なので<code>return 0;</code>すらできなくなるわけです。<br>それだけならともかく、配列にファイルなどから何かを読み込む場合、バッファオーバーランを起こすプログラムに悪意のあるバイト列を読み込ませることでリターンアドレスを書き換え、悪意のあるプログラムを呼び出すことができます<br>
            このように、バッファオーバーランとは実に恐ろしい問題なのです。<br>
            それ故C言語では<b>確保していない領域にポインターを指すことすら認めていません</b>。
        </p>
        <p>なので<b>配列に何かを書き込むときは、必ず配列の要素数を確認するように</b>しましょう。まあ、C++のvectorやarray、stringを使えばほとんど気を使わずに済むんですが。</p>
        <p>ただし、割とどうでもいいことですが、配列の要素数番目にポインターを指すことは認められています。書き込んだらダメですが。</p>
        <p>
            参考サイト<br>
            6-1. バッファオーバーラン　その１「こうして起こる」 | IPA ISEC セキュアプログラミング講座<br>
            <a href="http://www.ipa.go.jp/security/awareness/vendor/programmingv1/b06_01.html">http://www.ipa.go.jp/security/awareness/vendor/programmingv1/b06_01.html</a><br>
            スタック領域の構成 | 分かりやす～いコンピュータ技術情報<br>
            <a href="http://hack.ninja-web.net/academy003-060.htm">http://hack.ninja-web.net/academy003-060.htm</a>
        </p>
    </section>
    <section>
        <h2>argvについて補足</h2>
        <p>今更言うまでもありませんがmain関数で引数を受け取る場合は</p>
        <pre class="brush: cpp;">int main(int argc, char* argv[]);</pre>
        <p>のように書きますが、argvはchar**型です。多分char*型の配列が渡されているんでしょう。で、argv[argc]はNULLポインタであることが保証されています。たま～に必要になる知識ですので覚えていてください。</p>
    </section>
    <section>
        <h2>std::bitsetとstd::vector&lt;bool&gt;</h2>
        <p>
            以前bool型についてやったのを覚えているでしょうか？(C++の)bool型とはtrue/falseの2値を格納できる型でした。故に実質1bitしかないこともあります。<br>
            ところでポインタ演算はsizeof([対象の型])分ポインタを進めるものでした。で、sizeof(bool)は1、つまり1byte使われます。<br>
            もう一度言いますよ？bool型は1bitではなく1byte消費します。<br>
            なんか勿体無いでしょ？普通の配列にするにはもったいないでしょ？<br>
            そこでstd::bitsetとstd::vector&lt;bool&gt;の出番です。
        </p>
        <section>
            <h3>std::vector&lt;bool&gt;</h3>
            <p>
                まさか他の型のvectorより先に紹介するとは思わなかった。<br>
                std::vector&lt;bool&gt;は配列と異なりぎちぎちに詰めて、つまり1bit=1要素になります。<br>
                どういうことかというと、<code>&amp;v[0]+i != &amp;v[i]</code>ということです。なので扱いはすこし注意が必要になります。
            </p>
            <pre class="brush: cpp;">#include &lt;vector&gt;
//void Func(bool&amp; x)//これは誤り
void Func(vector&lt;bool&gt;::reference x)
{
  x= false;
}
int main(int argc, char**argv)
{
  std::vector&lt;bool&gt; vec;
  vec.push_back(true);
  Func(vec.back());
  return 0;
}</pre>
            <p>
                <code>&amp;v[0]+i != &amp;v[i]</code>ということは、のちに説明する参照は特殊なものになります。通常のbool&amp;型には変換でいないのでvector&lt;bool&gt;::referenceに変換する必要があります。<br>
                そういった都合上以下のコードはすべて違法です
            </p>
            <pre class="brush: cpp;" title="違法なコード">std::vector&lt;bool&gt; bb;
bb.push_bask(true);
bool* bb_p = &amp;bb[0];//"std::_Vb_reference&lt;std::_Wrap_alloc&lt;std::allocator&lt;std::_Vbase&gt;&gt;&gt; *" の値を使用して型 "bool *" のエンティティを初期化することはできません
bool&amp; bb_r = bb[0];//非 const への参照の初期値は左辺値である必要があります
std::vector&lt;bool&gt;::pointer bb_p2 = &amp;bb[0];
//"std::_Vb_reference&lt;std::_Wrap_alloc&lt;std::allocator&lt;std::_Vbase&gt;&gt;&gt; *" から "std::_Vb_iterator&lt;std::_Wrap_alloc&lt;std::allocator&lt;std::_Vbase&gt;&gt;&gt;" に変換するための適切なコンストラクターが存在しません</pre>
            <p>
                関数などに渡すときはポインタ渡しは諦めて参照渡しにするか、<b>コンテナごと参照渡しして、書き込む位置を別途変数で渡す</b>のが楽でしょう。<br>
                ちなみに型推論はちゃんと働きます。
            </p>
            <pre class="brush: cpp;">std::vector&lt;bool&gt; bb;
bb.push_bask(true);
auto&amp; bb_r = bb[0];//vector&lt;bool&gt;::reference型</pre>
            <blockquote title="Effective STL p77 第18項" cite="http://www.amazon.co.jp/dp/4894714108">
                <p>vector&lt;bool&gt;がSTLのコンテナとして悪い点は2つしかない。第1に、STLのコンテナではない。第2に、bool型の値が格納されない。この2つを除けば、異議を唱える理由はない。</p>
                <cite><a href="http://www.amazon.co.jp/dp/4894714108">Effective STL p77 第18項</a></cite>
            </blockquote>
            <p>
                参考サイト<br>
                vector&lt;bool&gt; の話 - melpon日記 - HaskellもC++もまともに扱えないへたれのページ<br>
                <a href="http://d.hatena.ne.jp/melpon/20111114/1321297053">http://d.hatena.ne.jp/melpon/20111114/1321297053</a><br>
                std::vector&lt;bool&gt;の要素の参照型はbool&amp;ではない（場合がある） - akihiko’s tech note <br>
                <a href="http://d.hatena.ne.jp/aki-yam/20120307/1331117485">http://d.hatena.ne.jp/aki-yam/20120307/1331117485</a><br>
                vector&lt;bool&gt; クラス | MSDN <br>
                <a href="https://msdn.microsoft.com/ja-jp/library/t0723a54.aspx">https://msdn.microsoft.com/ja-jp/library/t0723a54.aspx</a>
            </p>
        </section>
        <section>
            <h3>std::bitset&lt;N&gt;</h3>
            <p>そのうち紹介するstd::arrayのbool特化型超すごい版と思えばいいです。std::vector&lt;bool&gt;よりは使いやすいはず。</p>
            <pre class="brush: cpp;">#include &lt;iostream&gt;
#include &lt;bitset&gt;
constexpr std::size_t thread_num = 4;//コンパイル時定数でなければならない
void thread(std::bitset&lt;thread_num&gt;&amp; isHDMs, const std::size_t thread_id){
    isHDMs.set(thread_id);//thread_id番目のbitを立てる(trueにする)
}
int main(){
    std::bitset&lt;thread_num&gt; isHDMs(0ul);
    isHDMs.reset();//全bitを0に
    for(std::size_t i = 0; i < thread_num; ++i){
        thread(isHDMs, i);
    }
    if(isHDMs.any()){//一つでもbitが立っていたら
        for(std::size_t i = 0; i < thread_num; ++i){
            if(isHDMs.test(i)) std::cout << i << "番目のbitが立っています"　<< std::endl;
        }
    }
    return 0;
}</pre>
            <p>個人的に残念なのは、beginとendメンバー関数がないのでrange-base for(後述)が使えないことですかね。</p>
            <p>
                参考サイト<br>
                bitsetクラス - (void*)Pないと<br>
                <a href="http://d.hatena.ne.jp/pknight/20090813/1250140616">http://d.hatena.ne.jp/pknight/20090813/1250140616</a><br>
                ぐだぐだ std::bitsetの使い方サンプル<br>
                <a href="http://ututel.blog121.fc2.com/blog-entry-138.html">http://ututel.blog121.fc2.com/blog-entry-138.html</a><br>
                bitset クラス | MSDN <br>
                <a href="https://msdn.microsoft.com/ja-jp/library/2f93c55z.aspx">https://msdn.microsoft.com/ja-jp/library/2f93c55z.aspx</a><br>
                C++ ビット集合(std::bitset) | cppreference <br>
                <a href="http://www.cppll.jp/cppreference/cppbitset_details.html">http://www.cppll.jp/cppreference/cppbitset_details.html</a><br>
                C++編（標準ライブラリ）　第８章　bitset | Programing Place <br>
                <a href="http://ppp-lab.sakura.ne.jp/cpp/library/008.html">http://ppp-lab.sakura.ne.jp/cpp/library/008.html</a><br>
                8.4 bitset の抽象化 | Rogue Wave Software <br>
                <a href="https://docs.oracle.com/cd/E19205-01/820-2985/general/8_4.htm">https://docs.oracle.com/cd/E19205-01/820-2985/general/8_4.htm</a>
            </p>
        </section>
    </section>
    <nav class="bottom">
        <ul>
            <li><a href="10introduction_of_pointer.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="12m.d.c_array.html" title="次頁">next</a></li>
        </ul>
    </nav>
</body>
</html>