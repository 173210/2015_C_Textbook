<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>>第15章 ～lValueとrValueおよびtemplete～</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/sanitize.css/2.0.0/sanitize.min.css">
    <link rel="stylesheet" href="./css/style.css">
    <script src="./syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushPlain.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushCpp_kai.js" type="text/javascript"></script>
    <link href="./syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css">
    <link href="./syntaxhighlighter/styles/shThemeMidnight_likeVS.css" rel="stylesheet" type="text/css">
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <h1>第15章 ～lValueとrValueおよびtemplete～</h1>
    <nav class="top">
        <ul>
            <li><a href="./14pointer.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./16Range-base_for.html" title="次頁">next</a></li>
        </ul>
    </nav>
    <section>
        <h2>template入門</h2>
        <p>はい、入門です。こんなのまじめに解説したら本が一冊書けます。まあすでに出てきましたが。まずは定義から。</p>
        <blockquote>
            <a>テンプレートとは、コンパイル時に型や値を引数として渡す機能のことである。</a><br>
            <a href="http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#temp">14 テンプレート(Templates) | C++11の文法と機能(C++11: Syntax and Feature)</a>
        </blockquote>
        <p>分かった・・・？いい？<b>コンパイル時だよ？コンパイル時。</b>そこ大事だからね。</p>
        <pre class="brush: cpp;">
#include &lt;iostream>
template&lt;typename T_&gt;
inline T_ max(T_ a, T_ b){
    return (a > b)? a : b;
}
int main(){
    const auto hoge1 = max(54, 23);//hoge1はint型
    const auto hoge2 = max&lt;unsigned int>(54, 23);//hoge2はunsigned int型

    std::cout &lt;&lt; hoge1 &lt;&lt; hoge2 &lt;&lt; std::endl;
    return 0;
}</pre>
        <p>みれば分かるように最大値を返す関数ですが、型が「T_」になってます。どういうことだってばよ？</p>
        <p>これまで最大値を求める関数を作ろうと思ったら全部の型ごとに関数を書く必要が有りました。事実C言語のmath.hを見ると同じような機能の型が違う関数が乱造されています。んなもんいちいち覚えてらんないですよね？</p>
        <p>そういった背景からC++では関数をオーバーロード出来るようになりました。つまり、<b>引数の型が異なれば</b>同名の関数をいくつでも作れるようになりました。</p>
        <p>
            2行目を見てください。templateから始まる部分がありますが、これがtemplateの仮引数と呼ばれるところです。関数にも仮引数があったけどあれに似てます。<br>
            ただし指定できるのは型名(とコンパイル時定数)のみです。<br>
            例えばこの場合新たにT_という型をでっち上げているわけですが、この時点では実際の型はわかりません。若干違いますが方の異なる関数が無限に存在するイメージで差し支えありません。<br>
        </p>
        <p>
            7行目を見てください。これは<a href="http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#temp.expl.spec">テンプレートの実引数推定(Template argument deduction)</a>という機能を使っています。<br>
            できるだけ普通のプログラマーの常識に合わせるために、とても複雑になっているのですが、逆に言えば、<br>
            <b>ノリと勘と気分となんとなくでどーにかなる</b>ということです。<br>
            ようはtemplate関数の引数に書いた型に推論されるわけで。まあみればわかるでしょ。
        </p>
        <p>
            8行目は<a href="http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#temp.fct.spec">明示的なテンプレート実引数指定(explicit template argument specification)</a>と呼ばれていて<br>
            かっこ良く名前をつけましたがこの場合ならようはT_の型はunsigned intだよ～と教えているだけです。
        </p>
        <p>
            7, 8行目のようにtemplateを使ったもの(今回はtempalte関数)を実際に読んでコンパイルされると、先ほどの「無限に存在する」状態の例えで言うならどれか特定のものに定まります。<br>
            もちろん実際に関数としてコンパイルされるのは呼び出されているものだけです。
        </p>
        <p>関数のオーバーロードをするのにもっとも楽なのはtemplateを使って上のように書く方法です。コンパイラーはコンパイル時にどの型の関数が必要かわかるのでコンパイラーが型だけ違えた関数を勝手に作ってくれます。便利。</p>
        <p>まあ関数のオーバーロードよりは、クラスのオーバーロードで使うことのほうが多いんですけどね・・・、まいっか。</p>
        <p>ちなみにこの関数、もしchar*型の変数が引数になったらどうなるでしょうか？多分意図した動作では無いですよね？気をつけないと後述するスタックオーバーフローとかが起きかねないので注意です。</p>
        <p>
            で、templateですが、C++erになるなら必ず習得しないといけません、ああ、私の耳が痛い、なんでだろう。template使えないC++erなんて相手にされないですからね。<br>
            事実C++のBoostライブラリーなんてtemplateばっかです。さらにポリモーフィズム(動的/静的)とかも関わってくるのですが（以下略）
        </p>
        <p>
        	<a href="http://www.slideshare.net/faithandbrave/c-template-metaprogramming" title="C++ Template Metaprogramming">C++ Template Metaprogramming</a><br>
        	from <a href="//www.slideshare.net/faithandbrave" target="_blank">Akira Takahashi</a>
        </p>
        <iframe src="http://www.slideshare.net/slideshow/embed_code/key/D94FOh5mptZIEK" width="425" height="355" class="slideshare" allowfullscreen> </iframe>
        <p>上のスライドで出ているメタテンプレートプログラミングっていうのをほんの少しだけかじったコードがこれです。templateの特殊化という技法を使っているのですが・・・むずい。</p>
        <pre class="brush: cpp;">
#include &lt;random>
#include &lt;type_traits>
template &lt;bool Con, class Then, class Else>
struct IF;
template &lt;class Then, class Else>
struct IF&lt;true, Then, Else> {
    typedef Then type;
};
template &lt;class Then, class Else>
struct IF&lt;false, Then, Else> {
    typedef Else type;
};

template&lt;typename rand_type>
using my_uniform_distribution = typename IF&lt;
    std::is_integral&lt;rand_type>::value, std::uniform_int_distribution&lt;rand_type>, std::uniform_real_distribution&lt;rand_type>
>::type;
//中略
static_assert(std::is_arithmetic&lt;rand_type>::value == true, "'rand_type' is illegal type.");//非算術型にはコンパイルエラーを
my_uniform_distribution&lt;rand_type> distribution;</pre>
        <p>
            あーめんd。なんでstatic_ifが規格に入らないんや。<br>
            static_ifというのは、<br>
            <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3322.pdf">N3322: A Preliminary Proposal for a Static if</a><br>
            <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3329.pdf">N3329: Proposal: static if declaration</a><br>
            でC++14に向けて提案され、かなり真剣に議論さいれてC++14に入りかけたが、コンパイラー実装者から強い反対にあったために結局入らなかったが、それでも諦めきれず<br>
            <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4461.html">N4461: Static if resurrected</a><br>
            で再度提案された機能である。<br>
            <a href="http://cpplover.blogspot.jp/2012/01/2011-01-pre-kona-2012-mailing.html">2011-01 pre-Kona 2012 mailingの簡易レビュー | 本の虫</a><br>
            <a href="http://cpplover.blogspot.jp/2015/07/c-2015-04-pre-lenexa.html">C++標準化委員会の文書 2015-04-pre-Lenexaのレビュー： N4460-N4469 | 本の虫</a><br>
            ようはどうなるのかというと
        </p>
        <pre class="brush: cpp;" title="static_if不使用">
template &lt;class T, class... Args> 
enable_if_t&lt;is_constructible_v&lt;T, Args...>, unique_ptr&lt;T>> 
make_unique(Args&amp;&amp;... args)
{
    return unique_ptr&lt;T>(new T(forward&lt;Args>(args)...));
}

template &lt;class T, class... Args> 
enable_if_t&lt;!is_constructible_v&lt;T, Args...>, unique_ptr&lt;T>>
make_unique(Args&amp;&amp;... args) 
{
    return unique_ptr&lt;T>(new T{forward&lt;Args>(args)...});
}</pre>
        <pre class="brush: cpp;" title="static_if使用">
template &lt;class T, class... Args> 
unique_ptr&lt;T>
make_unique(Args&amp;&amp;... args) 
{
    static_if (is_constructible_v&lt;T, Args...>) {
        return unique_ptr&lt;T>(new T(forward&lt;Args>(args)...));
    } else {
        return unique_ptr&lt;T>(new T{forward&lt;Args>(args)...});
    }
}</pre>
        <p>すっきり。</p>
        <p>
            とおもったらこんどは<code>constexpr_if</code>なるものが提案されたらしい。<br>
            <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0128r0.html">P0128R0 : constexpr_if</a><br>
            どうもコンパイラー実装者から強い反対にあったためにstatic_ifにスコープができたのが嫌らしい(英文解釈を間違えていないことを祈って。)
        </p>
    </section>
    <section>
        <h2>C++のlValue参照</h2>
        <p>すでに何回か登場していますが、今説明しないとあとで説明できなさそうなので。</p>
        <p>"lValue"参照って言うんだから当然"rValue"参照があるのですが、解説しません。</p>
        <blockquote>
            <p>
                C++マニアック,リファレンス＝参照の使い方,how to use reference,C++入門,C++言語講座<br>
                <a href="http://homepage2.nifty.com/well/Reference.html">http://homepage2.nifty.com/well/Reference.html</a>
            </p>
            <p>リファレンスとは何かということを解説するために、まず、最も簡単な例をあげましょう。次のコードを見てください。int 型の変数 iABitComplex のリファレンス riSimple を定義しています。</p>
            <pre class="brush: cpp;">int main() {
    int iABitComplex;               // ちょっと複雑な名前の変数
    int&amp; riSimple = iABitComplex;   // 変数のリファレンスを定義する。
    riSimple = 1;                   // リファレンスを使って iABitComplex にアクセスする。
    return 0;
}</pre>
        </blockquote>
        <p>
            <b>参照とはあくまで元からあるlValue(変数とか)に別名をつける機能です。</b><br>
            たしかにポインタに似ていますが、<b>参照とポインタの関連性について意識してはいけません</b>。
        </p>
        <pre class="brush: cpp;">#include &lt;iostream>
#include &lt;cstdint>
void modifier(uint32_t&amp; modified, uint8_t r, uint8_t g, uint8_t b){
    modified = r + static_cast&lt;uint16_t>(g) &lt;&lt; 8 + static_cast&lt;uint32_t>(b) &lt;&lt; 16; 
}
int main(){
    uint32_t rgb = 0;
    std::cout &lt;&lt; rgb &lt;&lt; std::endl;//0
    modifier(rgb, 64, 32, 84);
    std::cout &lt;&lt; rgb &lt;&lt; std::endl;//5513280
    return 0;
}</pre>
        <p>ただしlvalue referenceなのでrvalueは参照できません！！！ところがどっこいconst lvalue referenceならrvalueを参照できるっていうんだからややこしい。なんでかはクラスを学ぶまでおあずけ。</p>
        <pre class="brush: cpp;">int foo(){
    return 3;
}
int main(){
    //int&amp; a = foo();//error
    const int &amp; a = foo();//OK. but dirty
}</pre>
        <p>当面クラスとか使わないわけで、役に立つシーンは配列を関数に渡す場合です。例を見ましょう。</p>
        <pre class="brush: cpp;">#include &lt;stdio.h&gt;
#if !defined (_countof)
#if !defined (__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else  /* !defined (__cplusplus) */
extern "C++"
{
	template&lt;typename TYPE,	std::size_t SIZE&gt;
	std::size_t array_length(const TYPE(&amp;)[SIZE]){
		return SIZE;
	}
#define _countof(_Array) array_length(_Array)
}
#endif  /* !defined (__cplusplus) */
#endif  /* !defined (_countof) */
void func(const int (&amp;in_arr)[4]) {
	printf("in_arr[0]:%d, sizeof(in_arr):%d, _countof(in_arr):%d\b", in_arr[0], sizeof(in_arr), _countof(in_arr));
}
int main () {
    int arr[] = {3,4,5,6};
    func(arr);
    return 0;
}</pre>
        <p>思い出してください、ここで変数arrの型はint[4]型でした。なので引数の型もint(&amp;)[4]にします。どういうことかというと、下の例はエラーになるということです。</p>
        <pre class="brush: cpp;">#include &lt;stdio.h&gt;
#if !defined (_countof)
#if !defined (__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else  /* !defined (__cplusplus) */
extern "C++"
{
	template&lt;typename TYPE,	std::size_t SIZE&gt;
	std::size_t array_length(const TYPE(&amp;)[SIZE]){
		return SIZE;
	}
#define _countof(_Array) array_length(_Array)
}
#endif  /* !defined (__cplusplus) */
#endif  /* !defined (_countof) */
void func(const int (&amp;in_arr)[4]) {
	printf("in_arr[0]:%d, sizeof(in_arr):%d, _countof(in_arr):%d\b", in_arr[0], sizeof(in_arr), _countof(in_arr));
}
int main () {
    int arr[] = {3, 4, 5, 6, 7};
    int arr2[] = {3, 4, 5, 6};
    func(arr);//エラー。arrの型はint[5]型
    auto arr3 = arr2;
    func(arr3);//エラー。arr3の型はint*型であってint[4]型ではない。配列は4つの例外を除きポインタに読み替えられる。
    return 0;
}</pre>
        <p>まあ当たり前ですよね？ただ、<b>参照にポインタ配列は渡せない、というのは忘れがちなので注意</b>ですね。</p>
        <p>配列の要素数が変わったぐらいで関数をいくつも作るなんであまりにもめんd過ぎます。そこでtemplate先生の出番です。先生、任せた！</p>
        <pre class="brush: cpp;">#include &lt;stdio.h&gt;
#if !defined (_countof)
#if !defined (__cplusplus)
#define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
#else  /* !defined (__cplusplus) */
extern "C++"
{
	template&lt;typename TYPE,	std::size_t SIZE&gt;
	std::size_t array_length(const TYPE(&amp;)[SIZE]){
		return SIZE;
	}
#define _countof(_Array) array_length(_Array)
}
#endif  /* !defined (__cplusplus) */
#endif  /* !defined (_countof) */
template&lt;size_t SIZE&gt;
void func(const int(&amp;in_arr)[SIZE]){
	printf("in_arr[0]:%d, sizeof(in_arr):%d, _countof(in_arr):%d\b", in_arr[0], sizeof(in_arr), _countof(in_arr));
}
int main(){
    int arr[] = {3, 4, 5, 6, 7};
    int arr2[] = {3, 4, 5, 6};
    func(arr);//OK, 'void func&lt;5U>(const int (&amp;in_arr)[5])' were called.
    func(arr2);//OK, 'void func&lt;4U>(const int (&amp;in_arr)[4])' were called.
    auto arr3 = arr2;
    func(arr3);//エラー。arr3の型はint*型。配列は4つの例外を除きポインタに読み替えられる。
    return 0;
}</pre>
        <p>注意ですが、SIZEはコンパイル時に置き換えられるrValueです。変数ではないので要注意です。</p>
        <p>いい忘れましたが、関数funcで変数in_arrの型はint(&amp;)[SIZE]なので、当然sizeof演算子で配列の大きさを求められます。あたりまえだよね、参照って所詮別名だもん。</p>
        <pre class="brush: cpp; first-line: 16;">void func(const int* in_arr){
	printf("in_arr[0]:%d, sizeof(in_arr):%d, _countof(in_arr)", in_arr[0], sizeof(in_arr), _countof(in_arr));
    //sizeof(in_arr)はint*型の大きさを表し、ポインタ型は要素数1の配列と同じなので_countof(in_arr)は1になる
}</pre>
        <p>
            ちなみに参照渡しでなくてポインタ渡しで書くとこんな感じ。<br>
            配列の参照渡しとポインタ渡しの違いをまとめておきます。ポインタ配列ってのはmallocみたいに動的確保したやつね。
        </p>
        <table>
            <tr>
                <th>ポインタ渡し</th>
                <th>参照渡し</th>
            </tr>
            <tr>
                <td>ポインタ配列を渡せる</td>
                <td>ポインタ配列を渡せない</td>
            </tr>
            <tr>
                <td>ポインタ演算出来る</td>
                <td>ポインタ演算出来ない</td>
            </tr>
            <tr>
                <td>
                    渡された関数側で配列の要素数を<br>
                    知るには別途変数を渡す必要がある
                </td>
                <td>
                    渡された関数側で配列の要素数を<br>
                    知るにはsizeofや_countofを用いて分かる
                </td>
            </tr>
        </table>
        <p>
            まあなにが一番楽って、配列の要素数を別変数で渡さなくていいことですね。<br>
            多くの場合はポインタ渡しと参照渡し両方を想定して関数をオーバーロードします。<br>
            引数が違えば同名の関数を複数作れるのがC++のオーバーロード機能だもんね。
        </p>
        <p>というわけで_countofが何をしているかもわかったはず。やったね。</p>
    </section>
    <nav class="bottom">
        <ul>
            <li><a href="./14pointer.html" title="前頁">prev</a></li>
            <li><a href="index.html" title="目次">main</a></li>
            <li><a href="./16Range-base_for.html" title="次頁">next</a></li>
        </ul>
    </nav>
</body>
</html>