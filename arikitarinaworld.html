<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>01はじめの一歩</title>
    <script src="./syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushPlain.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushCpp_kai.js" type="text/javascript"></script>
    <link href="./syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css">
    <link href="./syntaxhighlighter/styles/shThemeMidnight_likeVS.css" rel="stylesheet" type="text/css">
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <section>
        <h2>ありきたりなworld</h2>
        <p>面倒なことは後回しにしてまずは画面に文字を表示させてみましょう。</p>
        <script src="http://gist-it.appspot.com/github/yumetodo/2015_C_Textbook/blob/gh-pages/src/001_arikitari_na_world.c"></script>
        <p>え？なんでHello Worldじゃないんだ？私printf関数を使うって聞いたんだけどputsって何？いやいや、こっちのほうがありきたり（普通）ですから。（なぜprintfでなくputsを使ったのかは後で説明します）</p>
        <p>このコードから多くのことが学べます。まずは一行目。</p>
        <pre class="brush: cpp;">#include&lt;stdio.h&gt;</pre>
        <p>これはヘッダーファイルと呼ばれるものを読み込む部分です。stdio.hはC言語が提供する標準ライブラリで、標準入出力(STanDard Input and Output)に関わる関数群を提供します。puts関数とかprintf関数はこれを読み込むことで使えるようになります。</p>
        <p>ついで2行目と4行目に注目してください。</p>
        <pre class="brush: cpp; first-line: 2; highlight:[2,4];">int main(void){
    puts("arikitari na world!");//画面に表示
    return 0;
}</pre>
        <p>C/C++言語は必ず関数があり、特に別途定めない限りmain関数から処理が始まります。詳細説明は先送りするとして関数には戻り値というものがあり、void型以外では必ず戻り値を返す必要があります。<br>
        main関数の戻り値は、プログラムの処理がmain関数から始まるため、プログラムの終了コード(Exist Code)とも呼ばれます。処理が成功した場合は0を返す(return 0;)のが慣習となっています。</p>
    </section>
    <section>
        <h2>main関数の書き方</h2>
        <p>main関数ですが、ANCI-C規格で書き方が決まっています。(非フリースタンディング環境の場合)</p>
        <pre class="brush: cpp;">int main(void);
int main(int argc, char* argv[]);
int main()</pre>
        <p>1行目は引数を無視する書き方で、2行目は引数(関数の解説の章で解説します)を受け取るときの書き方、3行目はC++のmain関数の引数を受け取らない書き方となり、C99でも認められます。</p>
        <p>というわけでmain関数は上記何れかの書き方で書きましょう、というお話です。個人的にはちゃんとvoidと書きたい派です。</p>
        <p>まちがっても</p>
        <pre class="brush: cpp;">main();
void main(void);</pre>
        <p>などとしてはいけません(前者は古いCの記法、後者は頭がおかしい書き方)。</p>
    </section>
    <section>
        <h2>コメントの書き方</h2>
        <p>今はこんなに短いプログラムですから、必要性は薄いですが、もっと大規模に慣ればなるほど、ソースコードにメモを書きたくなります。すでにさらっと使っていますが、書き方は2通りあります。</p>
        <pre class="brush: cpp;">/*これは行をまたがって使えるコメント*/
//これはその行の終わりまでコメントになる</pre>
        <p>2行目がANCI-C認められたのはC99からなんですが、ほとんどのコンパイラーが対応してましたからどんどんつかって構いません。</p>
        <p>注意点ですが、一行目の書き方のコメントはネスト（入れ子）にできません</p>
        <pre class="brush: cpp;">/*これはコメント
/*ここもコメントだけど*/
ここはコメントじゃない*/</pre>
        <p>稀によくあるミスなので注意です。だから私はコメントを書くときは基本的に2行目のいわゆる行コメントを使うのをおすすめします。</p>
    </section>
    <section>
        <h2>変数と代入</h2>
        <p>プログラミング言語で必ずあるものといえば、真っ先に変数が上がるでしょう。変数とは処理途中のデータ（数字など）を保管しておく箱(オブジェクト)のようなものです。</p>
        <pre class="brush: cpp;">int a;
a = 10;
int numof_allocated_array_at_a_time = 15;
char ch = getchar();</pre>
        <p>1行目では変数を宣言し定義しています。宣言は「こんな変数があるよ」とコンパイラに教える作業で、定義は「ここで変数を確保するよ」とコンパイラに教えることです。<br>
        定義して初めてメモリ上に実体を持ち、変数を使えるようになるわけです。が、とりあえずヘッダーファイルを分けるようなことになるまでは、宣言も定義も同じと考えていいです。<br>
        まとめると、メモリ上に変数を保管する場所を確保し、場所に名前をつけた、という状態です。</p>
        <p>2行目は1行目で定義した変数aに10という値を代入しています。変数aは初めてここで使うのでこれは初期化作業とも言います。</p>
        <dl>
            <dt>代入</dt>
            <dd>
                数学の代入とは少し違います。2行目の場合はaに10という値を記憶する、という意味になります。ここでつまずくとプログラミングができなくなるので、しっかり抑えてください。<br>
                なお、多くの言語で代入は「=」ですが、R言語のように「&lt;-」を用いる言語もあります。<br>
                <div>
                    <pre class="brush: plain;" title="R言語">x &lt;- 123</pre>
                </div>
            </dd>
            <dt>初期化</dt>
            <dd>
                初期化、という言葉はかなり多くの人が誤解しています。0を代入することを初期化、と考える人が後を絶ちません。<br>
                1行目で変数を宣言し定義しましたが、この状態ではaにどんな値が入っているかは不定です。<br>
                2行目のように、プログラマがその変数に何が入っているかわかるようにすることを初期化といいます。<br>
                ポインタの話が出てこない限りは、とりあえず定義した後初めて値を代入すれば、初期化している、と思って構いません。<br>
                ポインタが絡んだ時のことは、その時にゆっくり解説します。
            </dd>
        </dl>
        <p>1行目でメモリーを確保し、その領域にお名前（識別名）をつけて、2行目でその領域に値を書き込んだ、といったほうがわかりやすい・・・のかな？</p>
        <p>1行目と2行目をまとめて書いたのが3行目です。4行目のように関数の戻り値を代入することもできます（関数については後述）</p>
    </section>

    <section>
        <h2>変数の型</h2>
        <p>C/C++言語はとくに型にうるさい言語として知られています。(JavaScriptやperlなど型を明示できない言語もある)。C++なんて型なしではやっていけません。</p>
        <p>じゃあその「型」ってなんでしょうか？「型」とはコンパイラに変数をどういう風にメモリー上に配置したらいいのか教えるものです。</p>
        <table>
            <colgroup style="width: 32px;"></colgroup>
            <colgroup style="width: 99px;"></colgroup>
            <colgroup style="width: 85px;"></colgroup>
            <colgroup style="width: 95px;"></colgroup>
            <colgroup style="width: 95px;"></colgroup>
            <colgroup style="width: 120px;"></colgroup>
            <tr>
                <th>基本型名</th>
                <th>整数型/浮動小数点型</th>
                <th>型の大きさ</th>
                <th>signedの最大値を求めるマクロ</th>
                <th>signedの(実数の)最小値を求めるマクロ</th>
                <th>unsignedの最大値を求めるマクロ</th>
                <th>使用例</th>
            </tr>
            <tr>
                <td>void</td>
                <td>不定</td>
                <td>不定</td>
                <td>不定</td>
                <td>存在しない</td>
                <td>存在しない</td>
                <td>ほぼ例外なく関数かポインタとともに用いるので省略</td>
            </tr>
            <tr>
                <td>bool型(C99,C++)</td>
                <td>論理型</td>
                <td>不定</td>
                <td>存在しない</td>
                <td>存在しない</td>
                <td>存在しない</td>
                <td><pre class="brush: cpp; gutter:false;">bool is_alphabet = true;</pre></td>
            </tr>
            <tr>
                <td>char</td>
                <td>整数型</td>
                <td>1byte</td>
                <td>SCHAR_MAX</td>
                <td>SCHAR_MIN</td>
                <td>UCHAR_MAX</td>
                <td><pre class="brush: cpp; gutter:false;">char delim = ',';</pre></td>
            </tr>
            <tr>
                <td>short(short int)</td>
                <td>整数型</td>
                <td>不定</td>
                <td>SHRT_MAX</td>
                <td>SHRT_MIN</td>
                <td>USHRT_MAX</td>
                <td><pre class="brush: cpp; gutter:false;">short rect_x = 320;</pre></td>
            </tr>
            <tr>
                <td>int</td>
                <td>整数型</td>
                <td>不定</td>
                <td>INT_MAX</td>
                <td>INT_MIN</td>
                <td>UINT_MAX</td>
                <td><pre class="brush: cpp; gutter:false;">int a = 3;</pre></td>
            </tr>
            <tr>
                <td>long(long int)</td>
                <td>整数型</td>
                <td>不定</td>
                <td>LONG_MAX</td>
                <td>LONG_MIN</td>
                <td>ULONG_MAX</td>
                <td><pre class="brush: cpp; gutter:false;">long size = 217;</pre></td>
            </tr>
            <tr>
                <td>long long</td>
                <td>整数型</td>
                <td>不定</td>
                <td>LLONG_MAX</td>
                <td>LLONG_MIN</td>
                <td>ULLONG_MAX</td>
                <td><pre class="brush: cpp; gutter:false;">long long size = 217;</pre></td>
            </tr>
            <tr>
                <td>float</td>
                <td>浮動小数点型</td>
                <td>不定</td>
                <td>FLT_MAX</td>
                <td>-FLT_MAX</td>
                <td>そんなものはない</td>
                <td><pre class="brush: cpp; gutter:false;">long long size = 217;</pre></td>
            </tr>
            <tr>
                <td>double</td>
                <td>浮動小数点型</td>
                <td>不定</td>
                <td>DBL_MAX</td>
                <td>-DBL_MAX</td>
                <td>そんなものはない</td>
                <td><pre class="brush: cpp; gutter:false;">long long size = 217;</pre></td>
            </tr>
        </table>
        <p>FLT_MAXって「魔法科高校の劣等生」の「<a href="http://www49.atwiki.jp/mahouka/pages/18.html">four leaves technology</a>」みたいでかっこいい！・・・話がそれた。<br>
        以上にc言語(c99)の基本型を上げてみた。各型によってメモリー上での大きさ（表せる値の範囲）や表せるものが違う。</p>
        <p>INT_MAXとかマクロとかって何？ってなると思うが、そう遠くなくお世話になるだろうから載せておく。解説は後ほど。</p>
        <section class="description_detile">
            <h3>ちと難しい話</h3>
            <p>C言語で型の大きさについての規定はほとんどなく、</p>
            <ul>
                <li>char型は1バイト(8ビットとは言っていない)</li>
                <li>型の大きさは、short <= int <= long <= long long　である。</li>
                <li>int型は -32767～+32767 の範囲が扱える</li>
            </ul>
            <p>程度しかない。小数点型に関しては特に規定はないが、事実上IEEE 754に従うので、（今どき従わない非フリースタンディング環境なんてあるのかね？）浮動小数点型についてはIEEE 754を参照すると良い。</p>
        </section>
        <p>まあ、ほとんどcharかdoubleかintしか使わない。ほんと。</p>
        <section class="common_misconception">
            <h3>よくある誤解</h3>
            <ul>
                <li>
                    char型は8bitだ<br>
                    →誤り。1byteと定められているだけで、1byte=8bitとは限らない。（確かに殆どの場合でchar型は8bitだけど）
                </li>
                <li>
                    1byte=8bitのとき、signed charは-128～127まで表せる<br>
                    →誤り。トラップ表現があることがあるので-127～-127までとなる（殆どの場合でトラップ表現を考慮する必要はないが）<br>
                    参考サイト:<a href="http://www.kijineko.co.jp/node/722">http://www.kijineko.co.jp/node/722</a>
                </li>
                <li>
                    int型は4byteである<br>
                    →誤り。2byteの時代もあったし、8byteの処理系も存在する。
                </li>
                <li>
                    float型のほうがdouble型より演算が速い<br>
                    →デマ。double型の演算器がない時代のお話。今はどちらでも等速。<br>
                    下記のコードで実験できる。いろんなコンパイルオプションで試してみよう。makeファイルとかslnファイルは<br>
                    <a href="https://github.com/yumetodo/2015_C_Textbook/tree/gh-pages/src/double_vs_float">https://github.com/yumetodo/2015_C_Textbook/tree/gh-pages/src/double_vs_float</a><br>
                    <script src="http://gist-it.appspot.com/github/yumetodo/2015_C_Textbook/blob/gh-pages/src/double_vs_float/double_vs_float/Source.cpp"></script>
                </li>
            </ul>
        </section>
        <section class="technique">
            <h3>コーディングの作法</h3>
            <p>厳密に型の大きさが定まっている必要が出ることは少なく、boolかcharかdoubleかintしか出番はないはず、それ以外を選択しようとしているなら、本当に必要か考えなおそう。</p>
        </section>
    </section>

    <section>
        <h2>signedとunsigned</h2>
        <p>既にちらっと書いてますが、整数型にはsignedとunsignedがあります（浮動小数点型にunsignedはない）。<br>
        御存知の通り、PCと言うのはすべてのデータを2進数で表しています。この2進数の一桁をbitと言うわけですが、<br>
        1bitを使って正の数か負の数かわかるようにしているのがsigned、すべて正の数とみなすのがunsignedになります。<br>
        正の数か負の数かのフラグを使わない分、unsignedの最大値はsignedの最大値のほぼ2倍になります。</p>
        <p>
            例：1byte=8bit,int型の大きさ(sizeof(int))を4byteと仮定すると、<br>
            INT_MAX:    2147483647<br>
            UINT_MAX:   4294967295
        </p>
        <p>char型以外では、signedやunsignedを省略するとsignedとして扱われます。char型の場合は処理系定義となります(VCのデフォルトはsigned)。</p>
        <pre class="brush: cpp;">int tmp = 5;
signed int tmp = 5;
unsigned int tmp = 5;
char temp = 6;
signed char temp = 6;
unsigned char temp = 6</pre>
        <p>1行目と2行目は同値。4行目と5行目が同値である保証はないし、だからといって4行目と6行目が同値である保証もない（処理系定義）</p>
    </section>

    <section>
        <h2>typedef</h2>
        <p>C/C++にはtypedefという便利な機能があります。さっそく使ってみましょう。</p>
        <pre class="brush: cpp;">typedef unsigned long DWORD;
typedef DWORD COLORREF;
unsigned long window_head = 0x00FFCCFF;
COLORREF window_head = 0x00FFCCFF;</pre>
        <p>typedefとは、<b>"すでにある"</b>型に別名をつける機能です。<br>
        1行目ではunsigned long型にDWORD型という別名をつけています。<br>
        2行目ではDWORD型にCOLORREF型という別名をつけています。</p>
        <p>
            こんな風に別名を付けて何がありがたいかというと、型名を調べるだけでそのデータの格納方法がわかるということです。<br>
            3行目では何をしているのかさっぱりですが、4行目を見るとなんか色が関係することをやってるんだな、と察せます。<br>
            さらに「COLORREF」でぐぐれば、その詳細もわかります。<br>
            <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd183449%28v=vs.85%29.aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/dd183449%28v=vs.85%29.aspx</a><br>
            <q>When specifying an explicit RGB color, the COLORREF value has the following hexadecimal form:0x00bbggrr</q><br>
            ちなみに1行目と2行目はいずれもWindef.hで定義されているものの引用です。Win32APIに触りたいと思っている方、よく覚えておきましょう。かならすお世話になるでしょう。
        </p>
        <section class="technique">
            <h3>コーディングの作法</h3>
            <p>char型は整数型ですが、主に文字を扱うのに使うことが多い型です。文字以外のデータを扱うのにchar型を使うことは、コードの可読性を下げます。</p>
            <pre class="brush: cpp;">typedef unsigned char myuint8_t;
typedef signed char myint8_t;</pre>
            のようにtypedefして使うようにしましょう。
        </section>
    </section>

    <section>
        <h2>整数リテラル</h2>
        <pre class="brush: cpp;">unsigned int len = 20;</pre>
        <p>のように、何気なく数値を書いていますが、この数値は「リテラル」と呼ばれます。どう見ても小数ではないのでこれは「整数リテラル」ですね。</p>
        <p>
            なお、浮動小数点リテラルについては<br>
            C++11の文法と機能(C++11: Syntax and Feature)<br>
            <a href="http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#lex.fcon">http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#lex.fcon</a><br>
            に投げます。
        </p>
        <dl>
            <dt>2進数的記法(C++14,VisualStudio2013は未対応,VisualStudio2015は対応)</dt>
            <dd>
                <pre class="brush: cpp;">int a = 0b11;// 10進数では、3
int d = 0B1011 ;// 10進数では、11</pre>
                このように「0b」または「0B」のあとに数字を書きます。
            </dd>
            <dt>8進数的記法</dt>
            <dd>
                <pre class="brush: cpp; gutter:false;">int e = 01234;// 10進数では、668</pre>
                このように「0」のあとに数字を書きます。<b>8進数リテラルは、10進数と区別しにくいので、気をつける必要があります。</b>
            </dd>
            <dt>10進数的記法</dt>
            <dd><pre class="brush: cpp; gutter:false;">int t = 1234;</pre></dd>
            <dt>16進数的記法</dt>
            <dd>
                <pre class="brush: cpp; gutter:false;">int x = 0x1234 ;// 10進数では、4660</pre>
                このように「0x」のあとに数字を書きます。
            </dd>
        </dl>
        <p>なにが言いたいかというと、<b>うっかりして0から数字を書くな</b>よ！ということです。</p>
    </section>
    <section>
        <h2>const</h2>
        <p>ある変数をその後で変更する予定がないときはconstをつけるようにするべきです。constは変数を「Read-Only」にします。</p>
        <pre class="brush: cpp;">const unsigned int len = 20;
len = 21;//エラー</pre>
        <p>constをつけるときは定義と初期化は同時である必要があります。だって「Read-Only」だもん、後から変更できないんだから初期化も一緒にやらないとダメだよね。</p>
        <p>逆に言うと定義と初期化を同時に行うときは殆どの場合constをつけるべき場面です。</p>
        <p>注意になりますが、constは「定数」を作るものではありません、あくまで「Read-Only」にするものです。その違いはポインタのところで解説します。</p>
    </section>

    <section>
        <h2>自動変数の生存期間とスコープ</h2>
        <p>自動変数ってなんなんだってばよっ！となってると思いますが、「いままで出てきたような」変数です。ということはそうでない変数があることくらいは「お察しください」。</p>
        <p>スコープとはなにか、については見てもらったほうが速いと思います。</p>
        <pre class="brush: cpp;">{
    int a = 10;
    printf("%d\n", a);
}
printf("%d\n", a);//エラー
</pre>
        <p>ずばり{}がスコープです。え？main関数を書いた時に見た？はい、それもスコープです。詳細は関数とはなにかのところで説明します。</p>
        <p>スコープの中で確保された変数はスコープの外にでるときに開放されます。消えてなくなるわけです。よって5行目はエラーになります。</p>
        <p>printf関数を使うのは初めてなので補足します、とりあえず今はこうすると整数を表示できるんだな、と思っておいてくだい。浮動小数点型だと%dじゃなくて%fだったりlong型だと%ldだったりするわけですが。</p>
    </section>
    <section>
        <h2>C++11の型推論機能</h2>
        <p>ちょっとC言語を離れてC++を見ていきます。今は型が短いのでいいですが、今に</p>
        <pre class="brush: cpp;">vector&lt;string&gt;::iterator it;
map&lt;int,list&lt;string&gt;&gt;::iterator i</pre>
        <p>とか使い出します。こんなに長ったらく書くのはめんdいですし、タイピングミスしやすかったり、コードが見づらくなったりと、3拍子揃って書きたくないです。</p>
        <p>そこでauto型の出番です。</p>
        <pre class="brush: cpp;">unsigned int x = 10;
auto l = x;</pre>
        <p>とかすると変数lの型はint型になります。便利だね。なお、C++03まではautoは別の意味で使われていたので注意です。</p>
    </section>

    <section>
        <h2>四則演算</h2>
        <p>やっぱり計算出来ないとプログラミングは始まりません。というわけでまずは四則演算。</p>
        <pre class="brush: cpp;">int i = 0, delay_time;
//中略
i = i + 1;
double time = 8.5 - 2.1;
double cure = 1.5 * time;
double damage = cure / 10;
unsigned int temp1 = delay_time / 60;
tm_sec += delay_time % 60;
i += 1;
cure -= 10;
i++;
++i;
i--;
--i;</pre>
        <p>3行目から7行目が四則演算ですね。6行目の割り算は整数精度で行われ、小数点以下は0に近い方向に切り捨てられることを忘れないで下さい。</p>
        <p>8行目は割り算の余りを求めるものです。これは整数精度の時のみ使えます。もし浮動小数点型で割り算のあまりを求めたいときは、math.hのfmod関数を使いましょう。</p>
        <p>9行目は2行目の略記です。10行目のように引き算などほかの演算記号も同じように使えます。</p>
        <p>11行目と12行目はインクリメント演算子、13行目と14行目はデクリメント演算子と呼ばれます。1増やしたり1減らしたりする処理を簡便に書くことができます。</p>
        <table>
            <tr> <th>演算</th><th>演算子</th><th>例</th><th>意味</th> </tr>
            <tr> <td rowspan="2">インクリメント</td><td rowspan="2" class="Cent">++</td><td>a++</td><td>a に 1 を加える（後置演算）</td> </tr>
            <tr> <td>++a</td><td>a に 1 を加える（前置演算）</td> </tr>
            <tr> <td rowspan="2">デクリメント</td><td rowspan="2" class="Cent">--</td><td>a--</td><td>a から 1 を引く（後置演算）</td> </tr>
            <tr> <td>--a</td><td>a から 1 を引く（前置演算）</td> </tr>
        </table>
        <p>使用上の注意です。下のコードを見てくだい。</p>
        <script src="http://gist-it.appspot.com/github/yumetodo/2015_C_Textbook/blob/gh-pages/src/increment_decrement.c"></script>
        <p>インクリメント・デクリメント演算子は前置と後置で意味が変わるので注意です。私は覚えるのがめんdいので、後置しか使わない派です。</p>
    </section>

    <section>
        <h2>暗黙の型変換とキャスト</h2>
        <p>ここまでの例ではすべて計算するものの型は揃っていました。では違う場合はどうなるでしょう？</p>
        <pre class="brush: cpp;">const int a = 10;
const double b = 3;
auto ans = a / b;
int ans2 = ans;
auto ans3 = (int)ans;</pre>
        <p>変数ansの型はdouble、ansには3.3333333(以下略)が入ります。</p>
        <p>一方でans2の型はint、ans2には3が入ります。</p>
        <p>また3行目のように型を明示することもできます。これを「キャスト」といいます。ans3の型はint型になります。</p>
        <dl>
            <dt>式の中で行われる変換</dt>
            <dd>
                優先順位の高い型に変換されます。優先順位は<br>
                <q>bool &lt; char &lt; short &lt; int &lt; long &lt; long long &lt; float &lt; double</q><br>
                です。
            </dd>
            <dt>代入時の変換</dt>
            <dd>左辺の型と右辺の型が異なっている場合は、左辺の型に変換します。</dd>
            <dt>キャスト時の変換</dt>
            <dd>有無をいわさずに指定した型に変換されます。</dd>
        </dl>
        <p>この法則にしたがって解釈すると、3行目は、aの型はint、bの型はdoubleなのでaがdouble型に変換され(式の中で行われる変換)、double型同士の計算となります。<br>
        また4行目は変数ansの型はdoubleですが、左辺のans2の型がintなのでint型に変換されます(代入時の変換)。</p>
        <p>このことを利用して割り算の余り(surplus)を求めてみましょう。</p>
        <pre class="brush: cpp;">const double input = 23;
const int divisor = 7;
const int temp = (int)input / divisor;
const double surplus = input - (divisor * temp);</pre>
        <p>inputをキャストする必要があるのか？と怒られそうですが、べつに整数精度の結果で事足るのでキャストしました。</p>
        <p>よくキャストを「ある型とみなす」と説明する人が居ますが、誤りです。bitの並びが変わることもあることからわかるように、実際に変換されます。</p>
        <section class="technique">
            <h3>コーディングの作法</h3>
            <p>C言語のキャストは、非常に強力で、どんな型にでも変換ができます。ゆえにしてはいけない型変換もできてしまいます。</p>
            <p>そこでC++ではキャストが4種類にわかれました。</p>
            <table>
                <tbody>
                    <tr><th> 名称 </th><th> 説明 </th><th> 使用 </th></tr>
                    <tr><td>dynamic_cast</td><td> 基本クラスから派生クラスへのキャスト</td><td>使用するべきではない</td></tr>
                    <tr><td>const_cast</td><td> const を外すキャスト</td><td>使用するべきではない</td></tr>
                    <tr><td>static_cast</td><td> double から int など暗黙の変換のあるキャスト </td><td>使用可</td></tr>
                    <tr><td>reinterpret_cast</td><td> double * から long long などの無理やりキャスト </td><td>なるべく使用しない</td></tr>
                </tbody>
            </table>
            <p>
                詳細な説明は<br>
                キャスト | プログラマーズ雑記帳<br>
                <a href="http://yohshiy.blog.fc2.com/blog-category-9.html">http://yohshiy.blog.fc2.com/blog-category-9.html</a><br>
                に譲りますが、Cのキャストは理由がない限り使わず、C++のstatic_castを使用しましょう。
            </p>
            <pre class="brush: cpp;">const int temp = static_cast&lt;int&gt;(input) / divisor;</pre>
            <p>もっとも、まともなコーディングをしていれば、malloc,calloc,realloc関数以外でキャストを使う場面はないはずです。<br>
            もしあなたがキャストを使おうとしているならば、それはあなたが寝ぼけているのか、ライブラリ作者がうっかりしている、ということになります。<br>
            後者なら、作者に文句を言いましょう。(実際私はDxLibraryの作者に色の扱いについて文句を言って、Ver 3.13eで修正してもらいました)</p>
            <p>signedとunsignedの変換はとくに理由のない限りしないようにしましょう。</p>
        </section>
    </section>

    <section>
        <h2>promotionsとconversions</h2>
        <p>型変換、と一口に言っても2つあり、promotionsとconversionsとそれぞれ呼ばれます。</p>
        <p>
            promotionsがなにか、については<br>
            C++11の文法と機能(C++11: Syntax and Feature)<br>
            <a href="http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#conv.prom">http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#conv.prom</a><br>
            に丸投げするとして、promotionsでなければconversionsである(そりゃそーだ)。
        </p>
        <p>conversionsは一般に危険をはらんでいます。何故かというと、変換元の数値を変換先の型で表せないかもしれないからです。</p>
        <p>unsigned charが8ビット、unsigned intが16ビットと仮定して実例を上げてみましょう。</p>
        <pre class="brush: cpp;">int main(void){
    unsigned int ui = 1234 ;
    unsigned char uc = ui ; // 210
}</pre>
        <p>この場合、unsigned int型は、16ビット、uiの値は、2進数で表すと0000010011010010になります。unsigned char型は8ビット。つまり、この場合の対応する下位桁の値は、2進数で11010010（uiの下位8ビット）です。よって、ucは、10進数で210となります。 </p>
        <p>しかし、そもそも型変換でオーバーフローやアンダーフローを起こさないようにコーディングするべきでしょう。</p>
    </section>

    <section>
        <h2>stdint.h/cstdint</h2>
        <p>先ほど「文字以外の目的でchar型を使うときはtypedefして使うようにしましょう」と言いましたが、毎回typedefするのはめんdいです。</p>
        <p>また、先程から散々言ってるように、C/C++では型の大きさについて、明確な規定はほぼありません。これでは厳密に何bitかを使いたいとき(HTTP通信など)に困ってしまいます。</p>
        <p>そこでstdint.h/cstdintの出番です。これはC99/C++11で追加された標準ライブラリで、主に以下の型が使えます。</p>
        <blockquote>int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t, int64_t, uint64_t</blockquote>
        <p>これらは厳密に型の大きさが決まっています。(ゆえにすべての処理系で実装されているわけではない)</p>
        <pre class="brush: cpp;">uint8_t color_r = 187;
int64_t receive_timestamp;// 受信タイムスタンプ
//中略
int64_t sum = sum1 + sum2;</pre>
        <p>よく使うのはこの2つかな？あるって知ってると何かと便利。</p>
    </section>
    <section>
        <h2>ビット演算</h2>
        <p>ビッド演算とは、各bitに対して論理演算を行うことを指します。なお、特にシフト演算では、<b>変数はunsigned、または正の整数である必要があり</b>ます。負の数の場合動作は実装定義となります。</p>
        <p>まあ、そもそもsignedな整数にビット演算をするべきではありません。</p>
        <section>
            <h3>左シフト</h3>
            <pre class="brush: cpp;">uint32_t si_a = 5;//101
const uint32_t si_b = 4;
const uint32_t re_si = si_a &lt;&lt; si_b;//80:1010000</pre>
            <p>1つ左シフトするごとに、2をかけているのと同じ効果が得られる。この場合は2<sup>4</sup> = 16倍していることになる。</p>
            <p>かならず以下の点をコーディング時に確認して行うこと。</p>
            <ul>
                <li>
                    オーバーフローしないか<br>
                    左シフトの結果がその型の最大値を超えるようなことがあったらだめ、ということ。だからこれはだめ<br>
                    <pre class="brush: cpp; gutter:false;">unsigned int re = UINT_MAX << 1;</pre>
                </li>
                <li>
                    右オペランドが格上げ後の左オペランドの精度以下<br>
                    「オーバーフローしないか」ともつながるが、例えば32bit変数を32回以上左シフトしたら必ずオーバーフローする。<br>
                    具体的にはSSE4.2のPOPCNT命令を呼び出すMSVC独自拡張の__popcnt関数ないしmath.hのlog2関数を用い、左オペランドのビット数が右オペランド未満であることを確認する。<br>
                    <pre class="brush: cpp; gutter:false;">const uint32_t re_si = (si_b < __popcnt(UINT_MAX))? si_a &lt;&lt; si_b : 0;</pre>
                </li>
            </ul>
        </section>
        <section>
            <h3>右シフト</h3>
            <pre class="brush: cpp;">uint32_t si_a = 37;//100101
const uint32_t si_b = 4;
const uint32_t re_si = si_a &gt;&gt; si_b;//2:10</pre>
            <p>左シフトと逆の効果が得られる。</p>
            <p>かならず以下の点をコーディング時に確認して行うこと。</p>
            <ul>
                <li>
                    右オペランドが格上げ後の左オペランドの精度以下<br>
                    「オーバーフローしないか」ともつながるが、例えば32bit変数を32回以上左シフトしたら必ずオーバーフローする。<br>
                    具体的にはSSE4.2のPOPCNT命令を呼び出すMSVC独自拡張の__popcnt関数ないしmath.hのlog2関数を用い、左オペランドのビット数が右オペランド未満であることを確認する。<br>
                    <pre class="brush: cpp; gutter:false;">const uint32_t re_si = (si_b < __popcnt(UINT_MAX))? si_a &gt;&gt; si_b : 0;</pre>
                </li>
            </ul>
        </section>
        <section>
            <h2>ビットの論理積</h2>
            <pre class="brush: cpp;">const uint32_t a = 0b10110;//22
const uint32_t b = 0b11010;//26
const uint32_t re = a &amp; b;//18:0b10010</pre>
            <p>各bitにAND演算をします。</p>
            <img alt="AND" src="http://upload.wikimedia.org/wikipedia/ja/7/7b/Venn-Diagram-AND.png" class="thumbimage" data-file-width="186" data-file-height="110" height="110" width="186">
            <table>
                <tr>
                    <th>AND(&amp;)</th><th>1</th><th>0</th>
                </tr>
                <tr>
                    <th>1</th><td>1</td><td>0</td>
                </tr>
                <tr>
                    <th>0</th><td>0</td><td>0</td>
                </tr>
            </table>
            <p>結果はこの表に従います。</p>
        </section>
        <section>
            <h2>ビットの論理和</h2>
            <pre class="brush: cpp;">const uint32_t a = 0b10110;//22
const uint32_t b = 0b11010;//26
const uint32_t re = a | b;//30:0b11110</pre>
            <p>各bitにOR演算をします。</p>
            <img alt="OR" src="http://upload.wikimedia.org/wikipedia/ja/5/5e/Venn-Diagram-OR.png" class="thumbimage" data-file-width="186" data-file-height="110" height="110" width="186">
            <table>
                <tr>
                    <th>OR(|)</th><th>1</th><th>0</th>
                </tr>
                <tr>
                    <th>1</th><td>1</td><td>1</td>
                </tr>
                <tr>
                    <th>0</th><td>1</td><td>0</td>
                </tr>
            </table>
            <p>結果はこの表に従います。</p>
        </section>
        <section>
            <h2>ビットの排他論理和</h2>
            <pre class="brush: cpp;">const uint32_t a = 0b10110;//22
const uint32_t b = 0b11010;//26
const uint32_t re = a ^ b;//12:0b1100</pre>
            <p>各bitにXOR演算をします。</p>
            <img alt="XOR" src="http:////upload.wikimedia.org/wikipedia/ja/6/6b/Venn-Diagram-XOR.png" class="thumbimage" data-file-width="186" data-file-height="110" height="110" width="186">
            <table>
                <tr>
                    <th>XOR(|)</th><th>1</th><th>0</th>
                </tr>
                <tr>
                    <th>1</th><td>0</td><td>1</td>
                </tr>
                <tr>
                    <th>0</th><td>1</td><td>0</td>
                </tr>
            </table>
            <p>結果はこの表に従います。</p>
        </section>
        <section>
            <h2>ビットの反転</h2>
            <pre class="brush: cpp;">const uint8_t a = 0b10110;//22
const uint8_t re = ~a;//233:0b11101001</pre>
            <p>各ビットにNOT演算をします。1の補数をとる、ともいいます。</p>
        </section>
    </section>

    <section>
        <h2>関数とは</h2>
        <p>既にそこかしこで出てますが、改めて。関数とは、処理の集合です。C/C++では、すべてのプログラムは必ず1つ以上の関数が含まれています。<br>
        これまで見てきたmain関数も関数の一つです。C言語においてとにかく大事なものです。そのくせ独習Cの説明は十分とは言えません、あれで説明してるつもりなんですかね。</p>
        <p>関数の一般的な書き方は</p>
        <pre class="brush: plain;">[戻り値の型] ([関数呼び出し規約]) [関数名](仮引数リスト){
    //処理
}</pre>
        <p>です。戻り値の型がvoid以外の時は、必ず戻り値を返さなければなりません。</p>
        <pre class="brush: cpp;">//これは誤り
int do_something(void){
    //do something
}
//これは正しい
int do_something2(void){
    //do something
    return 0;
}</pre>
        <p>関数の呼び出し規約は省略することが多いが(その場合__cdeclになる)、Win32APIを使うならお世話になるだろう。後述する。</p>
        <p>実際に関数を作るときには「プロトタイプ宣言」という物を書くことになる。書き方を立方体の体積を求める関数を例に説明する。</p>
        <script src="http://gist-it.appspot.com/github/yumetodo/2015_C_Textbook/blob/gh-pages/src/call_function.cpp"></script>
        <p>
            2行目が関数のプロトタイプ宣言と呼ばれるものだ。戻り値の型、(呼び出し規約)、関数名、仮引数リストを書く。<br>
            なお、その関数を使用するまでに関数が宣言されている必要があるため、原則として#define文やtypedefや定数宣言のあとにまとめて書いておくこと。
        </p>
        <p>このcalc_volume関数が定義されるのは、10～13行目の部分だ。ここで関数の実際の処理を書く。</p>
        <p>この関数が呼び出される7行目だ。ここで初めて実際に定義に基づいて処理を行う。calc_volume関数内のreturn文にかいたものが変数resultに代入されている。</p>
        <section>
            <h3>C標準ライブラリ</h3>
            <p>C標準ライブラリとは、プログラマーがよく使う機能をひとまとめにしてC言語自体が提供している関数群のことです。</p>
            <p>
                代表的なものとしては、puts, getcahr, fgets, time, clock, printf, sprintf, scanf, strcomp, memcpy, malloc, callocなどの関数でしょうか。<br>
                これらはいくつかのヘッダーファイルをincludeすることで使えます。<br>
                例えば、printf関数はstdio.h, calloc関数はstdlib.h, clock関数はtime.hをincludeすることで使えます。<br>
                includeし忘れると、コンパイラーに「そんな関数知らねーよ」と怒られます。
            </p>
            <p>ここで改めてはじめて書いたコードを見て欲しい。</p>
            <script src="http://gist-it.appspot.com/github/yumetodo/2015_C_Textbook/blob/gh-pages/src/001_arikitari_na_world.c"></script>
            <p>
                puts関数が出てくると思う。これはどういう関数なのだろうか？この関数はC標準ライブラリの関数なので関数名でググってみょう。大概は「関数名 MSDN」で適当な情報がでる。<br>
                <a href="https://msdn.microsoft.com/ja-jp/library/tf52y4t1.aspx">https://msdn.microsoft.com/ja-jp/library/tf52y4t1.aspx</a>
                以下の様な点に着目して見るといい。
            </p>
            <ul>
                <li>
                    プロトタイプ宣言は？<br>
                    →<pre class="brush: cpp;">int puts(const char *str);</pre>
                </li>
                <li>
                    戻り値の型は？<br>
                    →int型
                </li>
                <li>
                    どんな戻り値が帰ってくるの？<br>
                    →エラー時はEOF(-1にdefineされています)、正常なときは0より大きい数
                </li>
                <li>
                    errnoには何かセットされるの？<br>
                    →エラー時にセットされる
                </li>
                <li>
                    引数の型は？<br>
                    →char*型(すみません、ポインタについては後ほど。ここでは文字の集合を要求しています)
                </li>
                <li>
                    引数に指定するものは？<br>
                    →標準出力に出力したい文字列（標準出力についても後ほど。コンソール画面と思っていてとりあえずは構いません。）
                </li>
                <li>
                    includeしないといけないヘッダーファイルは？<br>
                    →stdio.h
                </li>
            </ul>
        </section>
        <section>
            <h2>関数の型</h2>
            <p>宣言、とか定義とかさっきから言ってるところからもう察しているかも知れませんが、関数も変数と同じくオブジェクトなので、メモリー上に実体があり、型も存在します。</p>
            <p>「型」がなにかについては変数のところで説明しましたが、「型」とはコンパイラにオブジェクトをどういう風にメモリー上に配置したらいいのか教えるものなのでした。</p>
            <p>関数になってもなにも変わりません。コンパイラーに</p>
            <ul>
                <li>戻り値の型</li>
                <li>(呼び出し規約)</li>
                <li>仮引数の型</li>
            </ul>
            <p>を教えます。だからcalc_volume関数の型は、「double(double, double, double)」型です。これが分かれば、コンパイラは関数を呼び出すアセンブリコードを書いてくれます。<br>
            このことは関数ポインタのところで大事になるので、覚えておいてくだい。</p>
        </section>
        <section>
            <h2>関数を作って使ってみよう</h2>
            <p>細かい理屈はひとまず置いておいて、まあ関数を作ってみましょう。オーバーフロー対策はif文を教えてないのでまだいいです。</p>
            <article>
                <h3>練習問題</h3>
                <ol>
                    <li>
                        <div>
                            <p>main関数の他に以下の機能を持つ関数を書き、main関数から呼び出せ。</p>
                            <dl>
                                <dt>機能</dt>
                                <dd>puts関数を呼び出し、「関数arikitari_na_kannsuuが実行されました」と表示する</dd>
                                <dt>プロトタイプ</dt>
                                <dd><pre class="brush: cpp; gutter:false;">void arikitari_na_kannsuu(void);</pre></dd>
                            </dl>
                        </div>
                    </li>
                    <li>
                        <div>
                            <p>以下の機能を持つ関数を作成し、main関数から呼び出し、戻り値をpriintf関数で表示せよ。</p>
                            <dl>
                                <dt>機能</dt>
                                <dd>2つの引数を受け取り、その和を返す。</dd>
                                <dt>プロトタイプ</dt>
                                <dd><pre class="brush: cpp; gutter:false;">uint64_t add(uint64_t a, uint64_t b);</pre></dd>
                                <dt>ヒント</dt>
                                <dd>
                                    main関数側はこう書けばいい。
                                    <pre class="brush: cpp; gutter:false;">printf("%ld", add(7, 2));</pre>
                                    当たり前だが、stdint.hをincludeしなければならない。
                                </dd>
                            </dl>
                        </div>
                    </li>
                    <li>
                        <div>
                            <p>以下の機能を持つ関数を作成し、main関数から呼び出し、戻り値をpriintf関数で表示せよ。</p>
                            <dl>
                                <dt>機能</dt>
                                <dd>COLORREF型の引数を受け取り、G(緑色)の値を返す。</dd>
                                <dt>プロトタイプ</dt>
                                <dd><pre class="brush: cpp; gutter:false;">uint8_t myGetGValue(COLORREF color);</pre></dd>
                                <dt>ヒント</dt>
                                <dd>
                                    COLORREF型を使うにはwindows.hを<b>一番先に</b>includeする必要がある。<br>
                                    main関数側はこう書けばいい。
                                    <pre class="brush: cpp;">COLORREF color = RGB(137, 195, 235);//RGBマクロでCOLORREF型の値を作製
printf("%d", myGetRValue(color));</pre>
                                    当たり前だが、stdint.hをincludeしなければならない。<br>
                                    内部の演算は右シフトとAND演算をすれば求められるはず。<br>
                                    COLORREF型については既に説明した。windows.hをincludeすればあそこで書いたtypedefが既にされている。<br>
                                    マクロ GetGValue を用いてはならない。
                                </dd>
                            </dl>
                        </div>
                    </li>
                </ol>
                <p></p>
            </article>
        </section>

        <section>
            <h2>スタック領域</h2>
            <p>
                Ｃで扱うメモリ領域は一般に、プログラム領域、静的領域、スタック領域、ヒープ領域の 4つに大別されます。<br>
                main関数が呼び出される時にある程度広い範囲のメモリーを確保します。この領域をスタック領域、といいます。<br>
                変数をメモリー上に確保して～とか、関数はメモリー上に実体があり～とか言ってましたが、ここのことです。<br>
                自動変数(これまで見てきた変数)や関数の引数、戻り値、リターンアドレスなどはここに記録されます。<br>
                ではどういう風に記録されていくのでしょうか？
            </p>
            <ol>
                <li>main関数が呼ばれるとき、スタック領域を確保する</li>
                <li>引数を後ろから順に書き込む</li>
                <li>復帰情報(リターンアドレスなど)を書き込む</li>
                <li>関数の処理が始まって、変数が確保されたりする</li>
            </ol>
            <p>わかりにくいので図で説明します。</p>
            <img alt="スタック領域" src="./pic/stack_area.png">
            <p>プログラムが呼ばれると(特に定めない限り)main関数が呼ばれます。この時スタック領域が確保されるわけです。そのあとにmain関数の引数やら戻り値の領域やらリターンアドレスが書き込まれます。(図の一番左)</p>
            <p>何が言いたかったか、ですが、単純。関数も変数となんら変わりません！・・・てことです。いやね、これがわからんと関数ポインタが説明できんのよ。</p>
        </section>
    </section>

    <section>
        <h2>main関数の引数って何？</h2>
        <p>先ほどさらっと「引数」という言葉を使いましたが、解説がまだでした。実例を見て行きましょう。</p>
        <script src="http://gist-it.appspot.com/github/yumetodo/2015_C_Textbook/blob/gh-pages/src/002_show_argv.c"></script>
        <p>さて疑問が噴出していることと思いますが気にすることはありません。[i]とかifとかforとかはちゃんと後で説明します。これをコンパイルしてできた002_show_argv.exeを</p>
        <pre class="brush: plain;">002_show_argv.exe arikitari na world!</pre>
        <p>のように実行してみてください。すると</p>
        <pre class="brush: plain;">argv[0]:[任意の場所]\002_show_argv.exe
argv[1]:arikitari
argv[2]:na
argv[3]:world!
</pre>
        <p>のようになったと思います。こんな感じでexeはコマンドライン引数を受け取れるんだなぁと思っていてください。<br>
        これを使ってプログラムにいろいろな値を与えられるわけです。</p>
    </section>

    <section>
        <h2>main関数の戻り値の意味</h2>
        <p>
            最初の方でも書きましたが、main関数はint型で、必ず値を返さなければなりません。<br>
            今までのサンプルコードを見てきた人は、｢main関数は必ず0を返さなければいけないんですか？｣と思ったのではないでしょうか？(むしろ思っててほしいです)<br>
            いいえ、そんなことはありません、下のサンプルを見てください。
        </p>
        <pre class="brush: cpp;">#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;stdlib.h&amp;gt;
#include&amp;lt;limits.h&amp;gt;//in gcc
#include&amp;lt;errno.h&amp;gt;//in gcc
#ifndef _cplusplus
#define nullptr NULL
#endif
int get_integer_num(const int max, const int min){
	//機能：標準入力を数字に変換する。
	//引数：戻り値の最大値,戻り値の最小値
	//戻り値：入力した数字、エラー時は-1,EOFのときはEOF
	char s[100];
	char *endptr;
	if (nullptr == fgets(s, 100, stdin)){
		return INT_MIN;
	}
	if ('\n' == s[0]) return INT_MIN;
	errno = 0;
	const long t = strtol(s, &amp;endptr, 10);
	if (0 != errno || '\n' != *endptr || t &amp;lt; min || max &amp;lt; t)
		return INT_MIN;
	return (int)t;
}
int main(void){
	printf("今の時間帯は？\n1.朝　2.昼　3.夜(まだ寝ない)　4.夜(もう寝る)\n");
	const int time = get_integer_num(4, 1);
	switch (time){
	case 1:
		printf("おはようございます\n");
		break;
	case 2:
		printf("こんにちは\n");
		break;
	case 3:
		printf("こんばんは\n");
		break;
	case 4:
		printf("おやすみなさい\n");
		break;
	default:
		time = -1;
		break;
	}
	return time;
}</pre>
        <p>
            このサンプルコードでは、時間帯を聞いたところで入力された値が返されるようになっています。<br>
            ｢上のint get_integer_numは何？｣って？後で説明するのでここではスルーしてください。<br>
            このように、main関数では必ずしも0を返す必要はありません。この程度のコードなら普通に0返せばいいじゃんと思うかもしれませんが、そんなのは今回どうでもいい話です。
            問題なのはmain関数は0以外の値を返しても大丈夫かどうかなので。<br>
            じゃあメイン関数の戻り値にはどういう意味があるのかって？そのプログラムの内部においては何にも関係ありません。この値はプログラムの外部に影響があります。<br>
            我々が作ったプログラムはどうやって呼ばれるかというと、別の何らかのプログラムが呼び出しています。普通の関数がそうであるように、main関数も例外ではなく、呼び出し元に値を返します。<br>
            この値をどう処理するかは各ＯＳによって異なり、さらにバッチファイルなどから呼び出す場合はその値に対する挙動はプログラマーが決められます。<br>
            細かいことはどうでもいいです。とりあえずここでは、main関数内の値はプログラム内部には影響がないってことだけ覚えておいてください。
        </p>
    </section>

    <section>
        <h2>ソースファイルを分ける</h2>
        <p>一つのファイルですべてのソースコードを書くと、コンパイル時間が増加する要因となり、また見通しの悪いプログラムになりやすい(はい、私です。いっつもファイルを分けるのをめんdいからやらないのは)です。</p>
        <p>
            先に、プロトタイプ宣言はソースコードの冒頭に、と言いましたが、この内外部公開するものはヘッダーファイルに書きます。この他にヘッダーファイルに書くものとしては、共通してincludeするファイルや、公開する構造体定義や列挙型定義などです。<br>
            通常変数やinline関数のプロトタイプ宣言を書くのはいろいろ面倒なので(externすればいいが)、あまりしません。とくに変数を共有しなければならないことは極めて稀だと思います。
            例を見ましょう。
        </p>
        <pre class="brush: cpp;" title="arikitari.h">#ifndef INC_ARIKITARI_H
#define INC_ARIKITARI_H
#if (defined(_MSC_VER) && _MSC_VER > 1000) || defined (__GNUC__) && (__GNUC__ >= 4 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#pragma once
#endif
int get_integer_num(const int max, const int min);
#endif INC_ARIKITARI_H</pre>
        <pre class="brush: cpp;" title="arikitari.c">#include "arikitari.h"
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;limits.h&gt;//in gcc
#include&lt;errno.h&gt;//in gcc
int get_integer_num(const int max, const int min){
    //中略
}</pre>
        <pre class="brush: cpp;" title="main.c">#include "arikitari.h"
#include&lt;stdio.h&gt;
#include&lt;limits.h&gt;
int main(void){
    const int input = get_integer_num(INT_MAX, INT_MIN);
    printf("input=%d", input);
    return 0;
}</pre>
        <p>ヘッダーファイルは必ず関数定義があるファイルと関数使用箇所両方でincludeするようにします。また、ヘッダーファイルの名前は普通関数定義があるファイル名と同じにします。</p>
        <p>何度も言いますが、すべての関数を公開する、ヘッダーファイルで宣言する必要はありません。あくまで他のファイルからも使いたい関数等を公開するわけです。</p>
        <pre class="brush: cpp; first-line: 3;">#if (defined(_MSC_VER) && _MSC_VER > 1000) || defined (__GNUC__) && (__GNUC__ >= 4 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))</pre>
        <p>は、#pragma onceに対応していないコンパイラー(というよりプリプロセッサか)に対応するものです。詳細はプリプロセッサの項目で。</p>
    </section>

    <section>
        <h2>bool型と_BOOL型とBOOL型と</h2>
        <p>
            C++では当初から真と偽を表すbool型が導入され、C言語でもC99でbool型が使えるようになりました。<br>
            C99のbool型は_BOOL型をマクロを使って実装しています（マクロが何かは後ほど）。<br>
            実際に使い方を見ましょう。C++ではstdbool.hのincludeは不要です(無理にincludeしても勝手にincldueを外されます)。
        </p>
        <pre class="brush: cpp;">#include &lt;stdbool.h&gt;
int main(void){
    //前略
    bool no_first_skip = true;
    bool no_dct_decimate = false;
    //後略
    return 0;
}</pre>
        <p>C99/C++のbool型は、真と偽はtrueとfalseに対応し、int型に変換すると1と0になります。それ以外の値を入れられることは保証されていません。</p>
        <p>
            さて、ここまでならなんら問題はなかったのですが、問題はBOOL型です。ここでいうBOOL型はWin32APIのBOOL型です。<br>
            Win32APIのBOOL型は何をキチがえたのか、平気で負の値とかが入っていたりします。それもそのはず、ただ単にint型をtypedefしてBOOL型を作っているからです。<br>
            これにはC言語が真と偽を非0と0に対応づけてきた歴史も関わってきます。<br>
            なにが言いたいかというと、false(FALSE)が0であることは保証されているが、true(TRUE)が1であることは保証されない、ということです。<br>
            うっかりすると足を救われるので注意です。
        </p>
    </section>

    <section>
        <h2>条件文とループ</h2>
        <section>
            <h3>条件文</h3>
            <p>
                前にbit演算のところでAND演算とかOR演算とかやったと思いますが、それをbit単位でなく、変数単位でやるのが条件文です。<br>
                条件文の演算結果は事実上bool型になります。つまり、真と偽は、1と0に対応します。例を見てみましょう。
            </p>
            <pre class="brush: cpp;">int a = 10;
int tmp = (5 == a);//0になる</pre>
            <p>条件文は多くの場合大小比較や同値比較と同時に用いられるので、その演算子をまとめておきましょう。</p>
            <table>
                <tr>
                    <th>演算子</th>
                    <th>意味</th>
                </tr>

                <tr>
                    <td>==</td>
                    <td>等しい</td>
                </tr>
                <tr>
                    <td>!=</td>
                    <td>等しくない</td>
                </tr>
                <tr>
                    <td>&lt;=</td>
                    <td>(左は)(右)以下である</td>
                </tr>
                <tr>
                    <td>&gt;=</td>
                    <td>(右は)(左)以下である</td>
                </tr>
                <tr>
                    <td>&lt;</td>
                    <td>(左は)(右)より小さい</td>
                </tr>
                <tr>
                    <td>&gt;</td>
                    <td>(左は)(右)より大きい</td>
                </tr>
            </table>
            <p>これに加えてAND,OR,NOT演算子があります</p>
            <table>
                <tr>
                    <th>演算子</th>
                    <th>意味</th>
                </tr>
                <tr>
                    <td>&amp;&amp;</td>
                    <td>かつ(AND)</td>
                </tr>
                <tr>
                    <td>||</td>
                    <td>または(OR)</td>
                </tr>
                <tr>
                    <td>!</td>
                    <td>否定(NOT)</td>
                </tr>
            </table>
        </section>
        <section>
            <h2>if文</h2>
            <p>条件式をそれ単体で使うことは、そこまで多くなく、if文やこの後紹介するwhile,for,do-while文と共に用いられます。</p>
            <p>if文はプログラムを組む上で無くてはならないものです。例を見てみましょう。</p>
            <pre class="brush: cpp;">if(条件式)
    //条件式が真の時
else
    //条件式が偽の時</pre>
            <p>この書き方だと処理が一行しか書けません。複数行書くときは{}を使います。<br>
            気をつけて欲しいのですが、{}がなくともスコープがあります。ところで言うまでもないですが、else節はなくても構いません。</p>
            <pre class="brush: cpp;">int first_number, second_number, third_number, max_number, center_number, min_number;
//3つの変数になにか値を代入
if (first_number > second_number){//１番目の数と２番めの数を比較
	max_number = first_number;
	center_number = second_number;
}
else{
	max_number = second_number;
	center_number = first_number;
}
if (third_number > max_number){//３番めの数と上で出した「１番目の数と２番めの数」の大きい方と比較
	min_number = center_number;
	center_number = max_number;
	max_number = third_number;
}
else if(third_number > center_number){//３番めの数と上で出した「１番目の数と２番めの数」の小さい方と比較
	min_number = center_number;
	center_number = third_number;
}
else{//3番目の数が最小の時
	min_number = third_number;
}</pre>
            <p>このようにif文 else if のように連ねて書くことも可能です。</p>
            <pre class="brush: cpp;">if(5 == a)
    int x = 7;
else
    x = 6;//これはだめ
</pre>
            <p>そもそもif文の中で変数を宣言しないようにしましょう。<b>変数を宣言したい、そう思ったら、直ちにその部分を関数化</b>しましょう。</p>
            <section class="technique">
                <h4>コーディングの作法</h4>
                <p>if文では、else節に正常な動作を書くと、多くの場合ですっきり書けます。</p>
                <pre class="brush: cpp;">if(条件文){
    //エラー処理
}
else{
    //正常動作
}</pre>
                <p>大切なのが、正常な動作の時の流れがもっとも簡潔であるように書くことです。</p>
                <p>また、条件式を書く上での注意ですが、同値比較(==)は「=」が2つですが、ついうっかり1つにしてしまいがちです。そこで、このように書くようにしましょう</p>
                <pre class="brush: cpp;">if(5 == a)//正しい書き方
if(a == 5)//これも正しい書き方だが、推奨しない、ミスの元
if(5 = a)//これはコンパイルエラー
if(a = 5)//これはコンパイルエラーにならない、aに代入した後のaが0か否かが判別される</pre>
                <p>constがついた変数や、数値、マクロで定義された値を左側、変数を右側に持っていくようにします。<br>
                こうすることで、書き間違えた時にコンパイルエラーになります。(変更不可能なものに代入しようとしています、など)</p>
                <p>エラー処理等、明確に実行文が1行しかない、と言える時を除き、原則{}はつけましょう。あとで文が増えた時に付け忘れるのを防ぐことができます。</p>
            </section>
        </section>

        <section>
            <h2>3項演算子</h2>
            <p>if文とは一味ちがう書き方です。見てみましょう。</p>
            <pre class="brush: cpp" title="3項演算子を使って書く">const int hoge = 17;
const int isEven = (hoge % 2)? 1324 : 2432;</pre>
            <pre class="brush: cpp;" title="if文で書く">const int hoge = 17;
int isEven;
if(hoge % 2){
    isEven = 1324;
}
else{
    isEven = 2432;
}</pre>
            <p>if文を使って書くより簡単ですし(スコープの問題がない)、代入する変数にconstが付けられます(ワタシ的にはここが美味しい)</p>
            <p>
                この書きかたですが、「一行で」かけるので、後に説明するプリプロセッサマクロでしばしば用いられます。<br>
                ・・・って私は教わったんだけど、マクロにして使ったことってないなぁ。それくらいならinline関数(C++の機能)にしちゃうし。
            </p>
        </section>
        <section>
            <h2>switch文</h2>
            <p>if文が高級な条件分岐文とするならば、switch文は低級な条件分岐文といえますが、最大のメリットは、一度の条件式で複数の分岐が作れることです。</p>
            <pre class="brush: cpp;">char time_when;
//do something
switch (time_when)
{
case 'a':
	puts("朝");
	break;
case 'b':
	puts("昼");
	break;
case 'c':
	puts("夜");
    break;
default:
	break;
}</pre>
            <p>
                switch文には必ず「default:」を書きましょう。<br>
                「case 'c':」とかは「ラベル」といいます。後述するgoto文にも登場するので頭の片隅においておいてください。<br>
                「break;」はswitch文を抜け出すために用います。もし、6行目の「break;」がなかった場合、5行目を実行した後8行目を実行します。つまり必ずしもbreakは必須ではありません。<br>
                switch文を「低級な条件分岐文」と表現したのは、アセンブリコードのjmp命令にそっくりの構文だからです。
            </p>
            <p>このjmp命令にそっくりという性質を活かして</p>
            <pre class="brush: cpp;">send(register short *to, register short *from, register count)
{
	register n = (count + 7) / 8;
	switch(count % 8) {
	case 0:	do {	*to = *from++;
	case 7:		*to = *from++;
	case 6:		*to = *from++;
	case 5:		*to = *from++;
	case 4:		*to = *from++;
	case 3:		*to = *from++;
	case 2:		*to = *from++;
	case 1:		*to = *from++;
		} while(--n > 0);
	}
}</pre>
            <p>なんていう、わけわかめなプログラム(<a href="http://ja.wikipedia.org/wiki/Duff%27s_device">Duff's device</a>というプログラム高速化のための最適化技法)を書いた人が居ますが、やめましょう。</p>
            <p>このswitch文、あとで出てくる列挙型(enum)とものすごく相性がいいです。#defineをわんさか書こうとしているそこのアナタ、enumを使いましょう。</p>
        </section>
        <section>
            <h2>while文</h2>
            <p>プログラミング言語へのループ文の導入は画期的なものでした。while文はC言語におけるもっとも簡単なループ文です。</p>
            <pre class="brush: cpp;">while(継続条件) 実行文;</pre>
            <p>if文と同様、実行文は{}を使って複数行書くことができます。例を見てみましょう。</p>
            <pre class="brush: cpp;">while('\n' != getchar());</pre>
        </section>
        <section>
            <h2>for文</h2>
            <p>はっきり言って、for文のほうがwhile文より使いやすいです。そしてfor文はこのあと説明する配列と殆どの場合一緒に使います。</p>
            <pre class="brush: cpp;">for(初期化文; 継続条件; カウンター等実行文);</pre>
            <pre class="brush: cpp;">for(unsigned int i = 0, sum = 0; i &lt; 10; i++) sum += i;</pre>
            <p>こんな感じ。まあそのうち呼吸をするがごとく登場するので、これ以上は例を上げないでおきます。実用的な例を上げたほうが良いもんね、やっぱり。</p>
        </section>
        <section>
            <h2>do-while文</h2>
            <p>事後評価文とでも言えばいいのでしょうか。whileと違い、一度実行し、それからループするかを判断します。</p>
            <pre class="brush: cpp;">do{
    //実行文
}while(継続条件)</pre>
            <p>これまた多くの場合、ポインターや標準入力とともに使うので実例はその時に。</p>
        </section>
    </section>

    <section>
        <h2>プリプロセッサー</h2>
        <p>
            お待たせしました。ようやくプリプロセッサーのお話です。<br>
            はい、#includeとかなにげに書いてきたものが何なのかわかります。
        </p>
        <ul>
            <li>#include</li>
            <li>#define</li>
            <li>#if/#else</li>
            <li>#ifdef/#ifndef</li>
            <li>#error</li>
            <li>#warning</li>
            <li>
                #pragma
                <ul>
                    <li>#pragma once</li>
                    <li>#pragma comment</li>
                    <li>#pragma ident</li>
                </ul>
            </li>
        </ul>
        <p>
            これだけ種類が有ります。解説するのは#includeと#define、#pragma once、#pragma commentにとどめます。他は<br>
            <a href="http://itref.fc2web.com/c/preprocessor.html">http://itref.fc2web.com/c/preprocessor.html</a><br>
            を参照してください。なお、#if/#else/#ifdef/#ifndefはこれまでもこれからもしれっと使います。
        </p>
        <section>
            <h3>#include</h3>
            <p>.cとか.cppが読み込めないわけではないのですが、ほぼ100%ヘッダーファイルを読み込むのに使います。</p>
            <pre class="brush: cpp;">#include "DxLib.h"
#include &lt;stdio.h&gt;</pre>
            <p>
                一般的なお話として、&lt;&gt;で囲むとコンパイラーの規定の場所とコンパイルオプションで指定した(gccなら-Iオプション)場所からヘッダーファイルを探します。<br>
                また、""で囲むと、それに加えて、#includeを書いたファイルと同じ場所も捜索対象になります。<br>
                ゆえに自分で作ったヘッダーは""で囲い、C/C++標準ライブラリ―のヘッダーは&lt;&gt;で囲むのが普通です。ありきたり。
            </p>
        </section>
        <section>
            <h3>#define</h3>
            <p>しばしば、const, enumと並んで定数を作る、と言われますが、残念ながらいずれも定数ではありません。</p>
            <p>#defineはコンパイル前にソースコードを置換するものです。で、「マクロ」と呼ばれます。Excelとかのマクロとはちと違うので注意です。</p>
            <pre class="brush: cpp;">#define WINDOW_HEIGH 1024</pre>
            <p>こんな風に定数っぽいのを作ることもできますし</p>
            <pre class="brush: cpp;">#define MAX(A, B) (A > B)? A : B</pre>
            <p>みたいに関数もどきも作れます。・・・がしかし、使いません。だってそれぞれ</p>
            <pre class="brush: cpp;">static const int WINDOW_HEIGH = 1024;
template&lt;typename T_&gt;
inline T_ max(T_ a, T_ b){
    return (a > b)? a : b;
}</pre>
            <p>のほうがわかりやすいじゃん。で、マクロを何に使うかというと、コンパイラー間の差異を吸収するために使います。どういうことでしょうか？</p>
            <p>
                最初に話したとおり、コンパイラーには何種類か有りますが、その中でも人口が多いVisual Studio C Compiler(以降VC)とGNU C Compiler(以降gcc)の２つだけ見ても、その差異は大きいです。<br>
                例えばfloat型とdouble型の計算速度のところで出したサンプルコードを見てみましょう。
            </p>
            <pre class="brush: cpp; first-line: 4">#ifndef __GNUC__
#pragma comment(lib, "setupapi.lib")
#pragma comment(lib, "hid.lib")
#pragma comment(lib, "winmm.lib")
#endif</pre>
            <p>
                ifndefというのはそのマクロ(この場合__GNUC__)が既に定義されているかを(プリプロセッサが)調べ、真なら対応するendifまでを有効にするものですが(偽ならその部分はコンパイラーに渡されない)<br>
                あとで説明する通りgccは「#pragma comment」という書き方はできません。この場合だとコンパイルオプションに
            </p>
            <pre class="brush: plain">-lsetupapi -lhid -lwinmm</pre>
            <p>つけるわけですが・・・ってそんな話はよくって、対応してない機能をコンパイラーに渡すと当然コンパイルエラーになるのでこのようにgccコンパイラーでコンパイルする時を考えてこのように書いています。</p>
            <p>すでに察しているかもしれませんが何も書かなくてもいくつかのマクロがdefineされています。例えばVCなら_MSC_VER、gccなら__GNUC__,__GNUC_MINOR__などがその代表的なものになります。</p>
            <pre class="brush: cpp; first-line: 3;" title="arikitari.h">#if (defined(_MSC_VER) && _MSC_VER > 1000) || defined (__GNUC__) && (__GNUC__ >= 4 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#pragma once
#endif</pre>
            <p>
                ヘッダーファイルに分ける、のところで書いたこの文の意味も今なら分かるでしょう。<br>
                #pragma onceという書き方に対応したのがVisual Studio.NET 2003以降、gcc3.4以降だからです。
            </p>
        </section>
        <section>
            <h3>#pragma comment</h3>
            <p>なんかすでに使っているので解説が必要か疑問ですが、.libファイルや.aファイルをリンカーにくっつけて、とお願いするために使います。ただし先述の通りVCやclang,bcc等限定の機能になります。</p>
            <p>なのでgccでコンパイルする予定があるなら(常にその可能性を想定するべきですが)さっきのような対策が必要です。</p>
        </section>
        <section>
            <h3>#pragma onceとインクルードガード</h3>
            <p>その昔#pragma onceが使えなかった頃、ヘッダーファイルが複数読み込まれると、2重定義です、と言われコンパイルエラーになりました。この対策として</p>
            <pre class="brush: cpp;">#ifndef _INC_STDIO
#define_INC_STDIO
//ヘッダーファイルの中身を書く
#endif /* _INC_STDIO */</pre>
            <p>といったことをしていました。こういう書き方をインクルードガードといいます。でもこんなの書くのはめんdいですよね？そこで生まれたのが#pragma onceです。</p>
            <p>ヘッダーファイルの冒頭に</p>
            <pre class="brush: cpp;">#pragma once</pre>
            <p>と書くだけです。</p>
            <p>ただし、普通は#defineを使ったインクルードガードと併用します。その理由は実際に使っていれば分かるはず。複数のヘッダーで同じことを書かないといけない時にこれがあると便利なんです。</p>
        </section>
        <section>
            <h3>#pragma warning</h3>
            <p>実例を見たほうが早いでしょう。プログラムはAviUtlプラグインで有名な透過性ロゴフィルター(makki氏)のSIMD化版(rigaya氏)の一部です。</p>
            <pre class="brush: cpp; highlight:[11,12];">#pragma warning (push)
#pragma warning (disable: 4244) //C4244: '=' : 'int' から 'short' への変換です。データが失われる可能性があります。
static BOOL create_adj_exdata(FILTER *fp, LOGO_HEADER *adjdata, const LOGO_HEADER *data)
{
	int i, j;
	if (data == NULL)
		return FALSE;
	// ロゴ名コピー
	memcpy(adjdata->name, data->name, LOGO_MAX_NAME);
	// 左上座標設定（位置調整後）
	adjdata->x = data->x + (int)(fp->track[LOGO_X]-LOGO_XY_MIN)/4 + LOGO_XY_MIN/4;
	adjdata->y = data->y + (int)(fp->track[LOGO_Y]-LOGO_XY_MIN)/4 + LOGO_XY_MIN/4;
	//中略
	return TRUE;
}
#pragma warning (pop)</pre>
            <p>
                このプログラムでは11,12行目がint型からshorに暗黙の型変換を行おうとしているのでコンパイル警告が出ます。<br>
                もしshort型で表せない大きさのデータだったら正常に変換できないのでこの警告はもっともな話です。むしろ警告してくれてありがとうです。<br>
                しかし、作者曰くこの場合はそうはならないらしいです。だとすればその警告は目障りです。なのでこのように#pragma warningを使って警告を消しています。<br>
                ただしプログラム全体でその警告が消えると不都合なので、この関数だけ警告が消えるように#pragma warning (push)/(pop)しています。
            </p>
            <p>
                ただしこの書き方はVCの書き方でgccだとまた書き方が違います。<br>
                VCだと警告番号ですがgccやclangだと警告の種類を指定するようです。<br>
                warning | MSDN<br>
                <a href="https://msdn.microsoft.com/ja-jp/library/2c8f766e.aspx">https://msdn.microsoft.com/ja-jp/library/2c8f766e.aspx</a><br>
                Diagnostic Pragmas - Using the GNU Compiler Collection (GCC)<br>
                <a href="https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Pragmas.html">https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Pragmas.html</a><br>
                controlling diagnostics via pragmas | clang 3.7 documentation<br>
                <a href="http://clang.llvm.org/docs/UsersManual.html#controlling-diagnostics-via-pragmas">http://clang.llvm.org/docs/UsersManual.html#controlling-diagnostics-via-pragmas</a>
            </p>
            <pre class="brush: cpp;" title="VC">#pragma warning (push)
#pragma warning (disable: [警告番号])
    //警告を無効にする部分のコード
#pragma warning (pop)</pre>
            <pre class="brush: cpp;" title="gcc">#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "[警告の種類]"
    //警告を無効にする部分のコード
#pragma GCC diagnostic pop</pre>
            <pre class="brush: cpp;" title="clang">#pragma clang diagnostic push
#pragma clang diagnostic ignored "[警告の種類]"
    //警告を無効にする部分のコード
#pragma clang diagnostic pop</pre>
            <p>
                大事なことを言います。本来警告が出たら出ないようなコードを書くべきなのです。このように警告を消したり、キャストして警告を消すのはやってはいけません。<br>
                なんどでもいいますが、本来は「警告を出していただき、コンパイラー様、ありがとうございます」なのです。<br>
                明確に問題ない、と言える警告を除き、警告を消すことのないようにしましょう。
            </p>
        </section>
    </section>
    <section>
        <h2>標準出力(stdout)</h2>
        <p>
            すでにputs関数やprintf関数を何気なく使っていますが、標準出力について説明していませんでした。<br>
            標準出力とは、プログラムが書き出すデータのストリームのことで、とくに指定しない限りコンソール画面に出力されます。<br>
            と、書けば察しがつくと思いますが、標準出力は変えられます。リダイレクトでググってください。<br>
            それ故、puts, printf関数などは「コンソール画面に文字を表示する関数」としばしば誤解されます。<br>
            なお、stdoutとはSTanDard OUTputの略です。C++は違いますが、他の言語でもこの言葉が使われることがおおいです。
        </p>
        <section>
            <h3>よく使う標準出力関係の関数</h3>
            <pre class="brush: cpp;">int puts(const char *str );
int printf(const char *format [,argument]...);
int fprintf(FILE *stream, const char *format [,argument ]...);
int fputc(int c, FILE *stream);
int putchar(int c );</pre>
        </section>
        <p>C言語の標準出力関数、とくにprintf関数はとても優秀で、正直C++の出力方法よりよほど使いやすいです。ちなみにC++では</p>
        <pre class="brush: cpp;">std::cout << "arikitari na world!" << std::endl;</pre>
        <p>のようにします・・・が、はっきり言って使いにくいです。C++はたしかに使いやすいですが、標準出力の使いにくさだけはいただけません。</p>
    </section>
    <section>
        <h2>標準エラー出力(stderr)</h2>
        <p>はっきりいって出番は少ないです。が、標準出力をたとえばファイルにリダイレクトした時、エラーはコンソールに出す、みたいなときには便利ですし、習慣的にエラーは標準エラー出力に出力することになっています。</p>
        <section>
            <h3>よく使う標準出力関係の関数</h3>
            <pre class="brush: cpp;">int fprintf(FILE *stream, const char *format [,argument ]...);</pre>
        </section>
    </section>
    <section>
        <h2>標準入力(stdin)</h2>
        <p>
            C言語の標準入力ははっきり言ってクソです。どれくらいクソかというと、標準ライブラリーにまともに数値を受ける関数がありません。<br>
            数値入力を受けたいだけなのに一度文字列として受け取りそれを数値に変換する処理を自前で書かないといけないなんてアホでしょ。<br>
            また、入力ストリームへの攻撃対策が弱かったり、しばしば改行文字を入力ストリームに置き去りにしたりと、文字すら安全に読み込むのは難しいのです。<br>
            その代表格がgets関数です。文字列を受け取る関数なのですが、あまりの危険性から、C99では非推奨、そしてついにC11では使用禁止になりました。<br>
            この背景には、後述しますがC言語にはそもそも「文字列」という概念がない、ということがあります。文字の実態はただの数字で、文字列はその集合でしかないのです。<br>
            そんなC言語でどうにかこうにか安全に標準入力を扱おう、というのが今回の目標です。
        </p>
        <p>
            まさかの愚痴スタートです、すみませんでした。標準入力とは、プログラムに入ってくるテキストデータのストリームです。<br>
            殆どの場合、キーボードから文字入力を受けます。言語を問わず数値入力を受けるためには一度文字列として読み込み、数値に変換する、という作業を行いますが、他の言語ではその作業を意識することはありません。
            先程から、C言語の標準入力は糞だ、と言っていますが、少なくとも文字列の入力を受けることに関しては改善されてきています。<br>
            MSVCではVisual Studio 2005の頃から、C標準ライブラリーを置き換える関数群を提供しています。scanf_sなどのように末尾に「_s」が付きます。<br>
            またC11でこれに追従する(というよりほぼパクリ・・・)ように同名の関数を提供しています。これはgcc4.9.1くらいからつかえます。<br>
            まあ、実例を見て行きましょうか。
        </p>
        <script src="http://gist-it.appspot.com/github/yumetodo/2015_C_Textbook/blob/gh-pages/src/stdin/stdin/Source.c"></script>
        <p>
            2通り目と3通り目の文字列読み込みでは、文字入力で大概の参考書で真っ先に使うscanf関数を紹介しましたが、個人的にはscanf関数は使いにくいなぁという印象です。<br>
            私はfgetsで改行文字ごと読み込んで改行文字をNULL文字に置き換えるほうが好きです。理屈が単純ということはそれだけバグを減らせるので。<br>
            もちろんscanfにはそれなりの良さがあるわけですが、だとしても3番目のように一度読み込んでからsscanfしますね。
        </p>
        <p>get_integer_num関数については簡単に説明すると、まず、fgets関数で文字列を受け、文字列をstrtol関数で数値に変換しています。</p>
        <p>というわけでポインターと文字列について何一つ説明していないのにばんばん使っていますが、すみません。すぐに解説します。</p>
        <article>
            <h3>練習問題</h3>
            <p>以下のソースコードは標準入力から数値を受け取り、指定範囲内でない数値に対しては再度入力を促すプログラムである。</p>
            <p>しかし、これは意図した動作をしない。問題点を可能な限り多くあげよ(getnum関数はget_integer_num関数のもとになった関数でエラー対策に難がありますが、そこはスルーしてください)</p>
            <pre class="brush: cpp;">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int getnum(void){
	char s[100];
	long t;
	char *endptr;
	fgets(s, 100, stdin);
	errno = 0;
	t = strtol(s, &endptr, 10);
	if (errno != 0 || *endptr != '\n' || (t < INT_MIN || INT_MAX < t))
		return -1;
	return t;
}
int getnum_customized(const int max, const int min){
	if (max < min)	return -1;
	int flag0;
	do{
		flag0 = getnum();
		if (flag0 < min || flag0 > max)
			system("cls");
			printf("再入力してください。\n");
	} while (flag0 < min || flag0 > max + 1);
	return flag0;
}
int main(void){
	printf("値を入力してください。\n");
	const int flag = getnum_customized(100, 0);
	printf("取得した値は%dです。\n", flag);

	return 0;
}</pre>
            <section>
                <h4>回答</h4>
                <ol>
                    <li>
                        <div>
                            <p>19-21行目は19行目の時の条件を満たした場合に20,21行目を実行することを意図していると思われるが、この書き方では21行目は条件判定にかかわらず実行される。</p>
                            <pre class="brush: cpp; first-line: 19">		if (flag0 < min || flag0 > max){
			system("cls");
			printf("再入力してください。\n");
        }</pre>
                            <p>が正しい。前に「エラー処理等、明確に実行文が1行しかない、と言える時を除き、原則{}はつけましょう。」と言った理由はこれ。もともと20行目はなく、このコードを書いた人曰く後から追加したらしい。</p>
                        </div>
                    </li>
                    <li>
                        19行目と22行目に注目すると、条件判定がおかしいことに気がつく。つまり、先の修正を踏まえると、flag0がmaxと同値の時、再入力を求める文章が出るのにもかかわらず、実際には再入力することなdo-while文を抜けてしまう。
                    </li>
                    <li>
                        18行目に注目すると、getnum関数の戻り値チェックをしていないことに気がつく。このgetnum関数は11行目にあるようにエラー時は-1を返すので、その判定をする必要がある。つまり
                        <pre class="brush: cpp;">if (-1 == flag0 || flag0 < min || flag0 > max){</pre>
                        とするべきである。
                    </li>
                </ol>
                <p>これらを踏まえ、また無駄な条件判定を減らし、getnum関数を上に上げたget_integer_num関数に置き換えると</p>
                <pre class="brush: cpp;">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;limits.h&gt;//in gcc
#include&lt;errno.h&gt;//in gcc
#ifndef _cplusplus
#define nullptr NULL
#endif
int get_integer_num(const int max, const int min){
	//機能：標準入力を数字に変換する。
	//引数：戻り値の最大値,戻り値の最小値
	//戻り値：入力した数字、エラー時は-1,EOFのときはEOF
	char s[100];
	char *endptr;
	if (nullptr == fgets(s, 100, stdin)){
		if (feof(stdin)){//エラーの原因がEOFか切り分け
			return EOF;
		}
		return INT_MIN;
	}
	if ('\n' == s[0]) return INT_MIN;
	errno = 0;
	const long t = strtol(s, &endptr, 10);
	if (0 != errno || '\n' != *endptr || t < min || max < t)
		return INT_MIN;
	return (int)t;
}
int getnum_customized(const int max, const int min){
	if (max < min)	return -1;
	int flag0;
	bool temp_judge;
	do{
		flag0 = get_integer_num(max, min);
		temp_judge = (INT_MIN == flag0);
		if (temp_judge){
			system("cls");
			puts("再入力してください。");
		}
	} while (temp_judge);
	return flag0;
}
int main(void){
	puts("値を入力してください。");
	const int flag = getnum_customized(100, 0);
	if(EOF == flag){
		puts("ファイル終端です");
	}
	else{
		printf("取得した値は%dです。\n", flag);
	}
	return 0;
}</pre>
            </section>
        </article>
    </section>
</body>
</html>
