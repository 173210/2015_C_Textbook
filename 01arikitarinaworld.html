<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <title>01はじめの一歩</title>
    <script src="./syntaxhighlighter/scripts/shCore.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushPlain.js" type="text/javascript"></script>
    <script src="./syntaxhighlighter/scripts/shBrushCpp_kai.js" type="text/javascript"></script>
    <link href="./syntaxhighlighter/styles/shCore.css" rel="stylesheet" type="text/css">
    <link href="./syntaxhighlighter/styles/shThemeMidnight_likeVS.css" rel="stylesheet" type="text/css">
    <script type="text/javascript">
        SyntaxHighlighter.all();
    </script>
</head>
<body>
    <section>
        <h2>ありきたりなworld</h2>
        <p>面倒なことは後回しにしてまずは画面に文字を表示させてみましょう。</p>
        <script src="http://gist-it.appspot.com/github/yumetodo/2015_C_Textbook/blob/gh-pages/src/001_arikitari_na_world.c"></script>
        <p>え？なんでHello Worldじゃないんだ？私printf関数を使うって聞いたんだけどputsって何？いやいや、こっちのほうがありきたり（普通）ですから。（なぜprintfでなくputsを使ったのかは後で説明します）</p>
        <p>このコードから多くのことが学べます。まずは一行目。</p>
        <pre class="brush: cpp;">#include&lt;stdio.h&gt;</pre>
        <p>これはヘッダーファイルと呼ばれるものを読み込む部分です。stdio.hはC言語が提供する標準ライブラリで、標準入出力(STanDard Input and Output)に関わる関数群を提供します。puts関数とかprintf関数はこれを読み込むことで使えるようになります。</p>
        <p>ついで2行目と4行目に注目してください。</p>
        <pre class="brush: cpp; first-line: 2; highlight:[2,4];">int main(void){
    puts("arikitari na world!");//画面に表示
    return 0;
}</pre>
        <p>C/C++言語は必ず関数があり、特に別途定めない限りmain関数から処理が始まります。詳細説明は先送りするとして関数には戻り値というものがあり、void型以外では必ず戻り値を返す必要があります。<br>
        main関数の戻り値は、プログラムの処理がmain関数から始まるため、プログラムの終了コード(Exist Code)とも呼ばれます。処理が成功した場合は0を返す(return 0;)のが慣習となっています。</p>
    </section>
    <section>
        <h2>main関数の書き方</h2>
        <p>main関数ですが、ANCI-C規格で書き方が決まっています。(非フリースタンディング環境の場合)</p>
        <pre class="brush: cpp;">int main(void);
int main(int argc, char* argv[]);
int main()</pre>
        <p>1行目は引数を無視する書き方で、2行目は引数(関数の解説の章で解説します)を受け取るときの書き方、3行目はC++のmain関数の引数を受け取らない書き方となり、C99でも認められます。</p>
        <p>というわけでmain関数は上記何れかの書き方で書きましょう、というお話です。個人的にはちゃんとvoidと書きたい派です。</p>
        <p>まちがっても</p>
        <pre class="brush: cpp;">main();
void main(void);</pre>
        <p>などとしてはいけません(前者は古いCの記法、後者は頭がおかしい書き方)。</p>
    </section>
    <section>
        <h2>main関数の引数って何？</h2>
        <p>先ほどさらっと「引数」という言葉を使いましたが、解説がまだでした。実例を見て行きましょう。</p>
        <script src="http://gist-it.appspot.com/github/yumetodo/2015_C_Textbook/blob/gh-pages/src/002_show_argv.c"></script>
        <p>さて疑問が噴出していることと思いますが気にすることはありません。ifとかforとかはちゃんと後で説明します。これをコンパイルしてできた002_show_argv.exeを</p>
        <pre class="brush: plain;">002_show_argv.exe arikitari na world!</pre>
        <p>のように実行してみてください。すると</p>
        <pre class="brush: plain;">argv[0]:[任意の場所]\002_show_argv.exe
argv[1]:arikitari
argv[2]:na
argv[3]:world!
</pre>
        <p>のようになったと思います。こんな感じでexeはコマンドライン引数を受け取れるんだなぁと思っていてください。</p>
    </section>
    <section>
        <h2>コメントの書き方</h2>
        <p>今はこんなに短いプログラムですから、必要性は薄いですが、もっと大規模に慣ればなるほど、ソースコードにメモを書きたくなります。すでにさらっと使っていますが、書き方は2通りあります。</p>
        <pre class="brush: cpp;">/*これは行をまたがって使えるコメント*/
//これはその行の終わりまでコメントになる</pre>
        <p>2行目がANCI-C認められたのはC99からなんですが、ほとんどのコンパイラーが対応してましたからどんどんつかって構いません。</p>
        <p>注意点ですが、一行目の書き方のコメントはネスト（入れ子）にできません</p>
        <pre class="brush: cpp;">/*これはコメント
/*ここもコメントだけど*/
ここはコメントじゃない*/</pre>
        <p>稀によくあるミスなので注意です。だから私はコメントを書くときは基本的に2行目のいわゆる行コメントを使うのをおすすめします。</p>
    </section>
    <section>
        <h2>変数と代入</h2>
        <p>プログラミング言語で必ずあるものといえば、真っ先に変数が上がるでしょう。変数とは処理途中のデータ（数字など）を保管しておく箱のようなものです。</p>
        <pre class="brush: cpp;">int a;
a = 10;
int numof_allocated_array_at_a_time = 15;
char ch = getchar();</pre>
        <p>1行目では変数を宣言し定義しています。宣言は「こんな変数があるよ」とコンパイラに教える作業で、定義は「ここで変数を確保するよ」とコンパイラに教えることです。<br>
        定義して初めてメモリ上に実体を持ち、変数を使えるようになるわけです。が、とりあえずヘッダーファイルを分けるようなことになるまでは、宣言も定義も同じと考えていいです。<br>
        まとめると、メモリ上に変数を保管する場所を確保し、場所に名前をつけた、という状態です。</p>
        <p>2行目は1行目で定義した変数aに10という値を代入しています。変数aは初めてここで使うのでこれは初期化作業とも言います。</p>
        <dl>
            <dt>代入</dt>
            <dd>数学の代入とは少し違います。2行目の場合はaに10という値を記憶する、という意味になります。ここでつまずくとプログラミングができなくなるので、しっかり抑えてください。</dd>
            <dt>初期化</dt>
            <dd>
                初期化、という言葉はかなり多くの人が誤解しています。0を代入することを初期化、と考える人が後を絶ちません。<br>
                1行目で変数を宣言し定義しましたが、この状態ではaにどんな値が入っているかは不定です。<br>
                2行目のように、プログラマがその変数に何が入っているかわかるようにすることを初期化といいます。<br>
                ポインタの話が出てこない限りは、とりあえず定義した後初めて値を代入すれば、初期化している、と思って構いません。<br>
                ポインタが絡んだ時のことは、その時にゆっくり解説します。
            </dd>
        </dl>
        <p>1行目でメモリーを確保し、その領域にお名前（識別名）をつけて、2行目でその領域に値を書き込んだ、といったほうがわかりやすい・・・のかな？</p>
        <p>1行目と2行目をまとめて書いたのが3行目です。4行目のように関数の戻り値を代入することもできます（関数については後述）</p>
    </section>

    <section>
        <h2>変数の型</h2>
        <p>C/C++言語はとくに型にうるさい言語として知られています。(JavaScriptやperlなど型を明示できない言語もある)。C++なんて型なしではやっていけません。</p>
        <p>じゃあその「型」ってなんでしょうか？</p>
        <table>
            <colgroup style="width: 32px;"></colgroup>
            <colgroup style="width: 99px;"></colgroup>
            <colgroup style="width: 85px;"></colgroup>
            <colgroup style="width: 95px;"></colgroup>
            <colgroup style="width: 95px;"></colgroup>
            <colgroup style="width: 120px;"></colgroup>
            <tr>
                <th>基本型名</th>
                <th>整数型/浮動小数点型</th>
                <th>型の大きさ</th>
                <th>signedの最大値を求めるマクロ</th>
                <th>signedの(実数の)最小値を求めるマクロ</th>
                <th>unsignedの最大値を求めるマクロ</th>
                <th>使用例</th>
            </tr>
            <tr>
                <td>void</td>
                <td>不定</td>
                <td>不定</td>
                <td>不定</td>
                <td>存在しない</td>
                <td>存在しない</td>
                <td>ほぼ例外なく関数かポインタとともに用いるので省略</td>
            </tr>
            <tr>
                <td>bool型(C99,C++)</td>
                <td>論理型</td>
                <td>不定</td>
                <td>存在しない</td>
                <td>存在しない</td>
                <td>存在しない</td>
                <td><pre class="brush: cpp; gutter:false;">bool is_alphabet = true;</pre></td>
            </tr>
            <tr>
                <td>char</td>
                <td>整数型</td>
                <td>1byte</td>
                <td>SCHAR_MAX</td>
                <td>SCHAR_MIN</td>
                <td>UCHAR_MAX</td>
                <td><pre class="brush: cpp; gutter:false;">char delim = ',';</pre></td>
            </tr>
            <tr>
                <td>short(short int)</td>
                <td>整数型</td>
                <td>不定</td>
                <td>SHRT_MAX</td>
                <td>SHRT_MIN</td>
                <td>USHRT_MAX</td>
                <td><pre class="brush: cpp; gutter:false;">short rect_x = 320;</pre></td>
            </tr>
            <tr>
                <td>int</td>
                <td>整数型</td>
                <td>不定</td>
                <td>INT_MAX</td>
                <td>INT_MIN</td>
                <td>UINT_MAX</td>
                <td><pre class="brush: cpp; gutter:false;">int a = 3;</pre></td>
            </tr>
            <tr>
                <td>long(long int)</td>
                <td>整数型</td>
                <td>不定</td>
                <td>LONG_MAX</td>
                <td>LONG_MIN</td>
                <td>ULONG_MAX</td>
                <td><pre class="brush: cpp; gutter:false;">long size = 217;</pre></td>
            </tr>
            <tr>
                <td>long long</td>
                <td>整数型</td>
                <td>不定</td>
                <td>LLONG_MAX</td>
                <td>LLONG_MIN</td>
                <td>ULLONG_MAX</td>
                <td><pre class="brush: cpp; gutter:false;">long long size = 217;</pre></td>
            </tr>
            <tr>
                <td>float</td>
                <td>浮動小数点型</td>
                <td>不定</td>
                <td>FLT_MAX</td>
                <td>-FLT_MAX</td>
                <td>そんなものはない</td>
                <td><pre class="brush: cpp; gutter:false;">long long size = 217;</pre></td>
            </tr>
            <tr>
                <td>double</td>
                <td>浮動小数点型</td>
                <td>不定</td>
                <td>DBL_MAX</td>
                <td>-DBL_MAX</td>
                <td>そんなものはない</td>
                <td><pre class="brush: cpp; gutter:false;">long long size = 217;</pre></td>
            </tr>
        </table>
        <p>FLT_MAXって「魔法科高校の劣等生」の「<a href="http://www49.atwiki.jp/mahouka/pages/18.html">four leaves technology</a>」みたいでかっこいい！・・・話がそれた。<br>
        以上にc言語(c99)の基本型を上げてみた。各型によってメモリー上での大きさ（表せる値の範囲）や表せるものが違う。</p>
        <p>INT_MAXとかマクロとかって何？ってなると思うが、そう遠くなくお世話になるだろうから載せておく。解説は後ほど。</p>
        <section class="description_detile">
            <h3>ちと難しい話</h3>
            <p>C言語で型の大きさについての規定はほとんどなく、</p>
            <ul>
                <li>char型は1バイト(8ビットとは言っていない)</li>
                <li>型の大きさは、short <= int <= long <= long long　である。</li>
                <li>int型は -32767～+32767 の範囲が扱える</li>
            </ul>
            <p>程度しかない。小数点型に関しては特に規定はないが、事実上IEEE 754に従うので、（今どき従わない非フリースタンディング環境なんてあるのかね？）浮動小数点型についてはIEEE 754を参照すると良い。</p>
        </section>
        <p>まあ、ほとんどcharかdoubleかintしか使わない。ほんと。</p>
        <section class="common_misconception">
            <h3>よくある誤解</h3>
            <ul>
                <li>
                    char型は8bitだ<br>
                    →誤り。1byteと定められているだけで、1byte=8bitとは限らない。（確かに殆どの場合でchar型は8bitだけど）
                </li>
                <li>
                    1byte=8bitのとき、signed charは-128～127まで表せる<br>
                    →誤り。トラップ表現があることがあるので-127～-127までとなる（殆どの場合でトラップ表現を考慮する必要はないが）<br>
                    参考サイト:<a href="http://www.kijineko.co.jp/node/722">http://www.kijineko.co.jp/node/722</a>
                </li>
                <li>
                    int型は4byteである<br>
                    →誤り。2byteの時代もあったし、8byteの処理系も存在する。
                </li>
                <li>
                    float型のほうがdouble型より演算が速い<br>
                    →デマ。double型の演算器がない時代のお話。今はどちらでも等速。<br>
                    下記のコードで実験できる。いろんなコンパイルオプションで試してみよう。makeファイルとかslnファイルは<br>
                    <a href="https://github.com/yumetodo/2015_C_Textbook/tree/gh-pages/src/double_vs_float">https://github.com/yumetodo/2015_C_Textbook/tree/gh-pages/src/double_vs_float</a><br>
                    <script src="http://gist-it.appspot.com/github/yumetodo/2015_C_Textbook/blob/gh-pages/src/double_vs_float/double_vs_float/Source.cpp"></script>
                </li>
            </ul>
        </section>
        <section class="technique">
            <h3>コーディングの作法</h3>
            <p>厳密に型の大きさが定まっている必要が出ることは少なく、boolかcharかdoubleかintしか出番はないはず、それ以外を選択しようとしているなら、本当に必要か考えなおそう。</p>
        </section>
    </section>

    <section>
        <h2>signedとunsigned</h2>
        <p>既にちらっと書いてますが、整数型にはsignedとunsignedがあります（浮動小数点型にunsignedはない）。<br>
        御存知の通り、PCと言うのはすべてのデータを2進数で表しています。この2進数の一桁をbitと言うわけですが、<br>
        1bitを使って正の数か負の数かわかるようにしているのがsigned、すべて正の数とみなすのがunsignedになります。<br>
        正の数か負の数かのフラグを使わない分、unsignedの最大値はsignedの最大値のほぼ2倍になります。</p>
        <p>
            例：1byte=8bit,int型の大きさ(sizeof(int))を4byteと仮定すると、<br>
            INT_MAX:    2147483647<br>
            UINT_MAX:   4294967295
        </p>
        <p>char型以外では、signedやunsignedを省略するとsignedとして扱われます。char型の場合は処理系定義となります(VCのデフォルトはsigned)。</p>
        <pre class="brush: cpp;">int tmp = 5;
signed int tmp = 5;
unsigned int tmp = 5;
char temp = 6;
signed char temp = 6;
unsigned char temp = 6</pre>
        <p>1行目と2行目は同値。4行目と5行目が同値である保証はないし、だからといって4行目と6行目が同値である保証もない（処理系定義）</p>
    </section>

    <section>
        <h2>typedef</h2>
        <p>C/C++にはtypedefという便利な機能があります。さっそく使ってみましょう。</p>
        <pre class="brush: cpp;">typedef unsigned long DWORD;
typedef DWORD COLORREF;
unsigned long window_head = 0x00FFCCFF;
COLORREF window_head = 0x00FFCCFF;</pre>
        <p>typedefとは、<b>"すでにある"</b>型に別名をつける機能です。<br>
        1行目ではunsigned long型にDWORD型という別名をつけています。<br>
        2行目ではDWORD型にCOLORREF型という別名をつけています。</p>
        <p>
            こんな風に別名を付けて何がありがたいかというと、型名を調べるだけでそのデータの格納方法がわかるということです。<br>
            3行目では何をしているのかさっぱりですが、4行目を見るとなんか色が関係することをやってるんだな、と察せます。<br>
            さらに「COLORREF」でぐぐれば、その詳細もわかります。<br>
            <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/dd183449%28v=vs.85%29.aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/dd183449%28v=vs.85%29.aspx</a><br>
            <q>When specifying an explicit RGB color, the COLORREF value has the following hexadecimal form:0x00bbggrr</q><br>
            ちなみに1行目と2行目はいずれもWindef.hで定義されているものの引用です。Win32APIに触りたいと思っている方、よく覚えておきましょう。かならすお世話になるでしょう。
        </p>
        <section class="technique">
            <h3>コーディングの作法</h3>
            <p>char型は整数型ですが、主に文字を扱うのに使うことが多い型です。文字以外のデータを扱うのにchar型を使うことは、コードの可読性を下げます。</p>
            <pre class="brush: cpp;">typedef unsigned char myuint8_t;
typedef signed char myint8_t;</pre>
            のようにtypedefして使うようにしましょう。
        </section>
    </section>

    <section>
        <h2>整数リテラル</h2>
        <pre class="brush: cpp;">unsigned int len = 20;</pre>
        <p>のように、何気なく数値を書いていますが、この数値は「リテラル」と呼ばれます。どう見ても小数ではないのでこれは「整数リテラル」ですね。</p>
        <p>
            なお、浮動小数点リテラルについては<br>
            C++11の文法と機能(C++11: Syntax and Feature)<br>
            <a href="http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#lex.fcon">http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#lex.fcon</a><br>
            に投げます。
        </p>
        <dl>
            <dt>2進数的記法(C++14,VisualStudio2013は未対応,VisualStudio2015は対応)</dt>
            <dd>
                <pre class="brush: cpp;">int a = 0b11;// 10進数では、3
int d = 0B1011 ;// 10進数では、11</pre>
                このように「0b」または「0B」のあとに数字を書きます。
            </dd>
            <dt>8進数的記法</dt>
            <dd>
                <pre class="brush: cpp; gutter:false;">int e = 01234;// 10進数では、668</pre>
                このように「0」のあとに数字を書きます。<b>8進数リテラルは、10進数と区別しにくいので、気をつける必要があります。</b>
            </dd>
            <dt>10進数的記法</dt>
            <dd><pre class="brush: cpp; gutter:false;">int t = 1234;</pre></dd>
            <dt>16進数的記法</dt>
            <dd>
                <pre class="brush: cpp; gutter:false;">int x = 0x1234 ;// 10進数では、4660</pre>
                このように「0x」のあとに数字を書きます。
            </dd>
        </dl>
        <p>なにが言いたいかというと、<b>うっかりして0から数字を書くな</b>よ！ということです。</p>
    </section>
    <section>
        <h2>const</h2>
        <p>ある変数をその後で変更する予定がないときはconstをつけるようにするべきです。constは変数を「Read-Only」にします。</p>
        <pre class="brush: cpp;">const unsigned int len = 20;
len = 21;//エラー</pre>
        <p>constをつけるときは定義と初期化は同時である必要があります。だって「Read-Only」だもん、後から変更できないんだから初期化も一緒にやらないとダメだよね。</p>
        <p>逆に言うと定義と初期化を同時に行うときは殆どの場合constをつけるべき場面です。</p>
        <p>注意になりますが、constは「定数」を作るものではありません、あくまで「Read-Only」にするものです。その違いはポインタのところで解説します。</p>
    </section>

    <section>
        <h2>自動変数の生存期間とスコープ</h2>
        <p>自動変数ってなんなんだってばよっ！となってると思いますが、「いままで出てきたような」変数です。ということはそうでない変数があることくらいは「お察しください」。</p>
        <p>スコープとはなにか、については見てもらったほうが速いと思います。</p>
        <pre class="brush: cpp;">{
    int a = 10;
    printf("%d\n", a);
}
printf("%d\n", a);//エラー
</pre>
        <p>ずばり{}がスコープです。え？main関数を書いた時に見た？はい、それもスコープです。詳細は関数とはなにかのところで説明します。</p>
        <p>スコープの中で確保された変数はスコープの外にでるときに開放されます。消えてなくなるわけです。よって5行目はエラーになります。</p>
        <p>printf関数を使うのは初めてなので補足します、とりあえず今はこうすると整数を表示できるんだな、と思っておいてくだい。浮動小数点型だと%dじゃなくて%fだったりlong型だと%ldだったりするわけですが。</p>
    </section>
    <section>
        <h2>C++11の型推論機能</h2>
        <p>ちょっとC言語を離れてC++を見ていきます。今は型が短いのでいいですが、今に</p>
        <pre class="brush: cpp;">vector&lt;string&gt;::iterator it;
map&lt;int,list&lt;string&gt;&gt;::iterator i</pre>
        <p>とか使い出します。こんなに長ったらく書くのはめんdいですし、タイピングミスしやすかったり、コードが見づらくなったりと、3拍子揃って書きたくないです。</p>
        <p>そこでauto型の出番です。</p>
        <pre class="brush: cpp;">unsigned int x = 10;
auto l = x;</pre>
        <p>とかすると変数lの型はint型になります。便利だね。なお、C++03まではautoは別の意味で使われていたので注意です。</p>
    </section>

    <section>
        <h2>四則演算</h2>
        <p>やっぱり計算出来ないとプログラミングは始まりません。というわけでまずは四則演算。</p>
        <pre class="brush: cpp;">int i = 0, delay_time;
//中略
i = i + 1;
double time = 8.5 - 2.1;
double cure = 1.5 * time;
double damage = cure / 10;
unsigned int temp1 = delay_time / 60;
tm_sec += delay_time % 60;
i += 1;
cure -= 10;
i++;
++i;
i--;
--i;</pre>
        <p>3行目から7行目が四則演算ですね。6行目の割り算は整数精度で行われ、小数点以下は0に近い方向に切り捨てられることを忘れないで下さい。</p>
        <p>8行目は割り算の余りを求めるものです。これは整数精度の時のみ使えます。もし浮動小数点型で割り算のあまりを求めたいときは、math.hのfmod関数を使いましょう。</p>
        <p>9行目は2行目の略記です。10行目のように引き算などほかの演算記号も同じように使えます。</p>
        <p>11行目と12行目はインクリメント演算子、13行目と14行目はデクリメント演算子と呼ばれます。1増やしたり1減らしたりする処理を簡便に書くことができます。</p>
        <table>
            <tr> <th>演算</th><th>演算子</th><th>例</th><th>意味</th> </tr>
            <tr> <td rowspan="2">インクリメント</td><td rowspan="2" class="Cent">++</td><td>a++</td><td>a に 1 を加える（後置演算）</td> </tr>
            <tr> <td>++a</td><td>a に 1 を加える（前置演算）</td> </tr>
            <tr> <td rowspan="2">デクリメント</td><td rowspan="2" class="Cent">--</td><td>a--</td><td>a から 1 を引く（後置演算）</td> </tr>
            <tr> <td>--a</td><td>a から 1 を引く（前置演算）</td> </tr>
        </table>
        <p>使用上の注意です。下のコードを見てくだい。</p>
        <script src="http://gist-it.appspot.com/github/yumetodo/2015_C_Textbook/blob/gh-pages/src/increment_decrement.c"></script>
        <p>インクリメント・デクリメント演算子は前置と後置で意味が変わるので注意です。私は覚えるのがめんdいので、後置しか使わない派です。</p>
    </section>

    <section>
        <h2>暗黙の型変換とキャスト</h2>
        <p>ここまでの例ではすべて計算するものの型は揃っていました。では違う場合はどうなるでしょう？</p>
        <pre class="brush: cpp;">const int a = 10;
const double b = 3;
auto ans = a / b;
int ans2 = ans;
auto ans3 = (int)ans;</pre>
        <p>変数ansの型はdouble、ansには3.3333333(以下略)が入ります。</p>
        <p>一方でans2の型はint、ans2には3が入ります。</p>
        <p>また3行目のように型を明示することもできます。これを「キャスト」といいます。ans3の型はint型になります。</p>
        <dl>
            <dt>式の中で行われる変換</dt>
            <dd>
                優先順位の高い型に変換されます。優先順位は<br>
                <q>bool &lt; char &lt; short &lt; int &lt; long &lt; long long &lt; float &lt; double</q><br>
                です。
            </dd>
            <dt>代入時の変換</dt>
            <dd>左辺の型と右辺の型が異なっている場合は、左辺の型に変換します。</dd>
            <dt>キャスト時の変換</dt>
            <dd>有無をいわさずに指定した型に変換されます。</dd>
        </dl>
        <p>この法則にしたがって解釈すると、3行目は、aの型はint、bの型はdoubleなのでaがdouble型に変換され(式の中で行われる変換)、double型同士の計算となります。<br>
        また4行目は変数ansの型はdoubleですが、左辺のans2の型がintなのでint型に変換されます(代入時の変換)。</p>
        <p>このことを利用して割り算の余り(surplus)を求めてみましょう。</p>
        <pre class="brush: cpp;">const double input = 23;
const int divisor = 7;
const int temp = (int)input / divisor;
const double surplus = input - (divisor * temp);</pre>
        <p>inputをキャストする必要があるのか？と怒られそうですが、べつに整数精度の結果で事足るのでキャストしました。</p>
        <p>よくキャストを「ある型とみなす」と説明する人が居ますが、誤りです。bitの並びが変わることもあることからわかるように、実際に変換されます。</p>
        <section class="technique">
            <h3>コーディングの作法</h3>
            <p>C言語のキャストは、非常に強力で、どんな型にでも変換ができます。ゆえにしてはいけない型変換もできてしまいます。</p>
            <p>そこでC++ではキャストが4種類にわかれました。</p>
            <table>
                <tbody>
                    <tr><th> 名称 </th><th> 説明 </th><th> 使用 </th></tr>
                    <tr><td>dynamic_cast</td><td> 基本クラスから派生クラスへのキャスト</td><td>使用するべきではない</td></tr>
                    <tr><td>const_cast</td><td> const を外すキャスト</td><td>使用するべきではない</td></tr>
                    <tr><td>static_cast</td><td> double から int など暗黙の変換のあるキャスト </td><td>使用可</td></tr>
                    <tr><td>reinterpret_cast</td><td> double * から long long などの無理やりキャスト </td><td>なるべく使用しない</td></tr>
                </tbody>
            </table>
            <p>
                詳細な説明は<br>
                キャスト | プログラマーズ雑記帳<br>
                <a href="http://yohshiy.blog.fc2.com/blog-category-9.html">http://yohshiy.blog.fc2.com/blog-category-9.html</a><br>
                に譲りますが、Cのキャストは理由がない限り使わず、C++のstatic_castを使用しましょう。
            </p>
            <pre class="brush: cpp;">const int temp = static_cast&lt;int&gt;(input) / divisor;</pre>
            <p>もっとも、まともなコーディングをしていれば、malloc,calloc,realloc関数以外でキャストを使う場面はないはずです。<br>
            もしあなたがキャストを使おうとしているならば、それはあなたが寝ぼけているのか、ライブラリ作者がうっかりしている、ということになります。<br>
            後者なら、作者に文句を言いましょう。(実際私はDxLibraryの作者に色の扱いについて文句を言って、Ver 3.13eで修正してもらいました)</p>
            <p>signedとunsignedの変換はとくに理由のない限りしないようにしましょう。</p>
        </section>
    </section>
    <section>
        <h2>promotionsとconversions</h2>
        <p>型変換、と一口に言っても2つあり、promotionsとconversionsとそれぞれ呼ばれます。</p>
        <p>
            promotionsがなにか、については<br>
            C++11の文法と機能(C++11: Syntax and Feature)<br>
            <a href="http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#conv.prom">http://ezoeryou.github.io/cpp-book/C++11-Syntax-and-Feature.xhtml#conv.prom</a><br>
            に丸投げするとして、promotionsでなければconversionsである(そりゃそーだ)。
        </p>
        <p>conversionsは一般に危険をはらんでいます。何故かというと、変換元の数値を変換先の型で表せないかもしれないからです。</p>
        <p>unsigned charが8ビット、unsigned intが16ビットと仮定して実例を上げてみましょう。</p>
        <pre class="brush: cpp;">int main(void){
    unsigned int ui = 1234 ;
    unsigned char uc = ui ; // 210
}</pre>
        <p>この場合、unsigned int型は、16ビット、uiの値は、2進数で表すと0000010011010010になります。unsigned char型は8ビット。つまり、この場合の対応する下位桁の値は、2進数で11010010（uiの下位8ビット）です。よって、ucは、10進数で210となります。 </p>
        <p>しかし、そもそも型変換でオーバーフローやアンダーフローを起こさないようにコーディングするべきでしょう。</p>
    </section>
    <section>
        <h2>stdint.h/cstdint</h2>
        <p>先ほど「文字以外の目的でchar型を使うときはtypedefして使うようにしましょう」と言いましたが、毎回typedefするのはめんdいです。</p>
        <p>また、先程から散々言ってるように、C/C++では型の大きさについて、明確な規定はほぼありません。これでは厳密に何bitかを使いたいとき(HTTP通信など)に困ってしまいます。</p>
        <p>そこでstdint.h/cstdintの出番です。これはC99/C++11で追加された標準ライブラリで、主に以下の型が使えます。</p>
        <blockquote>int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t, int64_t, uint64_t</blockquote>
        <p>これらは厳密に型の大きさが決まっています。(ゆえにすべての処理系で実装されているわけではない)</p>
        <pre class="brush: cpp;">uint8_t color_r = 187;
int64_t receive_timestamp;// 受信タイムスタンプ
//中略
int64_t sum = sum1 + sum2;</pre>
        <p>よく使うのはこの2つかな？あるって知ってると何かと便利。</p>
    </section>
    <section>
        <h2>ビット演算</h2>
        <p>ビッド演算とは、各bitに対して論理演算を行うことを指します。なお、特にシフト演算では、<b>変数はunsigned、または正の整数である必要があり</b>ます。負の数の場合動作は実装定義となります。</p>
        <p>まあ、そもそもsignedな整数にビット演算をするべきではありません。</p>
        <section>
            <h3>左シフト</h3>
            <pre class="brush: cpp;">uint32_t si_a = 5;//101
const uint32_t si_b = 4;
const uint32_t re_si = si_a &lt;&lt; si_b;//80:1010000</pre>
            <p>1つ左シフトするごとに、2をかけているのと同じ効果が得られる。この場合は2<sup>4</sup> = 16倍していることになる。</p>
            <p>かならず以下の点をコーディング時に確認して行うこと。</p>
            <ul>
                <li>
                    オーバーフローしないか<br>
                    左シフトの結果がその型の最大値を超えるようなことがあったらだめ、ということ。だからこれはだめ<br>
                    <pre class="brush: cpp; gutter:false;">unsigned int re = UINT_MAX << 1;</pre>
                </li>
                <li>
                    右オペランドが格上げ後の左オペランドの精度以下<br>
                    「オーバーフローしないか」ともつながるが、例えば32bit変数を32回以上左シフトしたら必ずオーバーフローする。<br>
                    具体的にはSSE4.2のPOPCNT命令を呼び出すMSVC独自拡張の__popcnt関数ないしmath.hのlog2関数を用い、左オペランドのビット数が右オペランド未満であることを確認する。<br>
                    <pre class="brush: cpp; gutter:false;">const uint32_t re_si = (si_b < __popcnt(UINT_MAX))? si_a &lt;&lt; si_b : 0;</pre>
                </li>
            </ul>
        </section>
        <section>
            <h3>右シフト</h3>
            <pre class="brush: cpp;">uint32_t si_a = 37;//100101
const uint32_t si_b = 4;
const uint32_t re_si = si_a &gt;&gt; si_b;//2:10</pre>
            <p>左シフトと逆の効果が得られる。</p>
            <p>かならず以下の点をコーディング時に確認して行うこと。</p>
            <ul>
                <li>
                    右オペランドが格上げ後の左オペランドの精度以下<br>
                    「オーバーフローしないか」ともつながるが、例えば32bit変数を32回以上左シフトしたら必ずオーバーフローする。<br>
                    具体的にはSSE4.2のPOPCNT命令を呼び出すMSVC独自拡張の__popcnt関数ないしmath.hのlog2関数を用い、左オペランドのビット数が右オペランド未満であることを確認する。<br>
                    <pre class="brush: cpp; gutter:false;">const uint32_t re_si = (si_b < __popcnt(UINT_MAX))? si_a &gt;&gt; si_b : 0;</pre>
                </li>
            </ul>
        </section>
        <section>
            <h2>ビットの論理積</h2>
            <pre class="brush: cpp;">const uint32_t a = 0b10110;//22
const uint32_t b = 0b11010;//26
const uint32_t re = a &amp; b;//18:0b10010</pre>
            <p>各bitにAND演算をします。</p>
            <img alt="AND" src="http://upload.wikimedia.org/wikipedia/ja/7/7b/Venn-Diagram-AND.png" class="thumbimage" data-file-width="186" data-file-height="110" height="110" width="186">
            <table>
                <tr>
                    <th>AND(&amp;)</th><th>1</th><th>0</th>
                </tr>
                <tr>
                    <th>1</th><td>1</td><td>0</td>
                </tr>
                <tr>
                    <th>0</th><td>0</td><td>0</td>
                </tr>
            </table>
            <p>結果はこの表に従います。</p>
        </section>
        <section>
            <h2>ビットの論理和</h2>
            <pre class="brush: cpp;">const uint32_t a = 0b10110;//22
const uint32_t b = 0b11010;//26
const uint32_t re = a | b;//30:0b11110</pre>
            <p>各bitにOR演算をします。</p>
            <img alt="OR" src="http://upload.wikimedia.org/wikipedia/ja/5/5e/Venn-Diagram-OR.png" class="thumbimage" data-file-width="186" data-file-height="110" height="110" width="186">
            <table>
                <tr>
                    <th>OR(|)</th><th>1</th><th>0</th>
                </tr>
                <tr>
                    <th>1</th><td>1</td><td>1</td>
                </tr>
                <tr>
                    <th>0</th><td>1</td><td>0</td>
                </tr>
            </table>
            <p>結果はこの表に従います。</p>
        </section>
        <section>
            <h2>ビットの排他論理和</h2>
            <pre class="brush: cpp;">const uint32_t a = 0b10110;//22
const uint32_t b = 0b11010;//26
const uint32_t re = a ^ b;//12:0b1100</pre>
            <p>各bitにXOR演算をします。</p>
            <img alt="XOR" src="http:////upload.wikimedia.org/wikipedia/ja/6/6b/Venn-Diagram-XOR.png" class="thumbimage" data-file-width="186" data-file-height="110" height="110" width="186">
            <table>
                <tr>
                    <th>XOR(|)</th><th>1</th><th>0</th>
                </tr>
                <tr>
                    <th>1</th><td>0</td><td>1</td>
                </tr>
                <tr>
                    <th>0</th><td>1</td><td>0</td>
                </tr>
            </table>
            <p>結果はこの表に従います。</p>
        </section>
        <section>
            <h2>ビットの反転</h2>
            <pre class="brush: cpp;">const uint32_t a = 0b10110;//22
const uint32_t re = ~a;//9:0b1001</pre>
            <p>各ビットにNOT演算をします。1の補数をとる、ともいいます。</p>
        </section>
    </section>

</body>
</html>
